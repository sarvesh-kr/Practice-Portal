{
    "data": {
        "Programming Concepts": [
            {
                "id": "GEN001",
                "question": "What is the output of the following C++ code?\n\nint x = 5;\ncout << x++ + ++x;",
                "options": [
                    "11",
                    "12",
                    "10",
                    "Undefined behavior"
                ],
                "answer": 3,
                "explanation": "In C++, modifying a variable twice between sequence points (like x++ and ++x in the same expression) results in undefined behavior."
            },
            {
                "id": "GEN002",
                "question": "What is the output of the following code?\n\nint a = 2;\nint b = a++ + ++a;\ncout << b;",
                "options": [
                    "5",
                    "6",
                    "7",
                    "Undefined behavior"
                ],
                "answer": 3,
                "explanation": "The variable 'a' is modified twice without an intervening sequence point, leading to undefined behavior according to the C++ standard."
            },
            {
                "id": "GEN003",
                "question": "What is the output of this Java snippet?\n\nint x = 10;\nSystem.out.println(x-- - --x);",
                "options": [
                    "1",
                    "2",
                    "0",
                    "-1"
                ],
                "answer": 1,
                "explanation": "x-- returns 10, x becomes 9; --x decrements to 8; 10 - 8 = 2."
            },
            {
                "id": "GEN004",
                "question": "Which of the following statements about recursion is TRUE?",
                "options": [
                    "All recursive functions can be converted to iterative",
                    "Recursive functions always use more memory than iteration",
                    "Tail recursion cannot be optimized by compiler",
                    "Recursion does not require a base case"
                ],
                "answer": 0,
                "explanation": "All recursion can theoretically be rewritten iteratively using stack or loop constructs."
            },
            {
                "id": "GEN005",
                "question": "What will be the output?\n\nint a = 1;\nint b = a+++a;\ncout << b;",
                "options": [
                    "2",
                    "3",
                    "4",
                    "Compiler error"
                ],
                "answer": 1,
                "explanation": "C++ uses 'maximal munch' logic, interpreting this as (a++) + a. Here, a++ is 1 (original value) and a then becomes 2. 1 + 2 = 3."
            },
            {
                "id": "GEN006",
                "question": "What is the output of the following C++ program?\n\nint arr[3] = {1,2,3};\ncout << *(arr+1);",
                "options": [
                    "1",
                    "2",
                    "3",
                    "Compilation error"
                ],
                "answer": 1,
                "explanation": "Pointer arithmetic: arr+1 points to second element; * gives value 2."
            },
            {
                "id": "GEN007",
                "question": "What is the output?\n\nint i = 5;\nint j = i & 3;\ncout << j;",
                "options": [
                    "1",
                    "2",
                    "3",
                    "0"
                ],
                "answer": 1,
                "explanation": "Bitwise AND: 0101 & 0011 = 0001 = 1."
            },
            {
                "id": "GEN008",
                "question": "Which of the following is TRUE about pass by value and pass by reference?",
                "options": [
                    "Pass by value modifies original variable",
                    "Pass by reference does not modify original variable",
                    "Pass by value copies the argument",
                    "Both pass by value and reference are the same"
                ],
                "answer": 2,
                "explanation": "Pass by value creates a copy; original variable remains unchanged."
            },
            {
                "id": "GEN009",
                "question": "Which loop is guaranteed to execute at least once?",
                "options": [
                    "for",
                    "while",
                    "do-while",
                    "All loops behave the same"
                ],
                "answer": 2,
                "explanation": "do-while executes body first before checking condition."
            },
            {
                "id": "GEN010",
                "question": "What will the following C++ code print?\n\nint x = 0;\nif(x=1)\n cout << x;\nelse\n cout << x+1;",
                "options": [
                    "0",
                    "1",
                    "2",
                    "Compilation error"
                ],
                "answer": 1,
                "explanation": "x=1 assigns 1 to x; condition evaluates as true; prints 1."
            },
            {
                "id": "GEN011",
                "question": "What is the output of the following code?\n\nfor(int i=0;i<5;i++)\n if(i=3) cout << i;",
                "options": [
                    "0 1 2 3 4",
                    "3",
                    "Infinite loop",
                    "Compilation error"
                ],
                "answer": 2,
                "explanation": "The assignment i=3 always evaluates to true and resets i in every iteration, resulting in an infinite loop."
            },
            {
                "id": "GEN012",
                "question": "Which of the following statements is TRUE about static variables in functions?",
                "options": [
                    "Value is re-initialized each call",
                    "Retains value between calls",
                    "Cannot be initialized",
                    "Scope is global"
                ],
                "answer": 1,
                "explanation": "Static local variable retains its value between function calls."
            },
            {
                "id": "GEN013",
                "question": "Which of the following is TRUE about const in C++?",
                "options": [
                    "const variable can be modified later",
                    "const pointer means pointer cannot change",
                    "const value cannot be modified",
                    "Both pointer and value can be modified"
                ],
                "answer": 2,
                "explanation": "Const value cannot be modified after initialization."
            },
            {
                "id": "GEN014",
                "question": "Which of the following is TRUE about short-circuit evaluation in C/C++?",
                "options": [
                    "&& stops evaluation if first operand is false",
                    "|| stops evaluation if first operand is true",
                    "Improves performance",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Short-circuit operators avoid unnecessary evaluation; improves performance and avoids errors."
            },
            {
                "id": "GEN015",
                "question": "What will be the output of this code?\n\nint x = 1;\nprintf(\"%d %d\", x, x++);",
                "options": [
                    "1 1",
                    "1 2",
                    "Undefined behavior",
                    "2 1"
                ],
                "answer": 2,
                "explanation": "C standard: modifying and using variable in same statement without sequence point leads to undefined behavior; different compilers may print different results."
            },
            {
                "id": "GEN016",
                "question": "Which of the following is TRUE about function overloading in C++?",
                "options": [
                    "Functions with same name and signature can be overloaded",
                    "Return type can differ",
                    "Parameter types or number must differ",
                    "Overloading is not supported in C++"
                ],
                "answer": 2,
                "explanation": "Overloaded functions must differ in parameters; return type alone is not sufficient."
            },
            {
                "id": "GEN017",
                "question": "Which of the following is TRUE about default arguments in C++?",
                "options": [
                    "Can only be given for the first parameter",
                    "Can be skipped in call",
                    "Can appear in any position",
                    "Cannot be used with functions"
                ],
                "answer": 1,
                "explanation": "Default arguments can be omitted in calls and are usually provided for last parameters."
            },
            {
                "id": "GEN018",
                "question": "What is the output of the following code?\n\nint i=1;\nwhile(i<5)\n i*=i;\ncout << i;",
                "options": [
                    "1",
                    "4",
                    "16",
                    "Infinite loop"
                ],
                "answer": 3,
                "explanation": "Since 1 multiplied by 1 is always 1, the condition i < 5 is always true, leading to an infinite loop."
            },
            {
                "id": "GEN019",
                "question": "Which of the following is TRUE about local vs global variables?",
                "options": [
                    "Local variables can shadow global variables",
                    "Global variables cannot be accessed inside function",
                    "Local variables exist for entire program",
                    "Global variables are destroyed after function exits"
                ],
                "answer": 0,
                "explanation": "Local variables can shadow globals; local variables have function scope."
            },
            {
                "id": "GEN020",
                "question": "Which of the following is TRUE about recursion base case?",
                "options": [
                    "Optional",
                    "Must be present to terminate recursion",
                    "Slows down recursion",
                    "Causes stack overflow intentionally"
                ],
                "answer": 1,
                "explanation": "Recursion must have a base case to terminate, else stack overflow occurs."
            },
            {
                "id": "GEN021",
                "question": "What will the output?\n\nint a=5;\nint b=++a + a++; \ncout<<b;",
                "options": [
                    "11",
                    "12",
                    "10",
                    "Undefined behavior"
                ],
                "answer": 3,
                "explanation": "Because 'a' is modified twice in one expression, the result is undefined. While some compilers may output 12, the standard behavior is undefined."
            },
            {
                "id": "GEN022",
                "question": "Which of the following is TRUE about logical operators in C++?",
                "options": [
                    "&& returns true if both operands true",
                    "|| returns true if any operand true",
                    "! negates boolean value",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Logical operators behave as described; &&, ||, !."
            },
            {
                "id": "GEN023",
                "question": "What will be the output of this code?\n\nint arr[]={1,2,3,4};\ncout<<arr[4];",
                "options": [
                    "1",
                    "0",
                    "Garbage/undefined",
                    "Compilation error"
                ],
                "answer": 2,
                "explanation": "Accessing out-of-bounds index is undefined behavior in C++."
            },
            {
                "id": "GEN024",
                "question": "Which of the following is TRUE about C++ pointers?",
                "options": [
                    "Can store address of variable",
                    "Dereferencing NULL pointer is safe",
                    "Pointer arithmetic only works on arrays",
                    "Pointers cannot point to objects"
                ],
                "answer": 0,
                "explanation": "Pointers store addresses; dereferencing NULL is unsafe; pointer arithmetic works on arrays and objects."
            },
            {
                "id": "GEN025",
                "question": "Which of the following is TRUE about static members in C++ class?",
                "options": [
                    "Static members belong to class, not object",
                    "Cannot be accessed with class name",
                    "Static members cannot be initialized",
                    "Static members are instance-specific"
                ],
                "answer": 0,
                "explanation": "Static members are shared across all objects; belong to class."
            },
            {
                "id": "GEN026",
                "question": "What is output?\n\nint x=3;\nswitch(x){case 3: cout<<3;\ndefault: cout<<0;}",
                "options": [
                    "3",
                    "30",
                    "0",
                    "Compilation error"
                ],
                "answer": 1,
                "explanation": "No break; case 3 executes and falls through default; prints 30."
            },
            {
                "id": "GEN027",
                "question": "Which of the following is TRUE about Java String immutability?",
                "options": [
                    "Strings cannot be modified after creation",
                    "String methods create new String",
                    "Helps thread-safety",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Java Strings are immutable; modifications produce new Strings; immutable objects are thread-safe."
            },
            {
                "id": "GEN028",
                "question": "What will this print?\n\nint i=1;\ndo{cout<<i;i--; }while(i>0);",
                "options": [
                    "1",
                    "0",
                    "1 0",
                    "Infinite loop"
                ],
                "answer": 0,
                "explanation": "Do-while executes once: prints 1, then decrements i to 0; condition false, loop ends."
            },
            {
                "id": "GEN029",
                "question": "Which of the following is TRUE about Java method overloading?",
                "options": [
                    "Methods must have same name but different parameters",
                    "Return type alone can overload method",
                    "Cannot overload static methods",
                    "Overloading is resolved at runtime"
                ],
                "answer": 0,
                "explanation": "Overloading depends on parameter list; return type alone is insufficient; resolved at compile-time."
            },
            {
                "id": "GEN030",
                "question": "Which of the following is TRUE about C++ reference variables?",
                "options": [
                    "Must be initialized",
                    "Cannot be null",
                    "Acts as alias to original variable",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "References must be initialized, cannot be null, act as alias."
            },
            {
                "id": "GEN031",
                "question": "What will the following code output?\n\nint x=1;\nfor(int i=0;i<3;i++) x*=i;\ncout<<x;",
                "options": [
                    "0",
                    "1",
                    "6",
                    "Compilation error"
                ],
                "answer": 0,
                "explanation": "i=0 → x*=0 → x=0; remaining iterations multiply by i, result=0."
            },
            {
                "id": "GEN032",
                "question": "Which of the following is TRUE about pointer vs reference in C++?",
                "options": [
                    "Pointer can be NULL, reference cannot",
                    "Pointer supports arithmetic, reference does not",
                    "Both can refer to objects",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Pointers can be null and support arithmetic; references cannot be null and cannot do arithmetic; both refer to objects."
            },
            {
                "id": "GEN033",
                "question": "What is the output?\n\nint i=5;\nwhile(i>0){cout<<i--; if(i==3) break;}",
                "options": [
                    "5 4 3",
                    "5 4",
                    "5",
                    "4 3 2"
                ],
                "answer": 1,
                "explanation": "i=5→print5,i=4; i=4→print4,i=3; i=3→break; loop ends; output: 5 4."
            },
            {
                "id": "GEN034",
                "question": "Which of the following is TRUE about Java arrays?",
                "options": [
                    "Length is fixed after creation",
                    "Elements are initialized to default values",
                    "Accessing index out of bounds throws exception",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Java arrays are fixed size, auto-initialized, throw ArrayIndexOutOfBoundsException if accessed outside bounds."
            },
            {
                "id": "GEN035",
                "question": "What will the output of the following code?\n\nint a=1,b=2;\ncout << (a>b?a:b);",
                "options": [
                    "1",
                    "2",
                    "3",
                    "Compilation error"
                ],
                "answer": 1,
                "explanation": "Ternary operator: a>b false → prints b=2."
            },
            {
                "id": "GEN036",
                "question": "Which of the following is TRUE about function pointers in C/C++?",
                "options": [
                    "Can store address of function",
                    "Can be called via pointer",
                    "Useful for callback functions",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Function pointers can store function addresses, be invoked via pointer, and used in callbacks."
            },
            {
                "id": "GEN037",
                "question": "What is the output?\n\nint x=5;\ncout<<x+++x;",
                "options": [
                    "10",
                    "11",
                    "Undefined behavior",
                    "12"
                ],
                "answer": 2,
                "explanation": "x+++x is ambiguous; interpreted differently by compilers; usually undefined behavior."
            },
            {
                "id": "GEN038",
                "question": "Which of the following is TRUE about const function in C++?",
                "options": [
                    "Cannot modify class members",
                    "Cannot call non-const methods",
                    "Can be called on const objects",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Const methods cannot modify members, cannot call non-const methods, and are callable on const objects."
            },
            {
                "id": "GEN039",
                "question": "Which of the following is TRUE about recursion stack memory?",
                "options": [
                    "Each recursive call consumes stack",
                    "Deep recursion may cause stack overflow",
                    "Tail recursion can be optimized to reduce stack",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Recursion consumes stack; tail recursion can be optimized; deep recursion may overflow stack."
            },
            {
                "id": "GEN040",
                "question": "What is output?\n\nint x=0;\ndo {cout<<x;x++;}while(x<3);",
                "options": [
                    "0 1 2 3",
                    "0 1 2",
                    "1 2 3",
                    "0 1"
                ],
                "answer": 1,
                "explanation": "Do-while: x=0,1,2 → prints 0 1 2; loop ends when x=3."
            },
            {
                "id": "GEN041",
                "question": "Which of the following is TRUE about inline functions in C++?",
                "options": [
                    "Compiler replaces call with code body",
                    "Reduces function call overhead",
                    "Cannot have loops",
                    "All of the above"
                ],
                "answer": 1,
                "explanation": "Inline functions reduce overhead; loops allowed; compiler may ignore inline request."
            },
            {
                "id": "GEN042",
                "question": "Which of the following is TRUE about Java final keyword?",
                "options": [
                    "final variable cannot be reassigned",
                    "final method cannot be overridden",
                    "final class cannot be inherited",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "final restricts reassignment, overriding, and inheritance."
            },
            {
                "id": "GEN043",
                "question": "Which of the following is TRUE about Java static variables?",
                "options": [
                    "Shared among all instances",
                    "Can be accessed without object",
                    "Initialized only once",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Static variables are shared, accessible without object, and initialized once."
            },
            {
                "id": "GEN044",
                "question": "What is the output?\n\nint x=2;\ncout<<(x<<2);",
                "options": [
                    "8",
                    "4",
                    "6",
                    "2"
                ],
                "answer": 0,
                "explanation": "Bitwise left shift: 2<<2 = 2*2^2 = 8."
            },
            {
                "id": "GEN045",
                "question": "What is the output of the following code?\n\nint x=5,y=2;\ncout<<(x%y);",
                "options": [
                    "1",
                    "2",
                    "0",
                    "3"
                ],
                "answer": 0,
                "explanation": "5%2 = 1."
            },
            {
                "id": "GEN046",
                "question": "Which of the following is TRUE about C++ arrays and pointers?",
                "options": [
                    "Array name acts as pointer to first element",
                    "Pointer arithmetic works on arrays",
                    "Cannot change base address of array",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Array name = pointer to first element; arithmetic works; base address is fixed."
            },
            {
                "id": "GEN047",
                "question": "Which of the following is TRUE about logical XOR in C++?",
                "options": [
                    "^ operator returns 1 if operands differ",
                    "^ operator returns 1 if both operands same",
                    "^ is logical AND",
                    "Cannot use ^ with integers"
                ],
                "answer": 0,
                "explanation": "Bitwise XOR returns 1 if operands differ."
            },
            {
                "id": "GEN048",
                "question": "What is the output?\n\nint x=3;\ncout<<x>>1;",
                "options": [
                    "1",
                    "1 0",
                    "Undefined behavior",
                    "Compilation error"
                ],
                "answer": 3,
                "explanation": "The '<<' operator has higher precedence than '>>'. The code is interpreted as (cout << x) >> 1. Since the right-shift operator is not defined for the ostream object, this results in a compilation error."
            },
            {
                "id": "GEN049",
                "question": "Which of the following is TRUE about recursion depth in C/C++?",
                "options": [
                    "Limited by stack size",
                    "Tail recursion reduces stack usage",
                    "Deep recursion may crash program",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Recursion consumes stack; tail recursion may optimize; exceeding stack causes crash."
            },
            {
                "id": "GEN050",
                "question": "Which of the following is TRUE about pre-increment vs post-increment?",
                "options": [
                    "++i increments then returns",
                    "i++ returns then increments",
                    "Affects expression evaluation order",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Pre-increment increments before use; post-increment after; affects expression result."
            },
            {
                "id": "GEN051",
                "question": "What will be the output?\n\nint x=1;\nfor(int i=0;i<3;i++) x+=i;\ncout<<x;",
                "options": [
                    "4",
                    "5",
                    "6",
                    "7"
                ],
                "answer": 0,
                "explanation": "Step-by-step: Iteration 0 (i=0): x=1+0=1. Iteration 1 (i=1): x=1+1=2. Iteration 2 (i=2): x=2+2=4. Final output is 4."
            },
            {
                "id": "GEN052",
                "question": "What will the output of this code?\n\nint x=5;\nif(x>3)\n if(x<10)\n  cout<<1;\n else\n  cout<<2;",
                "options": [
                    "1",
                    "2",
                    "Compilation error",
                    "Undefined behavior"
                ],
                "answer": 0,
                "explanation": "Nested if: x>3 true, x<10 true → prints 1; else pairs with nearest if."
            },
            {
                "id": "GEN053",
                "question": "Which of the following is TRUE about break and continue in loops?",
                "options": [
                    "break exits current loop",
                    "continue skips rest of iteration",
                    "Both can be used in nested loops with labels (Java)",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "break exits loop; continue skips current iteration; Java allows labeled break/continue in nested loops."
            },
            {
                "id": "GEN054",
                "question": "What is the output of the following C++ code?\n\nint a=5;\nint *p=&a;\n*p+=2;\ncout<<a;",
                "options": [
                    "5",
                    "6",
                    "7",
                    "8"
                ],
                "answer": 2,
                "explanation": "*p+=2 changes value of a via pointer; 5+2=7."
            },
            {
                "id": "GEN055",
                "question": "Which of the following is TRUE about recursion in Java?",
                "options": [
                    "Recursion cannot be used for factorial calculation",
                    "Every recursion must have a base case",
                    "Java automatically optimizes all recursion",
                    "Recursion cannot call itself indirectly"
                ],
                "answer": 1,
                "explanation": "Recursion must have a base case to terminate; indirect recursion is allowed; no automatic optimization."
            },
            {
                "id": "GEN056",
                "question": "What will be the output?\n\nint x=0;\nwhile(x<3) {cout<<x;x++;}",
                "options": [
                    "0 1 2",
                    "0 1 2 3",
                    "1 2 3",
                    "Compilation error"
                ],
                "answer": 0,
                "explanation": "x=0→0, x=1→1, x=2→2; x=3 → condition false; prints 0 1 2."
            },
            {
                "id": "GEN057",
                "question": "Which of the following is TRUE about function default arguments in C++?",
                "options": [
                    "Must be provided in function definition only",
                    "Can be omitted in function call",
                    "Cannot be used with overloaded functions",
                    "Must appear for first parameter"
                ],
                "answer": 1,
                "explanation": "Default arguments can be omitted in calls; usually provided for last parameters."
            },
            {
                "id": "GEN058",
                "question": "What is output?\n\nint a=5;\ncout<<a+++a;",
                "options": [
                    "10",
                    "11",
                    "Compiler dependent / Undefined",
                    "12"
                ],
                "answer": 2,
                "explanation": "Expression is ambiguous; compiler dependent; typically interpreted as (a++)+a; best treated as undefined behavior."
            },
            {
                "id": "GEN059",
                "question": "Which of the following is TRUE about logical AND (&&) in C++?",
                "options": [
                    "Stops evaluation if first operand is false",
                    "Always evaluates both operands",
                    "Used only with integers",
                    "Cannot be used in expressions"
                ],
                "answer": 0,
                "explanation": "Short-circuit: && stops evaluating if first operand is false."
            },
            {
                "id": "GEN060",
                "question": "What will the following code print?\n\nint i=0;\ndo {cout<<i; i++;} while(i<3);",
                "options": [
                    "0 1 2",
                    "0 1 2 3",
                    "1 2 3",
                    "0 1"
                ],
                "answer": 0,
                "explanation": "Do-while loop prints 0,1,2; increments after printing; loop exits when i=3."
            },
            {
                "id": "GEN061",
                "question": "Which of the following is TRUE about arrays in C++?",
                "options": [
                    "Array name acts as pointer to first element",
                    "Cannot be assigned directly",
                    "Size must be constant at compile time",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "All statements are correct: array name = pointer, cannot assign whole array, size fixed at compile time (except dynamic arrays)."
            },
            {
                "id": "GEN062",
                "question": "What is the output of this Java code?\n\nint x=5;\nSystem.out.println(x<<1);",
                "options": [
                    "5",
                    "10",
                    "6",
                    "Compiler error"
                ],
                "answer": 1,
                "explanation": "Left shift 5<<1 = 5*2 = 10."
            },
            {
                "id": "GEN063",
                "question": "Which of the following is TRUE about function overloading in C++?",
                "options": [
                    "Overloaded functions must differ in parameters",
                    "Return type alone can differentiate functions",
                    "Cannot overload constructors",
                    "Overloading resolved at runtime"
                ],
                "answer": 0,
                "explanation": "Overloaded functions must differ in parameter list; return type alone is insufficient."
            },
            {
                "id": "GEN064",
                "question": "Which of the following statements about C++ const pointer is TRUE?",
                "options": [
                    "const int *p → value cannot change",
                    "int *const p → pointer cannot change",
                    "const int *const p → both value and pointer cannot change",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "All statements correctly describe C++ const pointer variations."
            },
            {
                "id": "GEN065",
                "question": "Which of the following is TRUE about Java final variables?",
                "options": [
                    "Must be initialized once",
                    "Cannot be reassigned",
                    "Helps immutability",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "final variables must be initialized once, cannot be reassigned; support immutability."
            },
            {
                "id": "GEN066",
                "question": "What will the output?\n\nint a=1,b=2;\ncout << (a>b?a:b);",
                "options": [
                    "1",
                    "2",
                    "3",
                    "Compilation error"
                ],
                "answer": 1,
                "explanation": "Ternary operator: a>b false → print b=2."
            },
            {
                "id": "GEN067",
                "question": "Which of the following is TRUE about recursion in C++?",
                "options": [
                    "Every recursive call uses stack memory",
                    "Deep recursion may cause stack overflow",
                    "Tail recursion can be optimized by compiler",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "All statements are correct about recursion behavior."
            },
            {
                "id": "GEN068",
                "question": "What is the output?\n\nint x=3;\nint y=x++ + ++x;\ncout<<y;",
                "options": [
                    "7",
                    "8",
                    "9",
                    "Undefined behavior"
                ],
                "answer": 3,
                "explanation": "x++ + ++x modifies x twice between sequence points → undefined behavior in C++."
            },
            {
                "id": "GEN069",
                "question": "Which of the following is TRUE about static local variables in C++?",
                "options": [
                    "Initialized only once",
                    "Retains value across function calls",
                    "Scope limited to function",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Static locals are initialized once, retain value, scope is limited to function."
            },
            {
                "id": "GEN070",
                "question": "Which of the following is TRUE about Java exceptions?",
                "options": [
                    "Checked exceptions must be handled or declared",
                    "Unchecked exceptions can be ignored",
                    "finally block always executes",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "All statements are correct about Java exceptions."
            },
            {
                "id": "GEN071",
                "question": "What is output?\n\nint a=1;\nwhile(a<3){cout<<a; a++;}",
                "options": [
                    "1 2",
                    "1 2 3",
                    "2 3",
                    "Compilation error"
                ],
                "answer": 0,
                "explanation": "Loop executes for a=1,2 → prints 1 2; then a=3 → condition false."
            },
            {
                "id": "GEN072",
                "question": "Which of the following is TRUE about Java method overriding?",
                "options": [
                    "Method signature must be same",
                    "Return type can be covariant",
                    "Private methods cannot be overridden",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Overriding requires same signature; return type can be covariant; private methods are not inherited → cannot override."
            },
            {
                "id": "GEN073",
                "question": "What is output of the following C++ code?\n\nint x=0;\ndo {cout<<x; x++;} while(x<3);",
                "options": [
                    "0 1 2",
                    "0 1 2 3",
                    "1 2 3",
                    "Compilation error"
                ],
                "answer": 0,
                "explanation": "Do-while executes for x=0,1,2 → prints 0 1 2."
            },
            {
                "id": "GEN074",
                "question": "Which of the following is TRUE about C++ operator precedence?",
                "options": [
                    "Multiplication has higher precedence than addition",
                    "Logical AND (&&) has higher precedence than relational operators",
                    "Assignment (=) has higher precedence than arithmetic",
                    "All of the above"
                ],
                "answer": 0,
                "explanation": "Arithmetic * / % > + - > relational > logical > assignment."
            },
            {
                "id": "GEN075",
                "question": "What will the output?\n\nint a=2,b=3;\ncout<<(a&b);",
                "options": [
                    "0",
                    "2",
                    "3",
                    "5"
                ],
                "answer": 1,
                "explanation": "Bitwise AND: 2&3 = 2."
            },
            {
                "id": "GEN076",
                "question": "Which of the following is TRUE about Java final method?",
                "options": [
                    "Cannot be overridden",
                    "Can be overloaded",
                    "Can be inherited",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "final method can be inherited and overloaded but cannot be overridden."
            },
            {
                "id": "GEN077",
                "question": "Which of the following is TRUE about Java static methods?",
                "options": [
                    "Can be called without object",
                    "Cannot access instance variables directly",
                    "Cannot be overridden",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Static methods can be called via class, cannot access instance variables, cannot be overridden (hidden instead)."
            },
            {
                "id": "GEN078",
                "question": "Which of the following is TRUE about C++ virtual functions?",
                "options": [
                    "Supports runtime polymorphism",
                    "Cannot be static",
                    "Base class pointer can call derived method",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Virtual functions enable runtime polymorphism; cannot be static; called via base pointer."
            },
            {
                "id": "GEN079",
                "question": "Which of the following is TRUE about Java interface?",
                "options": [
                    "Cannot have instance variables",
                    "All methods are abstract by default (except static/default)",
                    "Supports multiple inheritance",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Java interfaces cannot have instance variables; methods abstract by default; supports multiple inheritance."
            },
            {
                "id": "GEN080",
                "question": "What is the output of the following code?\n\nint arr[]={1,2,3};\ncout<<*(arr+2);",
                "options": [
                    "1",
                    "2",
                    "3",
                    "Compilation error"
                ],
                "answer": 2,
                "explanation": "Pointer arithmetic: arr+2 points to third element; * gives 3."
            },
            {
                "id": "GEN081",
                "question": "Which of the following is TRUE about C++ dynamic memory?",
                "options": [
                    "new allocates memory on heap",
                    "delete frees heap memory",
                    "Memory leak occurs if delete not called",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Dynamic memory allocated with new, freed with delete; missing delete → memory leak."
            },
            {
                "id": "GEN082",
                "question": "Which of the following is TRUE about Java exception hierarchy?",
                "options": [
                    "Throwable is root class",
                    "Error and Exception are direct subclasses",
                    "Checked exceptions are subclasses of Exception",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Java exceptions hierarchy: Throwable → Error/Exception; checked exceptions extend Exception."
            },
            {
                "id": "GEN083",
                "question": "Which of the following is TRUE about C++ destructors?",
                "options": [
                    "Called automatically when object goes out of scope",
                    "Cannot have parameters",
                    "Cannot be overloaded",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Destructors are automatically invoked; cannot have parameters; cannot be overloaded."
            },
            {
                "id": "GEN084",
                "question": "Which of the following is TRUE about Java constructors?",
                "options": [
                    "Name same as class",
                    "No return type",
                    "Can be overloaded",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "All statements correctly describe Java constructors."
            },
            {
                "id": "GEN085",
                "question": "What is output?\n\nint x=1;\nwhile(x<3){cout<<x; x++;}",
                "options": [
                    "1 2",
                    "1 2 3",
                    "2 3",
                    "0 1"
                ],
                "answer": 0,
                "explanation": "Loop executes x=1,2 → prints 1 2."
            },
            {
                "id": "GEN086",
                "question": "Which of the following is TRUE about Java static block?",
                "options": [
                    "Executed once when class is loaded",
                    "Can initialize static variables",
                    "Cannot throw checked exceptions directly",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Static block executed once during class loading; used for static initialization."
            },
            {
                "id": "GEN087",
                "question": "Which of the following is TRUE about operator precedence in C++?",
                "options": [
                    "++ (pre-increment) > * (multiplication)",
                    "* > +",
                    "== > &&",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Precedence order: ++ > * > + > relational > logical operators."
            },
            {
                "id": "GEN088",
                "question": "Which of the following is TRUE about Java abstract classes?",
                "options": [
                    "Cannot be instantiated",
                    "Can have abstract and concrete methods",
                    "Can have constructors",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Abstract classes cannot be instantiated; can have concrete/abstract methods; can have constructors."
            },
            {
                "id": "GEN089",
                "question": "What is output of this C++ code?\n\nint i=1;\nfor(;i<4;) {cout<<i;i++;}",
                "options": [
                    "1 2 3",
                    "1 2 3 4",
                    "2 3 4",
                    "Compilation error"
                ],
                "answer": 0,
                "explanation": "For loop without initialization/condition works; prints 1 2 3."
            },
            {
                "id": "GEN090",
                "question": "Which of the following is TRUE about C++ references vs pointers?",
                "options": [
                    "References must be initialized",
                    "References cannot be null",
                    "References cannot do arithmetic",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "References must be initialized, cannot be null, and arithmetic not allowed."
            },
            {
                "id": "GEN091",
                "question": "What is output?\n\nint x=0;\ndo {cout<<x; x++;}while(x<3);",
                "options": [
                    "0 1 2",
                    "0 1 2 3",
                    "1 2 3",
                    "Compilation error"
                ],
                "answer": 0,
                "explanation": "Do-while executes x=0,1,2 → prints 0 1 2."
            },
            {
                "id": "GEN092",
                "question": "Which of the following is TRUE about Java finally block?",
                "options": [
                    "Always executes even if exception occurs",
                    "Executes after try-catch",
                    "Cannot prevent termination if System.exit() called",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Finally block executes after try-catch; cannot prevent termination from System.exit()."
            },
            {
                "id": "GEN093",
                "question": "Which of the following is TRUE about C++ friend function?",
                "options": [
                    "Not a member but can access private/protected",
                    "Cannot be inherited",
                    "Cannot be virtual",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Friend function: non-member with access; cannot be inherited/virtual."
            },
            {
                "id": "GEN094",
                "question": "Which of the following is TRUE about Java method overloading?",
                "options": [
                    "Resolved at compile-time",
                    "Parameters must differ",
                    "Return type can differ",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Overloading resolved at compile time; parameter list must differ; return type can differ."
            },
            {
                "id": "GEN095",
                "question": "What is output?\n\nint x=2;\nint y=3;\ncout<<x^y;",
                "options": [
                    "1",
                    "2",
                    "3",
                    "0"
                ],
                "answer": 0,
                "explanation": "Bitwise XOR: 2^3 = 1."
            },
            {
                "id": "GEN096",
                "question": "Which of the following is TRUE about Java polymorphism?",
                "options": [
                    "Compile-time polymorphism achieved via overloading",
                    "Runtime polymorphism via overriding",
                    "Cannot override static methods",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "All statements are correct about Java polymorphism."
            },
            {
                "id": "GEN097",
                "question": "Which of the following is TRUE about C++ inline function?",
                "options": [
                    "Reduces function call overhead",
                    "Cannot contain loops",
                    "Always inlined by compiler",
                    "All of the above"
                ],
                "answer": 0,
                "explanation": "Inline reduces call overhead; compiler may ignore inline; loops allowed."
            },
            {
                "id": "GEN098",
                "question": "What is the output of the following bitwise operation?\n\nint x=3, y=4;\ncout << (x & y);",
                "options": [
                    "0",
                    "2",
                    "3",
                    "4"
                ],
                "answer": 0,
                "explanation": "Bitwise AND: 0011 (3) & 0100 (4) = 0000 (0)."
            },
            {
                "id": "GEN099",
                "question": "Which of the following is TRUE about Java wrapper classes?",
                "options": [
                    "Provide object representation for primitives",
                    "Immutable",
                    "Support autoboxing/unboxing",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Wrapper classes wrap primitives; immutable; support autoboxing/unboxing."
            },
            {
                "id": "GEN100",
                "question": "Which of the following is TRUE about C++ exception handling?",
                "options": [
                    "throw used to raise exception",
                    "catch used to handle exception",
                    "Multiple catch blocks allowed",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "C++ uses throw to raise, catch to handle; multiple catch blocks allowed."
            }
        ],
        "Program Control": [
            {
                "id": "PC101",
                "question": "Which loop executes at least once in C/C++?",
                "options": [
                    "for",
                    "while",
                    "do-while",
                    "None"
                ],
                "answer": 2,
                "explanation": "do-while loop executes at least once before checking condition."
            },
            {
                "id": "PC102",
                "question": "What is the output of the following code?\n\nint i=0;\ndo { printf(\"%d\", i); i++; } while(i>0);",
                "options": [
                    "0",
                    "1",
                    "Infinite loop",
                    "Compilation error"
                ],
                "answer": 2,
                "explanation": "The loop body executes once (printing 0), increments i to 1, and the condition 1 > 0 is always true thereafter."
            },
            {
                "id": "PC103",
                "question": "Which of the following is a correct function declaration in C?",
                "options": [
                    "int func();",
                    "func int();",
                    "function int();",
                    "int -> func();"
                ],
                "answer": 0,
                "explanation": "int func(); declares a function returning int with unspecified parameters."
            },
            {
                "id": "PC104",
                "question": "In recursion, which of the following is mandatory?",
                "options": [
                    "Global variable",
                    "Base condition",
                    "Static variable",
                    "Function overloading"
                ],
                "answer": 1,
                "explanation": "Recursion requires a base condition to terminate; otherwise, it leads to infinite recursion."
            },
            {
                "id": "PC105",
                "question": "What will happen if a recursive function has no base case?",
                "options": [
                    "Program will compile normally",
                    "Stack overflow occurs",
                    "Returns zero",
                    "Infinite loop without error"
                ],
                "answer": 1,
                "explanation": "Without a base case, recursive calls keep stacking until stack memory is exhausted, causing stack overflow."
            },
            {
                "id": "PC106",
                "question": "Which keyword is used to return a value from a function in C/C++?",
                "options": [
                    "break",
                    "return",
                    "exit",
                    "continue"
                ],
                "answer": 1,
                "explanation": "The 'return' keyword is used to send a value back to the caller."
            },
            {
                "id": "PC107",
                "question": "Which of the following loops is preferred when the number of iterations is known?",
                "options": [
                    "for",
                    "while",
                    "do-while",
                    "goto"
                ],
                "answer": 0,
                "explanation": "for loop is ideal for a known number of iterations because it combines initialization, condition, and increment in one line."
            },
            {
                "id": "PC108",
                "question": "Which statement about functions is correct in C/C++?",
                "options": [
                    "Functions can be nested directly",
                    "Function definitions cannot be inside another function",
                    "Only main() can call functions",
                    "Functions cannot return values"
                ],
                "answer": 1,
                "explanation": "C/C++ does not allow defining a function inside another function directly."
            },
            {
                "id": "PC109",
                "question": "Which of the following parameter passing methods passes the address of the variable?",
                "options": [
                    "Call by value",
                    "Call by reference",
                    "Call by name",
                    "Call by pointer"
                ],
                "answer": 1,
                "explanation": "Call by reference passes the actual variable’s address, allowing the function to modify it."
            },
            {
                "id": "PC110",
                "question": "What is the output of the following code?\n\nvoid fun(int n) {\n if(n>0) {\n  printf(\"%d\", n);\n  fun(n-1);\n }\n}\n\nfun(3);",
                "options": [
                    "1 2 3",
                    "3 2 1",
                    "0 1 2",
                    "Compilation error"
                ],
                "answer": 1,
                "explanation": "The function prints n first and then calls itself with n-1, so output is 3 2 1."
            },
            {
                "id": "PC111",
                "question": "Which of the following is **not** a valid looping construct in C?",
                "options": [
                    "for",
                    "while",
                    "do-while",
                    "foreach"
                ],
                "answer": 3,
                "explanation": "'foreach' loop does not exist in standard C."
            },
            {
                "id": "PC112",
                "question": "Which of the following is a disadvantage of recursion?",
                "options": [
                    "Code readability",
                    "Consumes more stack memory",
                    "Reduces code complexity",
                    "None"
                ],
                "answer": 1,
                "explanation": "Recursion uses stack memory for each call; excessive recursion may lead to stack overflow."
            },
            {
                "id": "PC113",
                "question": "What is the scope of a local variable inside a function?",
                "options": [
                    "Accessible globally",
                    "Accessible only within the function",
                    "Accessible in main() only",
                    "Accessible in all files"
                ],
                "answer": 1,
                "explanation": "Local variables exist only during the function execution and cannot be accessed outside it."
            },
            {
                "id": "PC114",
                "question": "Which function call method passes a copy of the variable’s value to the function?",
                "options": [
                    "Call by value",
                    "Call by reference",
                    "Call by pointer",
                    "Call by object"
                ],
                "answer": 0,
                "explanation": "Call by value passes a copy, so the original variable remains unchanged."
            },
            {
                "id": "PC115",
                "question": "What will be the output of the following C++ code?\n\nint factorial(int n) {\n if(n==0) return 1;\n return n * factorial(n-1);\n}\n\ncout << factorial(3);",
                "options": [
                    "6",
                    "9",
                    "3",
                    "0"
                ],
                "answer": 0,
                "explanation": "factorial(3) = 3*2*1 = 6."
            },
            {
                "id": "PC116",
                "question": "Which statement is correct about infinite loops?",
                "options": [
                    "while(1) {} creates an infinite loop",
                    "for(;;) {} creates an infinite loop",
                    "Both A and B",
                    "None"
                ],
                "answer": 2,
                "explanation": "Both 'while(1){}' and 'for(;;){}' create infinite loops."
            },
            {
                "id": "PC117",
                "question": "Which of the following is **true** about recursion in Java?",
                "options": [
                    "Every recursive function must be void",
                    "Recursive calls are handled via stack memory",
                    "Java does not support recursion",
                    "Recursion automatically optimizes memory"
                ],
                "answer": 1,
                "explanation": "Recursive calls are pushed onto the call stack until base condition is met."
            },
            {
                "id": "PC118",
                "question": "Which of the following is a valid function prototype in C?",
                "options": [
                    "int sum(int, int);",
                    "sum int(int, int);",
                    "int sum(); int int();",
                    "function sum(int,int);"
                ],
                "answer": 0,
                "explanation": "int sum(int, int); declares a function returning int and accepting two int arguments."
            },
            {
                "id": "PC119",
                "question": "What will be the output of this C++ program?\n\nvoid print(int n) {\n if(n==0) return;\n print(n-1);\n cout << n;\n}\n\nprint(3);",
                "options": [
                    "3 2 1",
                    "1 2 3",
                    "0 1 2 3",
                    "Compilation error"
                ],
                "answer": 1,
                "explanation": "Recursive call occurs first, then cout prints after returning, so output is 1 2 3."
            },
            {
                "id": "PC120",
                "question": "Which of the following is **not** a valid way to call a function in C?",
                "options": [
                    "func();",
                    "func(5);",
                    "int func();",
                    "(*func)();"
                ],
                "answer": 2,
                "explanation": "int func(); is a declaration, not a function call."
            },
            {
                "id": "PC121",
                "question": "Which of the following statements is correct for 'break' inside loops?",
                "options": [
                    "Terminates the loop immediately",
                    "Skips the current iteration",
                    "Exits the program",
                    "Does nothing"
                ],
                "answer": 0,
                "explanation": "'break' immediately exits the loop or switch statement."
            },
            {
                "id": "PC122",
                "question": "Which statement is used to skip the current iteration in loops?",
                "options": [
                    "break",
                    "continue",
                    "exit",
                    "return"
                ],
                "answer": 1,
                "explanation": "'continue' skips the remaining statements in the current iteration and moves to the next iteration."
            },
            {
                "id": "PC123",
                "question": "Which of the following is **true** about function overloading in C++?",
                "options": [
                    "C++ allows multiple functions with the same name but different parameters",
                    "C does not support function overloading",
                    "Both A and B",
                    "None"
                ],
                "answer": 2,
                "explanation": "C++ supports overloading by parameter type/number; C does not."
            },
            {
                "id": "PC124",
                "question": "Which of the following is the correct syntax for recursion?",
                "options": [
                    "A function calling itself directly or indirectly",
                    "A loop inside a function",
                    "A function calling main() only",
                    "None"
                ],
                "answer": 0,
                "explanation": "Recursion occurs when a function calls itself directly or indirectly."
            },
            {
                "id": "PC125",
                "question": "Which of the following is a correct way to declare a function pointer in C?",
                "options": [
                    "int (*fp)(int, int);",
                    "int fp* (int, int);",
                    "fp int(*)(int,int);",
                    "int fp(int,int);"
                ],
                "answer": 0,
                "explanation": "int (*fp)(int, int); declares a pointer to a function taking two int arguments and returning int."
            },
            {
                "id": "PC126",
                "question": "What is the output of the following code?\n\nint x = 5;\nvoid fun(int x) { x += 5; }\nfun(x);\nprintf(\"%d\", x);",
                "options": [
                    "10",
                    "5",
                    "Compilation error",
                    "0"
                ],
                "answer": 1,
                "explanation": "Call by value passes a copy, so the original x remains 5."
            },
            {
                "id": "PC127",
                "question": "Which type of recursion is called when the recursive call is the last statement in the function?",
                "options": [
                    "Tail recursion",
                    "Head recursion",
                    "Indirect recursion",
                    "Nested recursion"
                ],
                "answer": 0,
                "explanation": "Tail recursion has the recursive call as the last action, allowing optimization in some languages."
            },
            {
                "id": "PC128",
                "question": "Which type of loop is better when the exit condition is checked after executing the loop body?",
                "options": [
                    "for",
                    "while",
                    "do-while",
                    "None"
                ],
                "answer": 2,
                "explanation": "do-while checks the condition after executing the loop body, guaranteeing at least one execution."
            },
            {
                "id": "PC129",
                "question": "Which of the following is **true** about recursive functions in C++?",
                "options": [
                    "Recursion reduces stack memory usage",
                    "Recursive functions can be called multiple times",
                    "Recursion cannot be used with loops",
                    "Recursive functions do not return values"
                ],
                "answer": 1,
                "explanation": "Recursive functions can be called multiple times and are a valid alternative to iteration."
            },
            {
                "id": "PC130",
                "question": "What is the output of the following code?\n\nint sum(int n) {\n if(n==1) return 1;\n return n + sum(n-1);\n}\n\ncout << sum(4);",
                "options": [
                    "10",
                    "24",
                    "4",
                    "0"
                ],
                "answer": 0,
                "explanation": "sum(4) = 4+3+2+1 = 10."
            },
            {
                "id": "PC131",
                "question": "Which of the following is **true** about function prototypes in C?",
                "options": [
                    "They are optional",
                    "They tell the compiler about function name, return type, and parameters",
                    "They are same as function calls",
                    "They can only appear after main()"
                ],
                "answer": 1,
                "explanation": "Function prototypes provide the compiler information about functions before their use."
            },
            {
                "id": "PC132",
                "question": "Which of the following best describes 'scope' of a variable?",
                "options": [
                    "Memory allocated to variable",
                    "Region of program where variable can be accessed",
                    "Type of variable",
                    "Size of variable"
                ],
                "answer": 1,
                "explanation": "Scope defines where a variable can be accessed within the program."
            },
            {
                "id": "PC133",
                "question": "Which of the following statements is correct about nested loops?",
                "options": [
                    "Outer loop executes less than inner loop",
                    "Inner loop executes completely for each iteration of outer loop",
                    "Nested loops are not allowed in C/C++",
                    "Break statement cannot be used inside nested loops"
                ],
                "answer": 1,
                "explanation": "Inner loop runs completely for every iteration of the outer loop."
            },
            {
                "id": "PC134",
                "question": "What will happen if a function tries to return two values directly in C?",
                "options": [
                    "Both values are returned",
                    "Only the first value is returned",
                    "Compilation error",
                    "Program crashes"
                ],
                "answer": 2,
                "explanation": "C functions can return only a single value directly; attempting otherwise causes a compilation error."
            },
            {
                "id": "PC135",
                "question": "Which of the following loops is most efficient for iterating over an array with a known size?",
                "options": [
                    "while",
                    "do-while",
                    "for",
                    "goto"
                ],
                "answer": 2,
                "explanation": "for loop is compact and ideal for known-size arrays."
            },
            {
                "id": "PC136",
                "question": "What is the output of the following code?\n\nfor(int i=0;i<3;i++) {\n if(i==1) continue;\n printf(\"%d\", i);\n}",
                "options": [
                    "0 1 2",
                    "0 2",
                    "1 2",
                    "0 1"
                ],
                "answer": 1,
                "explanation": "continue skips the iteration when i==1, so output is 0 2."
            },
            {
                "id": "PC137",
                "question": "Which of the following is **true** about functions in Java?",
                "options": [
                    "All functions must be static",
                    "Java does not support recursion",
                    "Functions can return values or be void",
                    "Function overloading is not allowed"
                ],
                "answer": 2,
                "explanation": "Java functions (methods) may return values or be void; recursion and overloading are allowed."
            },
            {
                "id": "PC138",
                "question": "Which of the following is correct about 'call by reference' in C++?",
                "options": [
                    "Uses pointers or references",
                    "Modifies original argument",
                    "Saves memory in recursion",
                    "Both A and B"
                ],
                "answer": 3,
                "explanation": "Call by reference uses pointers/references and modifies the original variable."
            },
            {
                "id": "PC139",
                "question": "Which of the following best describes iteration?",
                "options": [
                    "Repeating a set of instructions until a condition is met",
                    "Calling a function recursively",
                    "Declaring variables",
                    "None"
                ],
                "answer": 0,
                "explanation": "Iteration is repeating code using loops until a condition is satisfied."
            },
            {
                "id": "PC140",
                "question": "Which of the following statements is correct for recursion vs iteration?",
                "options": [
                    "Recursion cannot solve problems loops can solve",
                    "Iteration uses less stack memory",
                    "Recursion is always faster",
                    "Iteration cannot be used in functions"
                ],
                "answer": 1,
                "explanation": "Iteration is generally more memory-efficient; recursion uses call stack and may cause overhead."
            },
            {
                "id": "PC141",
                "question": "Which of the following is correct about nested function calls?",
                "options": [
                    "Inner function executes before outer function",
                    "Outer function executes completely before inner",
                    "Nested functions are not allowed in C",
                    "Both functions execute simultaneously"
                ],
                "answer": 0,
                "explanation": "In nested function calls, inner functions are executed first to provide return values to outer functions."
            },
            {
                "id": "PC142",
                "question": "Which of the following is a valid way to terminate a loop prematurely?",
                "options": [
                    "return",
                    "break",
                    "exit",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "'return' exits the function, 'break' exits the loop, 'exit()' ends the program; all can terminate loop execution in different contexts."
            },
            {
                "id": "PC143",
                "question": "What will be the output of this recursive function?\n\nint fib(int n) {\n if(n==0) return 0;\n if(n==1) return 1;\n return fib(n-1)+fib(n-2);\n}\n\nfib(4);",
                "options": [
                    "3",
                    "5",
                    "4",
                    "7"
                ],
                "answer": 0,
                "explanation": "fib(4) = fib(3)+fib(2) = (2)+(1)=3."
            },
            {
                "id": "PC144",
                "question": "Which of the following is **false** about function recursion?",
                "options": [
                    "Recursion may improve code readability",
                    "Every recursion must have a base case",
                    "Recursion always uses less memory than loops",
                    "Excessive recursion may lead to stack overflow"
                ],
                "answer": 2,
                "explanation": "Recursion usually uses more stack memory than iteration."
            },
            {
                "id": "PC145",
                "question": "Which of the following is correct for mutually recursive functions?",
                "options": [
                    "Two functions calling each other",
                    "A function calling itself multiple times",
                    "Recursion without base case",
                    "A loop inside recursion"
                ],
                "answer": 0,
                "explanation": "Mutual recursion occurs when function A calls function B and B calls A."
            },
            {
                "id": "PC146",
                "question": "What is the default return type of a function in C if not specified?",
                "options": [
                    "int",
                    "void",
                    "float",
                    "char"
                ],
                "answer": 0,
                "explanation": "Historically in C, unspecified return type defaults to int (not recommended in modern C)."
            },
            {
                "id": "PC147",
                "question": "Which of the following is **true** about nested loops in C++?",
                "options": [
                    "Inner loop runs once per outer iteration",
                    "Inner loop runs completely for each outer iteration",
                    "Nested loops cannot contain break",
                    "Only for loops can be nested"
                ],
                "answer": 1,
                "explanation": "Inner loop executes fully for each iteration of outer loop."
            },
            {
                "id": "PC148",
                "question": "Which of the following is correct about infinite recursion?",
                "options": [
                    "Program terminates normally",
                    "Stack overflow occurs",
                    "Loop executes once",
                    "Recursion converts to iteration automatically"
                ],
                "answer": 1,
                "explanation": "Infinite recursion keeps calling functions without a base case, causing stack overflow."
            },
            {
                "id": "PC149",
                "question": "Which of the following is **true** for a function with no return type in C++?",
                "options": [
                    "It must be void",
                    "It defaults to int",
                    "It cannot be called",
                    "It is illegal"
                ],
                "answer": 0,
                "explanation": "A function without return value must be declared void."
            },
            {
                "id": "PC150",
                "question": "Which of the following is **true** about the 'for' loop in C/C++?",
                "options": [
                    "Initialization, condition, and increment are optional",
                    "Only initialization is mandatory",
                    "Condition must be true",
                    "Increment must be inside the body"
                ],
                "answer": 0,
                "explanation": "All three components are optional; omitting them can create infinite loops."
            }
        ],
        "Scope of Variables": [
            {
                "id": "SV001",
                "question": "What is the scope of a local variable in a function?",
                "options": [
                    "Accessible globally",
                    "Accessible only within the function",
                    "Accessible in main() only",
                    "Accessible in all files"
                ],
                "answer": 1,
                "explanation": "Local variables are declared inside a function and can only be accessed within that function."
            },
            {
                "id": "SV002",
                "question": "Which type of variable is accessible throughout the program in C/C++?",
                "options": [
                    "Local variable",
                    "Global variable",
                    "Static local variable",
                    "Function parameter"
                ],
                "answer": 1,
                "explanation": "Global variables are declared outside all functions and are accessible from any function in the file."
            },
            {
                "id": "SV003",
                "question": "What is the lifetime of a local variable inside a function?",
                "options": [
                    "Entire program execution",
                    "Only during function execution",
                    "Until the file ends",
                    "Until main() ends"
                ],
                "answer": 1,
                "explanation": "Local variables exist only while the function is executing; they are destroyed when the function exits."
            },
            {
                "id": "SV004",
                "question": "Which keyword in C/C++ is used to make a local variable retain its value between function calls?",
                "options": [
                    "register",
                    "auto",
                    "static",
                    "extern"
                ],
                "answer": 2,
                "explanation": "The 'static' keyword makes a local variable persist between function calls without losing its value."
            },
            {
                "id": "SV005",
                "question": "Which of the following has file scope in C?",
                "options": [
                    "Global variable declared with extern",
                    "Local variable declared in main",
                    "Static local variable inside function",
                    "Function parameter"
                ],
                "answer": 0,
                "explanation": "Global variables declared with 'extern' can be accessed across files and have file scope."
            },
            {
                "id": "SV006",
                "question": "Which variable is shared by all objects of a class in C++?",
                "options": [
                    "Instance variable",
                    "Static member variable",
                    "Local variable",
                    "Parameter variable"
                ],
                "answer": 1,
                "explanation": "Static member variables are shared across all objects of a class, not tied to a specific instance."
            },
            {
                "id": "SV007",
                "question": "What is the scope of a function parameter in C/C++?",
                "options": [
                    "Accessible throughout the program",
                    "Accessible only inside the function",
                    "Accessible in main() only",
                    "Accessible in global scope"
                ],
                "answer": 1,
                "explanation": "Function parameters act like local variables and exist only inside the function."
            },
            {
                "id": "SV008",
                "question": "Which of the following is true about 'extern' in C?",
                "options": [
                    "Declares a variable local to a function",
                    "Declares a global variable without defining it",
                    "Creates a static variable",
                    "Cannot be used with functions"
                ],
                "answer": 1,
                "explanation": "'extern' tells the compiler that a variable is defined elsewhere, usually in another file."
            },
            {
                "id": "SV009",
                "question": "What will happen if a local variable and a global variable have the same name?",
                "options": [
                    "Compilation error",
                    "Local variable hides global variable inside the function",
                    "Global variable overrides local variable",
                    "Program crashes"
                ],
                "answer": 1,
                "explanation": "The local variable shadows the global variable inside its scope; the global variable remains accessible outside the function."
            },
            {
                "id": "SV010",
                "question": "Which type of variable exists for the entire duration of the program execution in C/C++?",
                "options": [
                    "Local auto variable",
                    "Static local variable",
                    "Global variable",
                    "Function parameter"
                ],
                "answer": 2,
                "explanation": "Global variables have a lifetime that spans the entire program execution."
            },
            {
                "id": "SV011",
                "question": "What is the scope of a static local variable in C?",
                "options": [
                    "Accessible globally",
                    "Accessible only within the function",
                    "Accessible throughout the file",
                    "Accessible only in main()"
                ],
                "answer": 1,
                "explanation": "Static local variables retain their value between function calls but are only accessible within the function they are declared in."
            },
            {
                "id": "SV012",
                "question": "Which of the following is true about instance variables in Java?",
                "options": [
                    "Declared inside a method",
                    "Declared inside a class but outside methods",
                    "Declared as static",
                    "Cannot be accessed by objects"
                ],
                "answer": 1,
                "explanation": "Instance variables are declared in a class outside any method and are unique to each object."
            },
            {
                "id": "SV013",
                "question": "Which of the following is **not** affected by scope rules in C?",
                "options": [
                    "Global variables",
                    "Local variables",
                    "Function names",
                    "Comments"
                ],
                "answer": 3,
                "explanation": "Comments are ignored by the compiler and have no scope."
            },
            {
                "id": "SV014",
                "question": "Which of the following variable types can have the same name in different functions without conflict?",
                "options": [
                    "Global variable",
                    "Static local variable",
                    "Local variable",
                    "Function parameter"
                ],
                "answer": 2,
                "explanation": "Local variables have function scope; the same name can be reused in different functions."
            },
            {
                "id": "SV015",
                "question": "Which of the following describes block scope?",
                "options": [
                    "Variable accessible throughout program",
                    "Variable accessible only within the block it is defined",
                    "Variable accessible across files",
                    "Variable accessible only in main()"
                ],
                "answer": 1,
                "explanation": "Block scope means the variable exists only within the braces '{}' in which it is declared."
            },
            {
                "id": "SV016",
                "question": "What is the scope of a static member function in C++?",
                "options": [
                    "Accessible by all objects of the class",
                    "Accessible only by main()",
                    "Accessible only inside class",
                    "Cannot be called without object"
                ],
                "answer": 0,
                "explanation": "Static member functions can be called using the class name and are shared across all objects."
            },
            {
                "id": "SV017",
                "question": "Which of the following is **false** about global variables?",
                "options": [
                    "Declared outside all functions",
                    "Accessible by all functions",
                    "Lifetime is limited to a function call",
                    "Can be declared static to limit file scope"
                ],
                "answer": 2,
                "explanation": "Global variables persist throughout the program; their lifetime is not limited to a function call."
            },
            {
                "id": "SV018",
                "question": "Which of the following correctly describes local static variables in C?",
                "options": [
                    "Visible throughout the program",
                    "Destroyed after function exits",
                    "Retain value between function calls",
                    "Cannot be initialized"
                ],
                "answer": 2,
                "explanation": "Static local variables retain their value between function calls but have limited scope to the function."
            },
            {
                "id": "SV019",
                "question": "Which of the following is true about block-level variables in C++?",
                "options": [
                    "Declared outside any function",
                    "Declared inside a loop or conditional block",
                    "Accessible outside the block",
                    "Have global lifetime"
                ],
                "answer": 1,
                "explanation": "Block-level variables are declared inside a block '{}' and are destroyed once control leaves the block."
            },
            {
                "id": "SV020",
                "question": "What is the scope of a private member variable in C++?",
                "options": [
                    "Accessible in derived classes",
                    "Accessible only within the class",
                    "Accessible globally",
                    "Accessible by all objects"
                ],
                "answer": 1,
                "explanation": "Private members are accessible only inside the class and not outside, including derived classes."
            },
            {
                "id": "SV021",
                "question": "Which of the following is true about protected members in C++?",
                "options": [
                    "Accessible only in class",
                    "Accessible in class and derived classes",
                    "Accessible globally",
                    "Accessible only in main()"
                ],
                "answer": 1,
                "explanation": "Protected members can be accessed by the class itself and any derived classes, but not by unrelated code."
            },
            {
                "id": "SV022",
                "question": "Which of the following is correct about scope resolution operator (::) in C++?",
                "options": [
                    "Used to access global variable when hidden by local variable",
                    "Used for pointer access",
                    "Used for dynamic memory allocation",
                    "Used to call recursive functions"
                ],
                "answer": 0,
                "explanation": "The scope resolution operator allows access to global variables or class members when local variables shadow them."
            },
            {
                "id": "SV023",
                "question": "Which of the following is **true** about variable hiding?",
                "options": [
                    "Local variable can hide a global variable with the same name",
                    "Global variable can hide local variable",
                    "Function parameters can hide static global variables",
                    "Hiding causes compilation error"
                ],
                "answer": 0,
                "explanation": "A local variable can hide a global variable of the same name inside its scope; the global variable remains accessible outside."
            },
            {
                "id": "SV024",
                "question": "Which variable type cannot have the same name as a local variable in the same scope?",
                "options": [
                    "Another local variable in the same block",
                    "Global variable",
                    "Static local variable in a different function",
                    "Function parameter"
                ],
                "answer": 0,
                "explanation": "Two variables cannot have the same name in the same block scope; it causes a compilation error."
            },
            {
                "id": "SV025",
                "question": "Which of the following best describes global scope in C?",
                "options": [
                    "Variable accessible inside a single function",
                    "Variable accessible anywhere in the file",
                    "Variable accessible only in main()",
                    "Variable accessible only inside a loop"
                ],
                "answer": 1,
                "explanation": "Global scope means the variable can be accessed anywhere in the file after its declaration."
            },
            {
                "id": "SV026",
                "question": "Which of the following statements is correct about function scope?",
                "options": [
                    "Variables declared inside a function are not visible outside it",
                    "Variables declared inside a function are global",
                    "Function scope variables persist across function calls by default",
                    "Function scope variables cannot be initialized"
                ],
                "answer": 0,
                "explanation": "Local variables inside a function are only visible within the function and destroyed after it returns."
            },
            {
                "id": "SV027",
                "question": "Which of the following is true about parameter variables in functions?",
                "options": [
                    "They are global by default",
                    "They act like local variables inside the function",
                    "They cannot be initialized",
                    "They are static"
                ],
                "answer": 1,
                "explanation": "Function parameters behave like local variables inside the function and have the same scope and lifetime."
            },
            {
                "id": "SV028",
                "question": "Which of the following is true about static global variables?",
                "options": [
                    "Accessible outside the file",
                    "Lifetime is limited to function call",
                    "Scope is limited to the file they are declared in",
                    "Cannot be initialized"
                ],
                "answer": 2,
                "explanation": "Static global variables have file scope and are not accessible from other files."
            },
            {
                "id": "SV029",
                "question": "Which of the following variables can retain its value between function calls in C?",
                "options": [
                    "Local auto variable",
                    "Static local variable",
                    "Function parameter",
                    "Global extern variable"
                ],
                "answer": 1,
                "explanation": "Static local variables preserve their value across multiple calls of the function."
            },
            {
                "id": "SV030",
                "question": "What is the scope of a class variable in Java?",
                "options": [
                    "Accessible only in one method",
                    "Accessible by all methods of the class",
                    "Accessible globally",
                    "Accessible only in main()"
                ],
                "answer": 1,
                "explanation": "Class variables (instance variables) are accessible by all methods of the class via objects."
            },
            {
                "id": "SV031",
                "question": "Which of the following is true about block-level scope in Java?",
                "options": [
                    "Variables declared inside a loop are accessible outside",
                    "Variables declared inside a block exist only within that block",
                    "Variables can be accessed by all methods in class",
                    "Scope is same as global variables"
                ],
                "answer": 1,
                "explanation": "Variables declared inside a block are destroyed when the block exits."
            },
            {
                "id": "SV032",
                "question": "Which of the following is true about 'final' variables in Java?",
                "options": [
                    "Scope is global",
                    "Value cannot be changed after initialization",
                    "Cannot be used inside methods",
                    "Lifetime is limited to class definition"
                ],
                "answer": 1,
                "explanation": "Final variables in Java are constants; their value cannot be modified after initialization."
            },
            {
                "id": "SV033",
                "question": "Which of the following is **false** about local variables in C++?",
                "options": [
                    "Cannot be accessed outside the function",
                    "Exist only during function execution",
                    "Can be declared static to retain value",
                    "Are automatically shared between functions"
                ],
                "answer": 3,
                "explanation": "Local variables are private to the function and are not shared across functions unless declared global."
            },
            {
                "id": "SV034",
                "question": "Which keyword is used to declare a global variable accessible across multiple files in C?",
                "options": [
                    "static",
                    "extern",
                    "auto",
                    "register"
                ],
                "answer": 1,
                "explanation": "'extern' declares a global variable defined in another file."
            },
            {
                "id": "SV035",
                "question": "Which of the following is true about automatic variables in C?",
                "options": [
                    "Declared with auto inside function",
                    "Default storage class for local variables",
                    "Destroyed when function exits",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Automatic (auto) variables are local to the function, exist during execution, and are destroyed afterward."
            },
            {
                "id": "SV036",
                "question": "Which of the following is true about nested blocks and variable scope?",
                "options": [
                    "Outer block variable is accessible inside inner block",
                    "Inner block variable is accessible in outer block",
                    "Variables in nested blocks are always global",
                    "Nested blocks cannot have variables"
                ],
                "answer": 0,
                "explanation": "Variables in outer blocks are accessible inside inner blocks unless shadowed by inner block variables."
            },
            {
                "id": "SV037",
                "question": "Which of the following describes lifetime of a variable?",
                "options": [
                    "Region where variable is accessible",
                    "Duration for which memory is allocated",
                    "Variable type",
                    "Variable name"
                ],
                "answer": 1,
                "explanation": "Lifetime of a variable is the period during which memory is reserved for it."
            },
            {
                "id": "SV038",
                "question": "Which of the following is **true** about visibility of static class variables in C++?",
                "options": [
                    "Accessible by objects and class functions",
                    "Accessible only inside main()",
                    "Accessible globally without class",
                    "Cannot be accessed by objects"
                ],
                "answer": 0,
                "explanation": "Static class variables are shared across all objects and can be accessed by class methods."
            },
            {
                "id": "SV039",
                "question": "Which of the following best describes shadowing?",
                "options": [
                    "Local variable overrides global variable with same name",
                    "Global variable overrides local variable",
                    "Variables can be accessed anywhere",
                    "Function names cannot shadow each other"
                ],
                "answer": 0,
                "explanation": "Shadowing occurs when a local variable has the same name as a global variable; local variable takes precedence."
            },
            {
                "id": "SV040",
                "question": "Which of the following is **true** about function scope in C++?",
                "options": [
                    "Local variables inside functions cannot be accessed outside",
                    "Variables declared in a function are global",
                    "Function scope variables exist for entire program",
                    "Static variables cannot be inside functions"
                ],
                "answer": 0,
                "explanation": "Local variables exist only within the function and are destroyed after execution."
            },
            {
                "id": "SV041",
                "question": "Which of the following is true about class-level scope in Java?",
                "options": [
                    "Variables declared inside a class and outside methods are accessible by all methods",
                    "Variables declared inside methods are class-level",
                    "Class-level variables are destroyed after method execution",
                    "Cannot be static"
                ],
                "answer": 0,
                "explanation": "Variables declared in class but outside methods are class-level (instance variables) and accessible by all methods via objects."
            },
            {
                "id": "SV042",
                "question": "Which of the following is true about global variables in C?",
                "options": [
                    "Cannot be initialized",
                    "Accessible by all functions",
                    "Lifetime limited to function",
                    "Cannot be static"
                ],
                "answer": 1,
                "explanation": "Global variables are accessible by all functions and exist for the entire program duration."
            },
            {
                "id": "SV043",
                "question": "Which of the following is **false** about local and global variables in C?",
                "options": [
                    "Local variables hide global variables inside functions",
                    "Global variables exist for the entire program",
                    "Local variables can be static",
                    "Local variables are accessible outside their function"
                ],
                "answer": 3,
                "explanation": "Local variables cannot be accessed outside the function they are declared in."
            },
            {
                "id": "SV044",
                "question": "Which of the following is correct about dynamic variables allocated via malloc() in C?",
                "options": [
                    "Lifetime is till free() is called",
                    "Scope is global automatically",
                    "Cannot be accessed by pointer",
                    "Automatically destroyed after function"
                ],
                "answer": 0,
                "explanation": "Dynamically allocated memory exists until free() is called, independent of function scope."
            },
            {
                "id": "SV045",
                "question": "Which of the following is true about static variables in functions?",
                "options": [
                    "Scope is global",
                    "Lifetime is local to function",
                    "Scope is local, lifetime persists across calls",
                    "Cannot be initialized"
                ],
                "answer": 2,
                "explanation": "Static variables declared inside functions have local scope but retain their value between function calls."
            },
            {
                "id": "SV046",
                "question": "Which of the following best describes visibility in programming?",
                "options": [
                    "Memory allocated to variable",
                    "Region of code where variable can be accessed",
                    "Type of variable",
                    "Function definition"
                ],
                "answer": 1,
                "explanation": "Visibility defines which parts of the program can access a variable."
            },
            {
                "id": "SV047",
                "question": "Which of the following variables cannot be shadowed in Java?",
                "options": [
                    "Static class variable",
                    "Local variable",
                    "Instance variable",
                    "Final local variable"
                ],
                "answer": 3,
                "explanation": "Final local variables cannot be reassigned and hence cannot be shadowed in the same block."
            },
            {
                "id": "SV048",
                "question": "Which of the following is true about member variables declared public in C++?",
                "options": [
                    "Accessible only inside class",
                    "Accessible by any function or object",
                    "Cannot be accessed by derived class",
                    "Lifetime is limited to function execution"
                ],
                "answer": 1,
                "explanation": "Public member variables are accessible anywhere using objects of the class."
            },
            {
                "id": "SV049",
                "question": "Which of the following statements is correct about nested scopes in C++?",
                "options": [
                    "Outer block variables are inaccessible inside inner block",
                    "Inner block variables are inaccessible outside the block",
                    "Variables in nested blocks always override global variables",
                    "Nested blocks cannot declare variables"
                ],
                "answer": 1,
                "explanation": "Variables declared inside inner blocks are destroyed when control leaves the block."
            },
            {
                "id": "SV050",
                "question": "Which of the following is true about scope in Java?",
                "options": [
                    "Java does not support block-level scope",
                    "Local variables exist only within the method or block",
                    "Global variables are default",
                    "Function parameters exist throughout the class"
                ],
                "answer": 1,
                "explanation": "Local variables in Java exist only within the method or block in which they are declared."
            }
        ],
        "Binding of Variables & Functions": [
            {
                "id": "BF001",
                "question": "What does binding in programming refer to?",
                "options": [
                    "Assigning a value to a variable",
                    "Associating a variable or function with a memory location or implementation",
                    "Calling a function",
                    "Declaring a class"
                ],
                "answer": 1,
                "explanation": "Binding refers to linking a variable or function to its memory location or the function to its code."
            },
            {
                "id": "BF002",
                "question": "Which type of binding occurs at compile time?",
                "options": [
                    "Static binding",
                    "Dynamic binding",
                    "Late binding",
                    "Runtime binding"
                ],
                "answer": 0,
                "explanation": "Static binding (early binding) happens at compile time when the compiler determines the memory location or function call."
            },
            {
                "id": "BF003",
                "question": "Which type of binding is associated with polymorphism in object-oriented programming?",
                "options": [
                    "Static binding",
                    "Dynamic binding",
                    "Early binding",
                    "Compile-time binding"
                ],
                "answer": 1,
                "explanation": "Dynamic binding (late binding) allows the method call to be resolved at runtime, enabling polymorphism."
            },
            {
                "id": "BF004",
                "question": "Which of the following function calls is resolved at compile time in C++?",
                "options": [
                    "Non-virtual function call",
                    "Virtual function call",
                    "Overridden function call",
                    "Function pointer call"
                ],
                "answer": 0,
                "explanation": "Non-virtual functions are statically bound at compile time."
            },
            {
                "id": "BF005",
                "question": "Which function in C++ allows dynamic binding?",
                "options": [
                    "Static function",
                    "Virtual function",
                    "Inline function",
                    "Friend function"
                ],
                "answer": 1,
                "explanation": "Virtual functions enable dynamic (late) binding, resolved at runtime based on object type."
            },
            {
                "id": "BF006",
                "question": "Which of the following variables is bound at compile time?",
                "options": [
                    "Local auto variable",
                    "Global variable",
                    "Static local variable",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Local, global, and static local variables have memory locations determined at compile time, i.e., statically bound."
            },
            {
                "id": "BF007",
                "question": "Which of the following is an example of early binding in C++?",
                "options": [
                    "Overloaded function calls",
                    "Virtual function calls",
                    "Polymorphic method calls",
                    "Dynamic memory allocation"
                ],
                "answer": 0,
                "explanation": "Overloaded functions are resolved at compile time, hence early binding."
            },
            {
                "id": "BF008",
                "question": "Which of the following is **true** about late binding?",
                "options": [
                    "Resolved at compile time",
                    "Resolved at runtime",
                    "Cannot be used in OOP",
                    "Only applies to variables"
                ],
                "answer": 1,
                "explanation": "Late binding is resolved at runtime, allowing polymorphism in OOP."
            },
            {
                "id": "BF009",
                "question": "Which of the following keywords is used to enable late binding in C++?",
                "options": [
                    "virtual",
                    "static",
                    "extern",
                    "inline"
                ],
                "answer": 0,
                "explanation": "The 'virtual' keyword tells the compiler to resolve function calls at runtime (dynamic binding)."
            },
            {
                "id": "BF010",
                "question": "Which type of binding occurs when a variable is bound to memory at runtime?",
                "options": [
                    "Static binding",
                    "Dynamic binding",
                    "Compile-time binding",
                    "Early binding"
                ],
                "answer": 1,
                "explanation": "Dynamic binding occurs when memory for variables or function addresses is determined during execution."
            },
            {
                "id": "BF011",
                "question": "Which of the following is **false** about static binding?",
                "options": [
                    "Occurs at compile time",
                    "Applicable to non-virtual functions",
                    "Allows polymorphism",
                    "Faster than dynamic binding"
                ],
                "answer": 2,
                "explanation": "Static binding does not support runtime polymorphism; only dynamic binding allows polymorphism."
            },
            {
                "id": "BF012",
                "question": "Which of the following statements is true about virtual functions in C++?",
                "options": [
                    "Resolved at compile time",
                    "Cannot be overridden",
                    "Enable dynamic binding",
                    "Cannot be called using objects"
                ],
                "answer": 2,
                "explanation": "Virtual functions are resolved at runtime and enable dynamic binding and polymorphism."
            },
            {
                "id": "BF013",
                "question": "Which of the following is **true** for function overloading in C++?",
                "options": [
                    "Resolved at runtime",
                    "Resolved at compile time",
                    "Requires virtual keyword",
                    "Cannot have same function name"
                ],
                "answer": 1,
                "explanation": "Function overloading is resolved at compile time using static binding."
            },
            {
                "id": "BF014",
                "question": "Which type of binding is faster?",
                "options": [
                    "Static binding",
                    "Dynamic binding",
                    "Virtual binding",
                    "Runtime binding"
                ],
                "answer": 0,
                "explanation": "Static binding occurs at compile time and is faster because no runtime lookup is needed."
            },
            {
                "id": "BF015",
                "question": "Which of the following allows runtime decision on which function to call in C++?",
                "options": [
                    "Function overloading",
                    "Virtual function",
                    "Inline function",
                    "Macro function"
                ],
                "answer": 1,
                "explanation": "Virtual functions are resolved at runtime, allowing the program to choose the correct function based on object type."
            },
            {
                "id": "BF016",
                "question": "Which of the following is an example of static binding in Java?",
                "options": [
                    "Method overloading",
                    "Overridden method call",
                    "Virtual method call",
                    "Interface method call"
                ],
                "answer": 0,
                "explanation": "Method overloading in Java is resolved at compile time (static binding)."
            },
            {
                "id": "BF017",
                "question": "Which binding type applies to instance method calls via object reference in Java?",
                "options": [
                    "Static binding",
                    "Dynamic binding",
                    "Early binding",
                    "Compile-time binding"
                ],
                "answer": 1,
                "explanation": "Instance methods are resolved at runtime using dynamic binding based on the object's actual type."
            },
            {
                "id": "BF018",
                "question": "Which of the following binding types is used by private, static, and final methods in Java?",
                "options": [
                    "Dynamic binding",
                    "Static binding",
                    "Virtual binding",
                    "Late binding"
                ],
                "answer": 1,
                "explanation": "Private, static, and final methods in Java are bound at compile time (static binding)."
            },
            {
                "id": "BF019",
                "question": "Which of the following is resolved using a vtable in C++?",
                "options": [
                    "Static variable binding",
                    "Virtual function calls",
                    "Global variable access",
                    "Local variable access"
                ],
                "answer": 1,
                "explanation": "Virtual functions use a vtable (virtual table) to resolve function addresses at runtime."
            },
            {
                "id": "BF020",
                "question": "Which type of binding is used in calling inline functions in C++?",
                "options": [
                    "Static binding",
                    "Dynamic binding",
                    "Virtual binding",
                    "Late binding"
                ],
                "answer": 0,
                "explanation": "Inline function calls are resolved at compile time (static binding)."
            },
            {
                "id": "BF021",
                "question": "Which of the following is true for dynamic binding in Java?",
                "options": [
                    "Used for overloaded methods",
                    "Used for overridden methods",
                    "Resolved at compile time",
                    "Cannot be used with inheritance"
                ],
                "answer": 1,
                "explanation": "Overridden methods are dynamically bound in Java; the method invoked depends on the actual object type."
            },
            {
                "id": "BF022",
                "question": "Which of the following binding types determines which function to call based on object type at runtime?",
                "options": [
                    "Static binding",
                    "Dynamic binding",
                    "Early binding",
                    "Compile-time binding"
                ],
                "answer": 1,
                "explanation": "Dynamic binding chooses the function to execute at runtime based on the actual object."
            },
            {
                "id": "BF023",
                "question": "Which of the following can be considered compile-time binding?",
                "options": [
                    "Function pointer calls",
                    "Overloaded function calls",
                    "Virtual function calls",
                    "Interface method calls"
                ],
                "answer": 1,
                "explanation": "Overloaded functions are resolved at compile time, which is static binding."
            },
            {
                "id": "BF024",
                "question": "Which of the following statements is correct regarding virtual functions in C++?",
                "options": [
                    "Cannot be overridden",
                    "Bound at compile time",
                    "Bound at runtime",
                    "Cannot be inherited"
                ],
                "answer": 2,
                "explanation": "Virtual functions enable dynamic (runtime) binding and can be overridden in derived classes."
            },
            {
                "id": "BF025",
                "question": "Which type of function call is resolved using a function pointer in C?",
                "options": [
                    "Static binding",
                    "Dynamic binding",
                    "Compile-time binding",
                    "Early binding"
                ],
                "answer": 1,
                "explanation": "Function pointers allow the call to be resolved at runtime, which is dynamic binding."
            },
            {
                "id": "BF026",
                "question": "Which binding type allows polymorphic behavior in object-oriented languages?",
                "options": [
                    "Static binding",
                    "Dynamic binding",
                    "Early binding",
                    "Compile-time binding"
                ],
                "answer": 1,
                "explanation": "Dynamic binding allows the program to select the correct overridden method at runtime, enabling polymorphism."
            },
            {
                "id": "BF027",
                "question": "Which of the following is true about early binding?",
                "options": [
                    "Resolved at runtime",
                    "Cannot be used with function overloading",
                    "Resolved at compile time",
                    "Applies to virtual functions"
                ],
                "answer": 2,
                "explanation": "Early (static) binding resolves function calls or variable addresses at compile time."
            },
            {
                "id": "BF028",
                "question": "Which of the following variables are bound at runtime in C++?",
                "options": [
                    "Local automatic variables",
                    "Global variables",
                    "Static variables",
                    "Pointer to virtual function"
                ],
                "answer": 3,
                "explanation": "Function calls via pointers to virtual functions are resolved at runtime (dynamic binding)."
            },
            {
                "id": "BF029",
                "question": "Which of the following statements is **false** about dynamic binding?",
                "options": [
                    "Occurs at runtime",
                    "Enables polymorphism",
                    "Faster than static binding",
                    "Depends on actual object type"
                ],
                "answer": 2,
                "explanation": "Dynamic binding is generally slower than static binding due to runtime lookup."
            },
            {
                "id": "BF030",
                "question": "Which binding type is used for accessing private members of a class in C++?",
                "options": [
                    "Static binding",
                    "Dynamic binding",
                    "Virtual binding",
                    "Late binding"
                ],
                "answer": 0,
                "explanation": "Private members are resolved at compile time (static binding)."
            },
            {
                "id": "BF031",
                "question": "Which type of binding does Java use for constructors?",
                "options": [
                    "Static binding",
                    "Dynamic binding",
                    "Late binding",
                    "Virtual binding"
                ],
                "answer": 0,
                "explanation": "Constructor calls are resolved at compile time using static binding."
            },
            {
                "id": "BF032",
                "question": "Which of the following is **true** about function overriding and binding?",
                "options": [
                    "Overridden functions are statically bound",
                    "Overridden functions are dynamically bound",
                    "Function overloading is dynamically bound",
                    "Static functions are dynamically bound"
                ],
                "answer": 1,
                "explanation": "Overridden functions are resolved at runtime, i.e., dynamic binding."
            },
            {
                "id": "BF033",
                "question": "Which of the following is resolved by the compiler during compilation?",
                "options": [
                    "Virtual function call",
                    "Non-virtual function call",
                    "Function pointer call",
                    "Interface method call"
                ],
                "answer": 1,
                "explanation": "Non-virtual function calls are resolved at compile time using static binding."
            },
            {
                "id": "BF034",
                "question": "Which binding type does not allow overriding?",
                "options": [
                    "Dynamic binding",
                    "Static binding",
                    "Virtual binding",
                    "Late binding"
                ],
                "answer": 1,
                "explanation": "Static binding occurs at compile time and does not support overriding."
            },
            {
                "id": "BF035",
                "question": "Which of the following is **true** about function overloading vs overriding?",
                "options": [
                    "Overloading uses dynamic binding",
                    "Overriding uses static binding",
                    "Overloading uses static binding",
                    "Overloading and overriding both use dynamic binding"
                ],
                "answer": 2,
                "explanation": "Function overloading is resolved at compile time (static binding), whereas overriding uses dynamic binding."
            },
            {
                "id": "BF036",
                "question": "Which binding type is used for accessing global variables in C?",
                "options": [
                    "Static binding",
                    "Dynamic binding",
                    "Late binding",
                    "Virtual binding"
                ],
                "answer": 0,
                "explanation": "Global variables are resolved at compile time (static binding)."
            },
            {
                "id": "BF037",
                "question": "Which of the following statements is true about static member functions in C++?",
                "options": [
                    "Bound at runtime",
                    "Bound at compile time",
                    "Can be virtual",
                    "Overridden in derived class"
                ],
                "answer": 1,
                "explanation": "Static member functions are statically bound at compile time; they cannot be virtual."
            },
            {
                "id": "BF038",
                "question": "Which of the following C++ features requires dynamic binding?",
                "options": [
                    "Function overloading",
                    "Virtual functions",
                    "Static variables",
                    "Const variables"
                ],
                "answer": 1,
                "explanation": "Virtual functions rely on dynamic binding to resolve function calls at runtime."
            },
            {
                "id": "BF039",
                "question": "Which of the following best describes binding?",
                "options": [
                    "Association of variable/function with memory or code",
                    "Assignment of a constant",
                    "Function call",
                    "Declaration of variable"
                ],
                "answer": 0,
                "explanation": "Binding links a variable or function to its memory location or function implementation."
            },
            {
                "id": "BF040",
                "question": "Which of the following is **false** about static binding?",
                "options": [
                    "Faster than dynamic binding",
                    "Occurs at compile time",
                    "Supports polymorphism",
                    "Used in function overloading"
                ],
                "answer": 2,
                "explanation": "Static binding does not support polymorphism; dynamic binding does."
            },
            {
                "id": "BF041",
                "question": "Which of the following is true about member function calls in Java?",
                "options": [
                    "Private methods use dynamic binding",
                    "Final methods use dynamic binding",
                    "Non-static, non-final overridden methods use dynamic binding",
                    "Static methods use dynamic binding"
                ],
                "answer": 2,
                "explanation": "Non-static, non-final methods that are overridden are resolved at runtime (dynamic binding)."
            },
            {
                "id": "BF042",
                "question": "Which of the following is **true** about function pointers in C?",
                "options": [
                    "Resolve call at compile time",
                    "Resolve call at runtime",
                    "Cannot point to overloaded functions",
                    "Cannot be passed as parameters"
                ],
                "answer": 1,
                "explanation": "Function pointers allow runtime determination of which function to call (dynamic binding)."
            },
            {
                "id": "BF043",
                "question": "Which of the following is **false** about virtual tables (vtable) in C++?",
                "options": [
                    "Used for dynamic binding",
                    "Contains addresses of virtual functions",
                    "Used for static variables",
                    "Resolved at runtime"
                ],
                "answer": 2,
                "explanation": "Vtables are not used for static variables; they are used for resolving virtual functions at runtime."
            },
            {
                "id": "BF044",
                "question": "Which binding type is used for inline functions in C++?",
                "options": [
                    "Dynamic binding",
                    "Static binding",
                    "Virtual binding",
                    "Late binding"
                ],
                "answer": 1,
                "explanation": "Inline function calls are resolved at compile time using static binding."
            },
            {
                "id": "BF045",
                "question": "Which of the following is **true** about binding of constructors in Java?",
                "options": [
                    "Resolved at runtime",
                    "Resolved at compile time",
                    "Cannot be overloaded",
                    "Cannot be inherited"
                ],
                "answer": 1,
                "explanation": "Constructor calls are resolved at compile time using static binding."
            },
            {
                "id": "BF046",
                "question": "Which binding type is used for accessing class-level static variables in Java?",
                "options": [
                    "Dynamic binding",
                    "Static binding",
                    "Virtual binding",
                    "Late binding"
                ],
                "answer": 1,
                "explanation": "Static class variables are bound at compile time (static binding)."
            },
            {
                "id": "BF047",
                "question": "Which of the following is **true** about final methods in Java?",
                "options": [
                    "Overridable",
                    "Use dynamic binding",
                    "Use static binding",
                    "Cannot be called"
                ],
                "answer": 2,
                "explanation": "Final methods cannot be overridden and are statically bound at compile time."
            },
            {
                "id": "BF048",
                "question": "Which type of binding applies to object method calls in polymorphic behavior?",
                "options": [
                    "Static binding",
                    "Dynamic binding",
                    "Compile-time binding",
                    "Inline binding"
                ],
                "answer": 1,
                "explanation": "Dynamic binding resolves which overridden method to call at runtime based on actual object type."
            },
            {
                "id": "BF049",
                "question": "Which of the following statements is true about static methods in Java?",
                "options": [
                    "Bound at runtime",
                    "Bound at compile time",
                    "Can be overridden",
                    "Use vtable"
                ],
                "answer": 1,
                "explanation": "Static methods are bound at compile time using static binding; they cannot be overridden."
            },
            {
                "id": "BF050",
                "question": "Which of the following is a correct example of late binding?",
                "options": [
                    "Calling a non-virtual function",
                    "Calling a virtual function in C++ through a base class pointer",
                    "Accessing a global variable",
                    "Calling a static function"
                ],
                "answer": 1,
                "explanation": "Calling a virtual function via a base class pointer is resolved at runtime, demonstrating late binding."
            }
        ],
        "Parameter Passing": [
            {
                "id": "PP001",
                "question": "Which of the following is a correct definition of parameter passing?",
                "options": [
                    "Passing variables to a function so it can access them",
                    "Declaring global variables",
                    "Returning values from a function",
                    "Assigning a value to a variable"
                ],
                "answer": 0,
                "explanation": "Parameter passing is supplying arguments to a function so it can use them during execution."
            },
            {
                "id": "PP002",
                "question": "Which parameter passing method copies the actual value of the argument into the formal parameter?",
                "options": [
                    "Call by reference",
                    "Call by value",
                    "Call by pointer",
                    "Call by object"
                ],
                "answer": 1,
                "explanation": "In call by value, a copy of the argument is passed, so changes inside the function do not affect the original variable."
            },
            {
                "id": "PP003",
                "question": "Which parameter passing method allows a function to modify the actual argument?",
                "options": [
                    "Call by value",
                    "Call by reference",
                    "Call by constant",
                    "Call by temporary"
                ],
                "answer": 1,
                "explanation": "Call by reference passes the address of the variable so the function can modify the original variable."
            },
            {
                "id": "PP004",
                "question": "In C, which of the following is used to achieve call by reference?",
                "options": [
                    "Passing variable directly",
                    "Passing variable address using pointers",
                    "Passing variable name",
                    "Using global variables"
                ],
                "answer": 1,
                "explanation": "C does not support direct call by reference; it is simulated using pointers."
            },
            {
                "id": "PP005",
                "question": "In Java, which method is used to pass primitive data types?",
                "options": [
                    "Call by reference",
                    "Call by value",
                    "Call by pointer",
                    "Call by object reference"
                ],
                "answer": 1,
                "explanation": "Java passes primitive data types by value, meaning changes inside the method do not affect the original variable."
            },
            {
                "id": "PP006",
                "question": "In Java, objects are passed using which method?",
                "options": [
                    "Call by value",
                    "Call by reference",
                    "Call by object reference (call by value of reference)",
                    "Call by pointer"
                ],
                "answer": 2,
                "explanation": "Objects are passed by value of reference, meaning the reference is copied but both refer to the same object."
            },
            {
                "id": "PP007",
                "question": "Which of the following is true about call by value?",
                "options": [
                    "Original argument can be modified",
                    "Function works on copy of data",
                    "Faster than call by reference always",
                    "Cannot be used in C"
                ],
                "answer": 1,
                "explanation": "Call by value passes a copy of the variable, so changes inside the function do not affect the original variable."
            },
            {
                "id": "PP008",
                "question": "Which of the following is **true** about call by reference in C++?",
                "options": [
                    "Cannot be used for arrays",
                    "Changes in function affect original variable",
                    "Always slower than call by value",
                    "Requires pointers in all cases"
                ],
                "answer": 1,
                "explanation": "Call by reference allows the function to modify the actual argument; in C++ it can be done using references without pointers."
            },
            {
                "id": "PP009",
                "question": "Which of the following is a disadvantage of call by reference?",
                "options": [
                    "Cannot modify original value",
                    "Potential for side-effects",
                    "Extra memory required",
                    "Slower than call by value always"
                ],
                "answer": 1,
                "explanation": "Call by reference can lead to unintended side effects since the function can modify the original variable."
            },
            {
                "id": "PP010",
                "question": "Which parameter passing technique is safe when you do not want the function to modify the original value?",
                "options": [
                    "Call by value",
                    "Call by reference",
                    "Call by pointer",
                    "Call by object reference"
                ],
                "answer": 0,
                "explanation": "Call by value is safe as the function works on a copy and cannot modify the original variable."
            },
            {
                "id": "PP011",
                "question": "In C++, which symbol is used to declare a reference parameter?",
                "options": [
                    "*",
                    "&",
                    "#",
                    "$"
                ],
                "answer": 1,
                "explanation": "The '&' symbol is used to declare a reference parameter in C++, enabling call by reference."
            },
            {
                "id": "PP012",
                "question": "Which of the following is true about call by pointer?",
                "options": [
                    "Only works for arrays",
                    "Copies the value of variable",
                    "Function can modify original variable using address",
                    "Cannot be used in C++"
                ],
                "answer": 2,
                "explanation": "Call by pointer passes the address of the variable, allowing the function to modify the original variable."
            },
            {
                "id": "PP013",
                "question": "Which parameter passing method does Java not support directly?",
                "options": [
                    "Call by value",
                    "Call by reference",
                    "Call by object reference",
                    "Call by primitive"
                ],
                "answer": 1,
                "explanation": "Java does not support call by reference directly; primitives are passed by value, objects by value of reference."
            },
            {
                "id": "PP014",
                "question": "What happens when a large structure is passed by value in C?",
                "options": [
                    "Only reference is passed",
                    "Entire structure is copied",
                    "Original structure is modified",
                    "Cannot pass structure by value"
                ],
                "answer": 1,
                "explanation": "Passing by value copies the entire structure, which can be inefficient for large structures."
            },
            {
                "id": "PP015",
                "question": "Which method is more efficient for passing large objects or structures in C++?",
                "options": [
                    "Call by value",
                    "Call by reference",
                    "Call by constant value",
                    "Call by temporary"
                ],
                "answer": 1,
                "explanation": "Call by reference avoids copying the entire object and is more efficient for large objects or structures."
            },
            {
                "id": "PP016",
                "question": "Which of the following is true for 'const reference' in C++?",
                "options": [
                    "Function can modify original variable",
                    "Function cannot modify original variable",
                    "Cannot pass objects by const reference",
                    "Slower than call by value always"
                ],
                "answer": 1,
                "explanation": "Passing by const reference allows access without copying but prevents modification of the original variable."
            },
            {
                "id": "PP017",
                "question": "Which of the following allows both efficiency and safety when passing objects in C++?",
                "options": [
                    "Call by value",
                    "Call by reference",
                    "Call by const reference",
                    "Call by pointer"
                ],
                "answer": 2,
                "explanation": "Call by const reference avoids copying large objects and prevents modification of original data."
            },
            {
                "id": "PP018",
                "question": "Which of the following is true about array parameters in C?",
                "options": [
                    "Arrays are passed by value",
                    "Arrays are passed by reference (actually pointer to first element)",
                    "Cannot be passed to functions",
                    "Copies entire array automatically"
                ],
                "answer": 1,
                "explanation": "In C, array names decay to pointers, so the function receives the address of the first element (simulating call by reference)."
            },
            {
                "id": "PP019",
                "question": "Which of the following is **false** about call by value in C++?",
                "options": [
                    "Original variable is not affected",
                    "Function works on a copy of variable",
                    "Changes are visible outside the function",
                    "Safe from side-effects"
                ],
                "answer": 2,
                "explanation": "Call by value does not modify the original variable; changes are not visible outside the function."
            },
            {
                "id": "PP020",
                "question": "Which of the following is **true** about call by reference using '&' in C++?",
                "options": [
                    "Changes inside function do not affect caller",
                    "Changes inside function affect original variable",
                    "Requires use of pointers always",
                    "Cannot pass objects"
                ],
                "answer": 1,
                "explanation": "Reference parameters allow the function to modify the caller's variable directly."
            },
            {
                "id": "PP021",
                "question": "Which parameter passing method is default for primitive types in Java?",
                "options": [
                    "Call by reference",
                    "Call by value",
                    "Call by object reference",
                    "Call by pointer"
                ],
                "answer": 1,
                "explanation": "Primitives in Java are passed by value."
            },
            {
                "id": "PP022",
                "question": "Which parameter passing method is default for objects in Java?",
                "options": [
                    "Call by value",
                    "Call by reference",
                    "Call by object reference",
                    "Call by pointer"
                ],
                "answer": 2,
                "explanation": "Objects are passed by value of the reference in Java; modifications to the object affect original."
            },
            {
                "id": "PP023",
                "question": "Which of the following is true about pointer parameters in C?",
                "options": [
                    "Allow call by reference simulation",
                    "Cannot modify original variable",
                    "Copies variable automatically",
                    "Cannot pass structures"
                ],
                "answer": 0,
                "explanation": "Pointer parameters allow the function to access and modify the original variable."
            },
            {
                "id": "PP024",
                "question": "Which method avoids copying large data when passing to functions?",
                "options": [
                    "Call by value",
                    "Call by reference",
                    "Call by constant value",
                    "Call by primitive"
                ],
                "answer": 1,
                "explanation": "Call by reference passes address instead of copying, saving memory and time."
            },
            {
                "id": "PP025",
                "question": "Which of the following is **true** about call by constant reference?",
                "options": [
                    "Function can modify original variable",
                    "Function cannot modify original variable",
                    "Slower than call by value always",
                    "Cannot pass objects"
                ],
                "answer": 1,
                "explanation": "Call by const reference ensures efficiency and prevents modification of the original object."
            },
            {
                "id": "PP026",
                "question": "Which parameter passing method is used for strings in C++ efficiently?",
                "options": [
                    "Call by value",
                    "Call by reference",
                    "Call by const reference",
                    "Call by pointer"
                ],
                "answer": 2,
                "explanation": "Call by const reference avoids copying large strings and prevents modification."
            },
            {
                "id": "PP027",
                "question": "Which of the following is **false** about call by reference in C++?",
                "options": [
                    "Can modify original variable",
                    "Requires '&' in function declaration",
                    "Faster than call by value for large objects",
                    "Cannot pass primitive types"
                ],
                "answer": 3,
                "explanation": "Primitive types can also be passed by reference; call by reference is not restricted to objects."
            },
            {
                "id": "PP028",
                "question": "Which of the following is true for parameters passed by value?",
                "options": [
                    "Function modifies the original variable",
                    "Function works on copy only",
                    "Always passed using pointers",
                    "Cannot pass structures"
                ],
                "answer": 1,
                "explanation": "Call by value passes a copy; changes inside the function do not affect the original."
            },
            {
                "id": "PP029",
                "question": "Which of the following is **false** about call by pointer?",
                "options": [
                    "Can modify original variable",
                    "Passes address of variable",
                    "Simulates call by reference",
                    "Cannot modify object members"
                ],
                "answer": 3,
                "explanation": "Call by pointer can be used to modify object members by dereferencing the pointer."
            },
            {
                "id": "PP030",
                "question": "Which of the following is **true** about passing arrays to functions in C?",
                "options": [
                    "Passed by value",
                    "Passed by reference as pointer",
                    "Cannot be passed",
                    "Copied entirely"
                ],
                "answer": 1,
                "explanation": "Array name decays to pointer; function receives address of first element."
            },
            {
                "id": "PP031",
                "question": "Which of the following is true about passing objects by reference in C++?",
                "options": [
                    "Copies the entire object",
                    "Function can modify original object",
                    "Original object is protected",
                    "Cannot pass objects"
                ],
                "answer": 1,
                "explanation": "Passing by reference allows the function to modify the original object without copying it."
            },
            {
                "id": "PP032",
                "question": "Which of the following is true about 'call by value of reference' in Java?",
                "options": [
                    "Copies primitive values",
                    "Copies object reference",
                    "Copies the entire object",
                    "Cannot pass objects"
                ],
                "answer": 1,
                "explanation": "Java copies the reference of the object (not the object itself), so both caller and function refer to the same object."
            },
            {
                "id": "PP033",
                "question": "Which of the following is true about passing constants as parameters?",
                "options": [
                    "Call by value cannot pass constants",
                    "Call by reference cannot accept const reference",
                    "Const reference allows passing constants efficiently",
                    "Cannot pass constants to functions"
                ],
                "answer": 2,
                "explanation": "Const reference allows passing constants efficiently without copying and ensures they are not modified."
            },
            {
                "id": "PP034",
                "question": "Which of the following is **false** about call by value in Java?",
                "options": [
                    "Cannot modify primitive arguments",
                    "Objects cannot be modified",
                    "Primitives are passed by value",
                    "Changes to object references inside function do not affect caller reference"
                ],
                "answer": 1,
                "explanation": "Object state can still be modified; only the reference itself is passed by value."
            },
            {
                "id": "PP035",
                "question": "Which of the following is **true** for pointer parameters in C?",
                "options": [
                    "Function cannot access original variable",
                    "Function can modify original variable using dereferencing",
                    "Pointers are always copied by value",
                    "Cannot be used for arrays"
                ],
                "answer": 1,
                "explanation": "Using dereferencing, the function can modify the original variable pointed by the pointer."
            },
            {
                "id": "PP036",
                "question": "Which of the following is the most memory-efficient way to pass a large object to a function in C++?",
                "options": [
                    "Call by value",
                    "Call by reference",
                    "Call by pointer",
                    "Call by constant value"
                ],
                "answer": 1,
                "explanation": "Call by reference passes the address, avoiding copying the entire object."
            },
            {
                "id": "PP037",
                "question": "Which of the following statements is **true** about call by reference vs call by value?",
                "options": [
                    "Call by value is faster for large objects",
                    "Call by reference prevents modification",
                    "Call by reference allows function to modify caller variable",
                    "Call by value allows function to modify caller variable"
                ],
                "answer": 2,
                "explanation": "Call by reference allows modification of the original variable; call by value works on a copy."
            },
            {
                "id": "PP038",
                "question": "Which of the following is **true** about passing primitive arrays in Java?",
                "options": [
                    "Passed by value of elements",
                    "Passed by reference to array",
                    "Cannot pass arrays",
                    "Elements cannot be modified"
                ],
                "answer": 1,
                "explanation": "Arrays in Java are objects, and references to them are passed; modifications to elements affect original array."
            },
            {
                "id": "PP039",
                "question": "Which of the following is true about passing objects to functions in Java?",
                "options": [
                    "Changes to object state affect original object",
                    "Cannot modify object state",
                    "Object is copied entirely",
                    "Function receives only object class name"
                ],
                "answer": 0,
                "explanation": "Objects are passed by reference value; function can modify the object's internal state."
            },
            {
                "id": "PP040",
                "question": "Which of the following is true for call by value vs call by reference in C++?",
                "options": [
                    "Call by reference cannot modify original variable",
                    "Call by value modifies original variable",
                    "Call by value works on copy, call by reference works on original",
                    "Both work on original variable"
                ],
                "answer": 2,
                "explanation": "Call by value works on a copy; call by reference works on the original variable, allowing modification."
            },
            {
                "id": "PP041",
                "question": "Which of the following is **true** about passing objects in C++?",
                "options": [
                    "Always passed by value",
                    "Always passed by reference",
                    "Can be passed by value, reference, or const reference",
                    "Cannot be passed to functions"
                ],
                "answer": 2,
                "explanation": "Objects can be passed by value, by reference, or by const reference for efficiency and safety."
            },
            {
                "id": "PP042",
                "question": "Which of the following is **false** about passing arrays in C++?",
                "options": [
                    "Array decays to pointer when passed",
                    "Function receives address of first element",
                    "Entire array is copied automatically",
                    "Function can modify array elements"
                ],
                "answer": 2,
                "explanation": "Arrays are not copied automatically; function receives pointer to first element."
            },
            {
                "id": "PP043",
                "question": "Which of the following is **true** about passing objects by const reference in C++?",
                "options": [
                    "Cannot pass temporary objects",
                    "Function can modify object",
                    "Efficient for large objects and prevents modification",
                    "Always slower than call by value"
                ],
                "answer": 2,
                "explanation": "Passing by const reference avoids copying large objects and ensures the function cannot modify them."
            },
            {
                "id": "PP044",
                "question": "Which of the following is **true** for call by reference using pointers in C?",
                "options": [
                    "Cannot pass multiple variables",
                    "Function cannot modify variable",
                    "Requires dereferencing to access original variable",
                    "Pointer always points to null"
                ],
                "answer": 2,
                "explanation": "Dereferencing the pointer inside the function allows access and modification of the original variable."
            },
            {
                "id": "PP045",
                "question": "Which parameter passing method ensures original data cannot be modified?",
                "options": [
                    "Call by value",
                    "Call by reference",
                    "Call by pointer",
                    "Call by reference with const"
                ],
                "answer": 3,
                "explanation": "Call by reference with const allows access without copying but prevents modification."
            },
            {
                "id": "PP046",
                "question": "Which of the following is **false** about call by value in Java?",
                "options": [
                    "Primitives are passed by value",
                    "Objects references are copied",
                    "Function can modify object state",
                    "Function can change primitive value in caller"
                ],
                "answer": 3,
                "explanation": "Primitives are passed by value; function cannot modify original primitive value."
            },
            {
                "id": "PP047",
                "question": "Which of the following statements is **true** about parameter passing efficiency?",
                "options": [
                    "Call by value is efficient for large objects",
                    "Call by reference is inefficient for large objects",
                    "Call by const reference combines efficiency and safety",
                    "Call by value cannot be used for primitives"
                ],
                "answer": 2,
                "explanation": "Call by const reference avoids copying large objects and prevents modification, providing efficiency and safety."
            },
            {
                "id": "PP048",
                "question": "Which of the following allows a function to modify multiple arguments in C?",
                "options": [
                    "Call by value",
                    "Call by reference using pointers",
                    "Call by temporary",
                    "Call by object reference"
                ],
                "answer": 1,
                "explanation": "Passing multiple arguments by pointer allows the function to modify them directly."
            },
            {
                "id": "PP049",
                "question": "Which parameter passing method is used when passing strings in C?",
                "options": [
                    "Call by value",
                    "Call by reference using pointers",
                    "Call by object reference",
                    "Cannot pass strings"
                ],
                "answer": 1,
                "explanation": "Strings (character arrays) are passed as pointers to their first element, simulating call by reference."
            },
            {
                "id": "PP050",
                "question": "Which of the following is **true** about passing large structs in C efficiently?",
                "options": [
                    "Pass by value always",
                    "Pass by pointer",
                    "Cannot pass structs",
                    "Copy entire struct always"
                ],
                "answer": 1,
                "explanation": "Passing structs by pointer avoids copying large data, increasing efficiency."
            }
        ],
        "Functional & Logic Programming": [
            {
                "id": "FL001",
                "question": "Which of the following programming paradigms emphasizes pure functions and avoids side-effects?",
                "options": [
                    "Object-oriented programming",
                    "Functional programming",
                    "Procedural programming",
                    "Logic programming"
                ],
                "answer": 1,
                "explanation": "Functional programming emphasizes pure functions, immutability, and avoids side-effects."
            },
            {
                "id": "FL002",
                "question": "Which of the following is a feature of functional programming?",
                "options": [
                    "Use of loops for iteration",
                    "Immutability of data",
                    "Inheritance of classes",
                    "Global variables"
                ],
                "answer": 1,
                "explanation": "Functional programming encourages immutability, avoiding changes to data once created."
            },
            {
                "id": "FL003",
                "question": "Which of the following C++ constructs supports functional programming style?",
                "options": [
                    "Lambda expressions",
                    "Virtual functions",
                    "Pointers",
                    "Inline functions"
                ],
                "answer": 0,
                "explanation": "Lambda expressions allow defining anonymous functions, supporting functional programming style."
            },
            {
                "id": "FL004",
                "question": "In Java, which feature supports functional programming?",
                "options": [
                    "Abstract classes",
                    "Lambda expressions",
                    "Static variables",
                    "Synchronized methods"
                ],
                "answer": 1,
                "explanation": "Java 8 introduced lambda expressions, enabling functional programming constructs."
            },
            {
                "id": "FL005",
                "question": "Which of the following is a core concept of logic programming?",
                "options": [
                    "Using classes and objects",
                    "Defining rules and facts",
                    "Loop-based iteration",
                    "Using pointers"
                ],
                "answer": 1,
                "explanation": "Logic programming defines rules and facts to derive conclusions using a reasoning engine."
            },
            {
                "id": "FL006",
                "question": "Which language is primarily designed for logic programming?",
                "options": [
                    "C++",
                    "Java",
                    "Prolog",
                    "Python"
                ],
                "answer": 2,
                "explanation": "Prolog is a logic programming language based on rules and facts."
            },
            {
                "id": "FL007",
                "question": "Which of the following functional programming principles avoids modifying existing data?",
                "options": [
                    "Polymorphism",
                    "Immutability",
                    "Encapsulation",
                    "Inheritance"
                ],
                "answer": 1,
                "explanation": "Immutability ensures data cannot be modified after creation, a key functional programming principle."
            },
            {
                "id": "FL008",
                "question": "Which of the following is an example of higher-order function?",
                "options": [
                    "A function that takes another function as argument",
                    "A function that returns integer only",
                    "A function without parameters",
                    "A function with loops"
                ],
                "answer": 0,
                "explanation": "Higher-order functions either take functions as arguments or return functions as results."
            },
            {
                "id": "FL009",
                "question": "Which of the following is true about pure functions?",
                "options": [
                    "Depend on global variables",
                    "Produce side effects",
                    "Return the same output for same input",
                    "Modify input parameters"
                ],
                "answer": 2,
                "explanation": "Pure functions always return the same output for the same input and do not produce side effects."
            },
            {
                "id": "FL010",
                "question": "Which of the following is a benefit of functional programming?",
                "options": [
                    "Encourages side-effects",
                    "Simplifies reasoning about programs",
                    "Increases mutable state",
                    "Requires loops for iteration"
                ],
                "answer": 1,
                "explanation": "Functional programming avoids side-effects and mutable state, making programs easier to reason about."
            },
            {
                "id": "FL011",
                "question": "Which of the following is a logic programming technique?",
                "options": [
                    "Recursion",
                    "Backtracking",
                    "Pointers",
                    "Iteration"
                ],
                "answer": 1,
                "explanation": "Backtracking is used in logic programming to explore multiple possibilities to satisfy constraints."
            },
            {
                "id": "FL012",
                "question": "In functional programming, which of the following avoids loops for iteration?",
                "options": [
                    "Recursion",
                    "Pointers",
                    "Arrays",
                    "Classes"
                ],
                "answer": 0,
                "explanation": "Functional programming often uses recursion instead of loops to process data."
            },
            {
                "id": "FL013",
                "question": "Which of the following is true about logic programming?",
                "options": [
                    "Execution is based on evaluating expressions",
                    "Execution is based on applying rules and facts",
                    "Execution is based on loops and counters",
                    "Execution is based on object instantiation"
                ],
                "answer": 1,
                "explanation": "Logic programming uses rules and facts; the interpreter derives conclusions from them."
            },
            {
                "id": "FL014",
                "question": "Which of the following is an example of declarative programming?",
                "options": [
                    "C++ procedural code",
                    "Java lambda expressions",
                    "SQL queries",
                    "For loop in C"
                ],
                "answer": 2,
                "explanation": "Declarative programming expresses what to do rather than how; SQL is a declarative language."
            },
            {
                "id": "FL015",
                "question": "Which of the following is **true** about recursion in functional programming?",
                "options": [
                    "Loops are required",
                    "Recursion replaces iteration",
                    "Global variables are mandatory",
                    "Functions cannot call themselves"
                ],
                "answer": 1,
                "explanation": "Recursion is used instead of loops to achieve iteration in functional programming."
            },
            {
                "id": "FL016",
                "question": "Which of the following is a functional programming concept for processing collections?",
                "options": [
                    "Map, filter, reduce",
                    "Pointers and arrays",
                    "Objects and classes",
                    "Inheritance"
                ],
                "answer": 0,
                "explanation": "Map, filter, and reduce are common functional programming constructs to process collections."
            },
            {
                "id": "FL017",
                "question": "Which of the following is true about Prolog?",
                "options": [
                    "Supports imperative loops",
                    "Uses facts, rules, and queries",
                    "Supports mutable global state",
                    "Uses classes and objects"
                ],
                "answer": 1,
                "explanation": "Prolog programs consist of facts, rules, and queries; it is a logic programming language."
            },
            {
                "id": "FL018",
                "question": "Which of the following is true about first-class functions?",
                "options": [
                    "Functions cannot be assigned to variables",
                    "Functions cannot be passed as arguments",
                    "Functions can be treated as values",
                    "Functions cannot be returned from other functions"
                ],
                "answer": 2,
                "explanation": "In functional programming, functions are first-class citizens and can be assigned, passed, and returned."
            },
            {
                "id": "FL019",
                "question": "Which of the following is **false** about pure functions?",
                "options": [
                    "Do not depend on global state",
                    "Do not modify input parameters",
                    "Always use loops for iteration",
                    "Return same output for same input"
                ],
                "answer": 2,
                "explanation": "Pure functions can use recursion instead of loops; they do not require loops."
            },
            {
                "id": "FL020",
                "question": "Which of the following is an advantage of logic programming?",
                "options": [
                    "Simplifies object-oriented design",
                    "Simplifies problem-solving with constraints",
                    "Faster than procedural programming always",
                    "Requires loops for every problem"
                ],
                "answer": 1,
                "explanation": "Logic programming is ideal for constraint solving and reasoning problems using rules."
            },
            {
                "id": "FL021",
                "question": "Which of the following is a key property of functional programming?",
                "options": [
                    "Mutable state",
                    "Encapsulation",
                    "No side-effects",
                    "Inheritance"
                ],
                "answer": 2,
                "explanation": "Functional programming avoids side-effects to maintain predictable behavior."
            },
            {
                "id": "FL022",
                "question": "Which of the following statements is true about recursion in functional programming?",
                "options": [
                    "Cannot be used for loops",
                    "Is used instead of loops for iteration",
                    "Always modifies global variables",
                    "Not allowed in functional programming"
                ],
                "answer": 1,
                "explanation": "Recursion is a primary method for iteration in functional programming, replacing loops."
            },
            {
                "id": "FL023",
                "question": "Which of the following functional programming features supports immutability?",
                "options": [
                    "Using global variables",
                    "Avoiding assignment to existing variables",
                    "Using loops",
                    "Using object inheritance"
                ],
                "answer": 1,
                "explanation": "Immutability is achieved by not assigning new values to existing variables."
            },
            {
                "id": "FL024",
                "question": "Which of the following logic programming concepts allows searching multiple possibilities?",
                "options": [
                    "Recursion",
                    "Backtracking",
                    "Lambda expressions",
                    "Map-Reduce"
                ],
                "answer": 1,
                "explanation": "Backtracking systematically searches multiple possibilities to satisfy constraints."
            },
            {
                "id": "FL025",
                "question": "Which of the following is true about functional programming in Java?",
                "options": [
                    "Introduced with Java 8 lambda expressions",
                    "Cannot use collections",
                    "Requires pointers",
                    "Does not support recursion"
                ],
                "answer": 0,
                "explanation": "Java 8 introduced lambda expressions, enabling functional programming paradigms."
            },
            {
                "id": "FL026",
                "question": "Which of the following is true about declarative programming?",
                "options": [
                    "Specifies how to perform computation",
                    "Specifies what to compute",
                    "Requires loops for iteration",
                    "Cannot use functions"
                ],
                "answer": 1,
                "explanation": "Declarative programming focuses on what computation should be performed, not how."
            },
            {
                "id": "FL027",
                "question": "Which of the following is true about higher-order functions?",
                "options": [
                    "Cannot return other functions",
                    "Can take functions as arguments and return functions",
                    "Cannot take arguments",
                    "Always produce side-effects"
                ],
                "answer": 1,
                "explanation": "Higher-order functions can take other functions as arguments and/or return functions."
            },
            {
                "id": "FL028",
                "question": "Which of the following is true for immutability in functional programming?",
                "options": [
                    "Data cannot be changed after creation",
                    "Data is always global",
                    "Data can be changed inside functions",
                    "Loops are mandatory"
                ],
                "answer": 0,
                "explanation": "Immutability ensures data cannot be modified once created."
            },
            {
                "id": "FL029",
                "question": "Which of the following is a logic programming language?",
                "options": [
                    "C",
                    "Prolog",
                    "Java",
                    "Python"
                ],
                "answer": 1,
                "explanation": "Prolog is a declarative logic programming language based on facts and rules."
            },
            {
                "id": "FL030",
                "question": "Which of the following functional programming constructs is used to transform lists?",
                "options": [
                    "Map",
                    "Filter",
                    "Reduce",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Map transforms elements, filter selects elements, reduce combines elements; all are common functional constructs."
            },
            {
                "id": "FL031",
                "question": "Which of the following is true about 'filter' in functional programming?",
                "options": [
                    "Transforms each element of a list",
                    "Selects elements based on a predicate",
                    "Combines elements to a single value",
                    "Modifies original list"
                ],
                "answer": 1,
                "explanation": "Filter selects elements from a collection that satisfy a given condition without modifying the original list."
            },
            {
                "id": "FL032",
                "question": "Which of the following is true about 'reduce' in functional programming?",
                "options": [
                    "Selects elements based on a condition",
                    "Transforms each element individually",
                    "Combines elements into a single value",
                    "Cannot be used with lists"
                ],
                "answer": 2,
                "explanation": "Reduce (or fold) applies a function cumulatively to combine elements into a single result."
            },
            {
                "id": "FL033",
                "question": "Which of the following is true about pure functions?",
                "options": [
                    "Depends on external state",
                    "Produces side effects",
                    "Always returns same output for same input",
                    "Modifies global variables"
                ],
                "answer": 2,
                "explanation": "Pure functions do not depend on external state or produce side effects and always return the same output for the same input."
            },
            {
                "id": "FL034",
                "question": "Which of the following is a property of functional programming languages?",
                "options": [
                    "Emphasizes mutable state",
                    "Supports first-class functions",
                    "Relies heavily on loops",
                    "Requires classes and objects"
                ],
                "answer": 1,
                "explanation": "Functional languages treat functions as first-class citizens that can be assigned, passed, and returned."
            },
            {
                "id": "FL035",
                "question": "Which of the following logic programming features allows defining knowledge base?",
                "options": [
                    "Objects",
                    "Facts and rules",
                    "Loops",
                    "Lambda expressions"
                ],
                "answer": 1,
                "explanation": "Logic programming uses facts and rules to define a knowledge base from which queries can be answered."
            },
            {
                "id": "FL036",
                "question": "Which of the following is true about recursion in logic programming?",
                "options": [
                    "Cannot be used",
                    "Used to explore multiple possibilities",
                    "Always modifies global state",
                    "Replaces functions in C++"
                ],
                "answer": 1,
                "explanation": "Recursion is used to solve problems by exploring multiple possibilities in logic programming."
            },
            {
                "id": "FL037",
                "question": "Which of the following is a declarative programming example?",
                "options": [
                    "C++ procedural code",
                    "SQL query",
                    "Java for loop",
                    "C pointer arithmetic"
                ],
                "answer": 1,
                "explanation": "SQL query is declarative because it specifies what data to retrieve without defining how to retrieve it."
            },
            {
                "id": "FL038",
                "question": "Which of the following is true about backtracking in logic programming?",
                "options": [
                    "Only used in C++",
                    "Explores multiple solutions for a query",
                    "Modifies variables using pointers",
                    "Uses loops instead of recursion"
                ],
                "answer": 1,
                "explanation": "Backtracking systematically searches for multiple solutions to satisfy the rules in logic programming."
            },
            {
                "id": "FL039",
                "question": "Which of the following is true about immutability in functional programming?",
                "options": [
                    "Data can be changed freely",
                    "Data cannot be modified after creation",
                    "Loops are required",
                    "Only applies to primitive types"
                ],
                "answer": 1,
                "explanation": "Immutability ensures that once data is created, it cannot be altered, reducing side-effects."
            },
            {
                "id": "FL040",
                "question": "Which of the following is true about first-class functions?",
                "options": [
                    "Cannot be assigned to variables",
                    "Cannot be passed as arguments",
                    "Can be returned from other functions",
                    "Cannot be used in C++"
                ],
                "answer": 2,
                "explanation": "First-class functions can be assigned, passed, and returned like any other value."
            },
            {
                "id": "FL041",
                "question": "Which of the following statements is true for Prolog execution?",
                "options": [
                    "Uses loops for iteration",
                    "Queries are answered using unification and backtracking",
                    "Requires objects and classes",
                    "Modifies global variables frequently"
                ],
                "answer": 1,
                "explanation": "Prolog uses unification and backtracking to answer queries based on facts and rules."
            },
            {
                "id": "FL042",
                "question": "Which of the following is true about functional programming in C++?",
                "options": [
                    "C++ does not support functional style",
                    "Lambda expressions and std::function support functional style",
                    "Requires pointers only",
                    "Loops must be used instead of recursion"
                ],
                "answer": 1,
                "explanation": "C++ supports functional programming via lambda expressions and std::function constructs."
            },
            {
                "id": "FL043",
                "question": "Which of the following is true about logic programming?",
                "options": [
                    "Focuses on how to compute",
                    "Focuses on what to compute using rules and facts",
                    "Emphasizes loops and counters",
                    "Requires object inheritance"
                ],
                "answer": 1,
                "explanation": "Logic programming specifies what to compute using rules and facts rather than specifying how to compute it."
            },
            {
                "id": "FL044",
                "question": "Which of the following is true about higher-order functions in Java?",
                "options": [
                    "Cannot accept lambda expressions as arguments",
                    "Can accept functions as arguments and return functions",
                    "Cannot return functions",
                    "Cannot operate on collections"
                ],
                "answer": 1,
                "explanation": "Higher-order functions in Java can take lambda expressions as arguments and can return functions."
            },
            {
                "id": "FL045",
                "question": "Which of the following is true about map in functional programming?",
                "options": [
                    "Selects elements based on a condition",
                    "Applies a function to each element and returns a new collection",
                    "Combines elements into a single value",
                    "Modifies the original collection"
                ],
                "answer": 1,
                "explanation": "Map applies a given function to each element and returns a new collection without modifying the original."
            },
            {
                "id": "FL046",
                "question": "Which of the following is true about filter in functional programming?",
                "options": [
                    "Combines elements into a single value",
                    "Selects elements based on predicate function",
                    "Applies function to all elements and returns transformed collection",
                    "Modifies elements in place"
                ],
                "answer": 1,
                "explanation": "Filter selects elements satisfying a condition without modifying the original collection."
            },
            {
                "id": "FL047",
                "question": "Which of the following is true about reduce (fold) in functional programming?",
                "options": [
                    "Selects elements satisfying a condition",
                    "Transforms each element individually",
                    "Combines all elements into a single cumulative value",
                    "Does not work with collections"
                ],
                "answer": 2,
                "explanation": "Reduce applies a function cumulatively to combine all elements into a single result."
            },
            {
                "id": "FL048",
                "question": "Which of the following is true about pure functions in functional programming?",
                "options": [
                    "May modify global state",
                    "Returns different outputs for same input",
                    "Always return same output for same input and no side effects",
                    "Cannot be used in recursion"
                ],
                "answer": 2,
                "explanation": "Pure functions always return the same output for same input and do not produce side-effects."
            },
            {
                "id": "FL049",
                "question": "Which of the following is a logic programming technique for solving problems?",
                "options": [
                    "Iteration",
                    "Backtracking",
                    "Pointers",
                    "Loops"
                ],
                "answer": 1,
                "explanation": "Backtracking systematically explores all possible solutions to satisfy logic programming rules."
            },
            {
                "id": "FL050",
                "question": "Which of the following is an advantage of functional and logic programming?",
                "options": [
                    "Simpler reasoning about code and solving complex problems declaratively",
                    "Requires mutable state",
                    "Always uses loops",
                    "Cannot be used for collections"
                ],
                "answer": 0,
                "explanation": "Functional and logic programming reduce side-effects and allow declarative problem-solving, simplifying reasoning about code."
            }
        ],
        "OOP Concepts": [
            {
                "id": "OOPS001",
                "question": "Which of the following is a fundamental concept of OOP?",
                "options": [
                    "Encapsulation",
                    "Pointers",
                    "Procedures",
                    "Arrays"
                ],
                "answer": 0,
                "explanation": "Encapsulation is one of the four core OOP concepts along with inheritance, polymorphism, and abstraction."
            },
            {
                "id": "OOPS002",
                "question": "Which concept of OOP hides internal implementation and exposes only functionality?",
                "options": [
                    "Inheritance",
                    "Encapsulation",
                    "Polymorphism",
                    "Abstraction"
                ],
                "answer": 3,
                "explanation": "Abstraction hides the internal implementation details and shows only essential features."
            },
            {
                "id": "OOPS003",
                "question": "Which of the following enables one class to acquire properties of another class?",
                "options": [
                    "Polymorphism",
                    "Encapsulation",
                    "Inheritance",
                    "Abstraction"
                ],
                "answer": 2,
                "explanation": "Inheritance allows a class to inherit properties and behaviors from another class."
            },
            {
                "id": "OOPS004",
                "question": "Which OOP concept allows a single function to operate differently on different data types?",
                "options": [
                    "Polymorphism",
                    "Encapsulation",
                    "Abstraction",
                    "Inheritance"
                ],
                "answer": 0,
                "explanation": "Polymorphism allows methods to have different behaviors based on input types or objects."
            },
            {
                "id": "OOPS005",
                "question": "Which of the following ensures data is accessed only through methods?",
                "options": [
                    "Abstraction",
                    "Encapsulation",
                    "Polymorphism",
                    "Inheritance"
                ],
                "answer": 1,
                "explanation": "Encapsulation restricts direct access to data and allows access only via methods."
            },
            {
                "id": "OOPS006",
                "question": "Which of the following is **not** an OOP principle?",
                "options": [
                    "Polymorphism",
                    "Inheritance",
                    "Recursion",
                    "Abstraction"
                ],
                "answer": 2,
                "explanation": "Recursion is a programming technique, not an OOP principle."
            },
            {
                "id": "OOPS007",
                "question": "Which of the following describes a class in OOP?",
                "options": [
                    "A blueprint for creating objects",
                    "An instance of an object",
                    "A pointer to data",
                    "A function only"
                ],
                "answer": 0,
                "explanation": "A class is a blueprint or template from which objects are created."
            },
            {
                "id": "OOPS008",
                "question": "Which of the following is an instance of a class?",
                "options": [
                    "Object",
                    "Pointer",
                    "Function",
                    "Method"
                ],
                "answer": 0,
                "explanation": "An object is a specific instance created from a class."
            },
            {
                "id": "OOPS009",
                "question": "Which of the following describes a constructor?",
                "options": [
                    "A method that returns integer",
                    "A method that initializes objects",
                    "A static function",
                    "A global function"
                ],
                "answer": 1,
                "explanation": "Constructors initialize objects when they are created."
            },
            {
                "id": "OOPS010",
                "question": "Which of the following is true about constructors?",
                "options": [
                    "Can have return type",
                    "Has same name as class",
                    "Must be static",
                    "Cannot take parameters"
                ],
                "answer": 1,
                "explanation": "Constructors must have the same name as the class and do not have a return type."
            },
            {
                "id": "OOPS011",
                "question": "Which type of constructor is automatically called when an object is created?",
                "options": [
                    "Default constructor",
                    "Copy constructor",
                    "Static constructor",
                    "Destructor"
                ],
                "answer": 0,
                "explanation": "The default constructor is called automatically when an object is created."
            },
            {
                "id": "OOPS012",
                "question": "Which type of constructor creates a copy of an existing object?",
                "options": [
                    "Default constructor",
                    "Copy constructor",
                    "Parameterized constructor",
                    "Destructor"
                ],
                "answer": 1,
                "explanation": "Copy constructor initializes a new object as a copy of an existing object."
            },
            {
                "id": "OOPS013",
                "question": "Which of the following allows a class to have multiple functions with same name but different parameters?",
                "options": [
                    "Polymorphism",
                    "Encapsulation",
                    "Function overloading",
                    "Abstraction"
                ],
                "answer": 2,
                "explanation": "Function overloading allows multiple functions with same name but different parameters."
            },
            {
                "id": "OOPS014",
                "question": "Which of the following allows a derived class to redefine a base class method?",
                "options": [
                    "Function overloading",
                    "Function overriding",
                    "Encapsulation",
                    "Abstraction"
                ],
                "answer": 1,
                "explanation": "Function overriding allows a derived class to provide a new implementation of a base class method."
            },
            {
                "id": "OOPS015",
                "question": "Which of the following is true about virtual functions in C++?",
                "options": [
                    "They enable compile-time binding",
                    "They enable runtime polymorphism",
                    "Cannot be overridden",
                    "Cannot be inherited"
                ],
                "answer": 1,
                "explanation": "Virtual functions enable runtime polymorphism allowing dynamic method resolution."
            },
            {
                "id": "OOPS016",
                "question": "Which access specifier allows members to be accessed only within the class?",
                "options": [
                    "public",
                    "private",
                    "protected",
                    "default"
                ],
                "answer": 1,
                "explanation": "Private members are accessible only within the class."
            },
            {
                "id": "OOPS017",
                "question": "Which access specifier allows members to be accessed within the class and its derived classes?",
                "options": [
                    "public",
                    "private",
                    "protected",
                    "default"
                ],
                "answer": 2,
                "explanation": "Protected members can be accessed within the class and by derived classes."
            },
            {
                "id": "OOPS018",
                "question": "Which access specifier allows members to be accessed from anywhere?",
                "options": [
                    "public",
                    "private",
                    "protected",
                    "default"
                ],
                "answer": 0,
                "explanation": "Public members can be accessed from any part of the program."
            },
            {
                "id": "OOPS019",
                "question": "Which of the following describes encapsulation?",
                "options": [
                    "Combining data and methods in a class",
                    "Separating data and functions",
                    "Accessing global variables",
                    "Overloading functions"
                ],
                "answer": 0,
                "explanation": "Encapsulation combines data and methods into a single unit called a class."
            },
            {
                "id": "OOPS020",
                "question": "Which OOP concept allows code reuse by creating a hierarchy of classes?",
                "options": [
                    "Polymorphism",
                    "Inheritance",
                    "Abstraction",
                    "Encapsulation"
                ],
                "answer": 1,
                "explanation": "Inheritance allows derived classes to reuse code from base classes."
            },
            {
                "id": "OOPS021",
                "question": "Which of the following is true about abstract classes?",
                "options": [
                    "Cannot have methods",
                    "Cannot be instantiated",
                    "Cannot have data members",
                    "Cannot be inherited"
                ],
                "answer": 1,
                "explanation": "Abstract classes cannot be instantiated and are meant to be inherited."
            },
            {
                "id": "OOPS022",
                "question": "Which of the following is true about interfaces in Java?",
                "options": [
                    "Can contain concrete methods only",
                    "Cannot have abstract methods",
                    "All methods are abstract by default",
                    "Cannot be implemented by classes"
                ],
                "answer": 2,
                "explanation": "In Java, all interface methods are abstract by default (except default and static methods)."
            },
            {
                "id": "OOPS023",
                "question": "Which of the following is true about multiple inheritance in Java?",
                "options": [
                    "Allowed with classes",
                    "Allowed with interfaces",
                    "Not allowed with interfaces",
                    "Completely not allowed"
                ],
                "answer": 1,
                "explanation": "Java allows multiple inheritance using interfaces, but not with classes."
            },
            {
                "id": "OOPS024",
                "question": "Which of the following is true about destructor in C++?",
                "options": [
                    "Called automatically when object is destroyed",
                    "Called to create object",
                    "Must return integer",
                    "Cannot be overloaded"
                ],
                "answer": 0,
                "explanation": "Destructor is called automatically to release resources when an object goes out of scope."
            },
            {
                "id": "OOPS025",
                "question": "Which of the following is true about 'this' pointer in C++?",
                "options": [
                    "Points to global variable",
                    "Points to current object",
                    "Points to base class only",
                    "Cannot be used inside class"
                ],
                "answer": 1,
                "explanation": "'this' pointer refers to the current object inside class methods."
            },
            {
                "id": "OOPS026",
                "question": "Which of the following is true about constructor overloading?",
                "options": [
                    "Multiple constructors with same name but different parameters",
                    "Constructors cannot be overloaded",
                    "Overloading requires return type change",
                    "Only default constructor allowed"
                ],
                "answer": 0,
                "explanation": "Constructor overloading allows multiple constructors with different parameters in the same class."
            },
            {
                "id": "OOPS027",
                "question": "Which of the following is true about static members in a class?",
                "options": [
                    "Belongs to object instance",
                    "Belongs to class, shared by all objects",
                    "Cannot be accessed outside class",
                    "Cannot be initialized"
                ],
                "answer": 1,
                "explanation": "Static members are shared among all objects of the class and belong to the class itself."
            },
            {
                "id": "OOPS028",
                "question": "Which of the following is true about final class in Java?",
                "options": [
                    "Can be inherited",
                    "Cannot be inherited",
                    "Cannot have methods",
                    "Cannot have data members"
                ],
                "answer": 1,
                "explanation": "A final class cannot be inherited."
            },
            {
                "id": "OOPS029",
                "question": "Which of the following is true about final method in Java?",
                "options": [
                    "Can be overridden",
                    "Cannot be overridden",
                    "Cannot be accessed",
                    "Must be static"
                ],
                "answer": 1,
                "explanation": "A final method cannot be overridden by subclasses."
            },
            {
                "id": "OOPS030",
                "question": "Which of the following is true about object slicing in C++?",
                "options": [
                    "Derived class object assigned to base class object loses derived part",
                    "Base class object assigned to derived class object loses base part",
                    "Objects cannot be assigned",
                    "Slicing does not occur"
                ],
                "answer": 0,
                "explanation": "When a derived object is assigned to a base object, the extra data members of derived class are sliced off."
            },
            {
                "id": "OOPS031",
                "question": "Which of the following allows overriding of operators in C++?",
                "options": [
                    "Operator overloading",
                    "Virtual functions",
                    "Encapsulation",
                    "Polymorphism"
                ],
                "answer": 0,
                "explanation": "Operator overloading allows redefining the behavior of operators for user-defined types."
            },
            {
                "id": "OOPS032",
                "question": "Which of the following is true about multiple constructors in C++?",
                "options": [
                    "Cannot exist",
                    "Can exist with different parameter lists",
                    "Only one default constructor allowed",
                    "Must be static"
                ],
                "answer": 1,
                "explanation": "C++ supports multiple constructors with different parameter lists in the same class."
            },
            {
                "id": "OOPS033",
                "question": "Which of the following is true about pure virtual function?",
                "options": [
                    "Has implementation in base class",
                    "Must be overridden in derived class",
                    "Cannot be overridden",
                    "Cannot be declared in base class"
                ],
                "answer": 1,
                "explanation": "Pure virtual functions are declared in base class and must be overridden in derived class."
            },
            {
                "id": "OOPS034",
                "question": "Which of the following is true about abstract class in C++?",
                "options": [
                    "Can be instantiated",
                    "Cannot be instantiated",
                    "Cannot have virtual functions",
                    "Cannot have data members"
                ],
                "answer": 1,
                "explanation": "Abstract classes cannot be instantiated and can contain pure virtual functions."
            },
            {
                "id": "OOPS035",
                "question": "Which of the following is true about virtual inheritance in C++?",
                "options": [
                    "Used to avoid multiple copies of base class in diamond problem",
                    "Does not affect inheritance",
                    "Used for polymorphism only",
                    "Cannot be applied to abstract class"
                ],
                "answer": 0,
                "explanation": "Virtual inheritance avoids duplication of base class when using multiple inheritance (diamond problem)."
            },
            {
                "id": "OOPS036",
                "question": "Which of the following is true about dynamic polymorphism?",
                "options": [
                    "Resolved at compile time",
                    "Resolved at runtime using virtual functions",
                    "Cannot be achieved in C++",
                    "Requires operator overloading"
                ],
                "answer": 1,
                "explanation": "Dynamic polymorphism is resolved at runtime using virtual functions."
            },
            {
                "id": "OOPS037",
                "question": "Which of the following is true about static polymorphism?",
                "options": [
                    "Resolved at runtime",
                    "Resolved at compile time",
                    "Cannot be achieved in C++",
                    "Requires virtual functions"
                ],
                "answer": 1,
                "explanation": "Static polymorphism (function overloading, operator overloading) is resolved at compile time."
            },
            {
                "id": "OOPS038",
                "question": "Which of the following is true about multiple inheritance in C++?",
                "options": [
                    "Allowed for classes",
                    "Not allowed at all",
                    "Only via interfaces",
                    "Only for abstract classes"
                ],
                "answer": 0,
                "explanation": "C++ allows multiple inheritance using classes, unlike Java which allows it via interfaces only."
            },
            {
                "id": "OOPS039",
                "question": "Which of the following is true about method overriding?",
                "options": [
                    "Method signature must be same",
                    "Cannot change return type",
                    "Occurs in derived class",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Method overriding occurs in derived class with same signature and compatible return type."
            },
            {
                "id": "OOPS040",
                "question": "Which of the following is true about association in OOP?",
                "options": [
                    "Represents has-a relationship between objects",
                    "Represents is-a relationship",
                    "Represents polymorphism",
                    "Represents inheritance"
                ],
                "answer": 0,
                "explanation": "Association is a relationship between objects (has-a relationship)."
            },
            {
                "id": "OOPS041",
                "question": "Which of the following is true about aggregation?",
                "options": [
                    "Strong form of association",
                    "Represents has-a relationship where child can exist independently",
                    "Represents inheritance",
                    "Same as composition"
                ],
                "answer": 1,
                "explanation": "Aggregation is a weak form of association where the child can exist independently of parent."
            },
            {
                "id": "OOPS042",
                "question": "Which of the following is true about composition?",
                "options": [
                    "Represents has-a relationship where child cannot exist without parent",
                    "Represents is-a relationship",
                    "Represents polymorphism",
                    "Same as aggregation"
                ],
                "answer": 0,
                "explanation": "Composition is a strong association where the child cannot exist without the parent."
            },
            {
                "id": "OOPS043",
                "question": "Which of the following is true about friend function in C++?",
                "options": [
                    "Can access private and protected members of class",
                    "Cannot access class members",
                    "Must be a member function",
                    "Cannot be declared outside class"
                ],
                "answer": 0,
                "explanation": "Friend function can access private and protected members of a class even if not a member of that class."
            },
            {
                "id": "OOPS044",
                "question": "Which of the following is true about 'super' keyword in Java?",
                "options": [
                    "Refers to parent class members",
                    "Refers to current object",
                    "Refers to static members",
                    "Cannot be used in inheritance"
                ],
                "answer": 0,
                "explanation": "'super' keyword in Java is used to refer to parent class members."
            },
            {
                "id": "OOPS045",
                "question": "Which of the following is true about abstract method?",
                "options": [
                    "Has implementation",
                    "Declared without body and must be overridden",
                    "Can be called directly",
                    "Cannot be declared in abstract class"
                ],
                "answer": 1,
                "explanation": "Abstract method has no body and must be overridden in derived class."
            },
            {
                "id": "OOPS046",
                "question": "Which of the following allows hiding implementation in OOP?",
                "options": [
                    "Encapsulation",
                    "Polymorphism",
                    "Inheritance",
                    "Overloading"
                ],
                "answer": 0,
                "explanation": "Encapsulation hides the internal implementation from outside world."
            },
            {
                "id": "OOPS047",
                "question": "Which of the following is true about dynamic binding?",
                "options": [
                    "Determined at compile time",
                    "Determined at runtime",
                    "Not possible in C++",
                    "Only applies to static functions"
                ],
                "answer": 1,
                "explanation": "Dynamic binding determines the method to call at runtime, enabling polymorphism."
            },
            {
                "id": "OOPS048",
                "question": "Which of the following is true about virtual destructor in C++?",
                "options": [
                    "Ensures derived class destructor is called",
                    "Prevents inheritance",
                    "Cannot be defined",
                    "Must return integer"
                ],
                "answer": 0,
                "explanation": "Virtual destructor ensures that derived class destructors are called when deleting through a base pointer."
            },
            {
                "id": "OOPS049",
                "question": "Which of the following is true about interface vs abstract class in Java?",
                "options": [
                    "Interface methods are abstract by default",
                    "Abstract class can have concrete methods",
                    "Interface supports multiple inheritance",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "All statements are correct; interface supports multiple inheritance, abstract class can have concrete methods."
            },
            {
                "id": "OOPS050",
                "question": "Which of the following is true about method hiding in Java?",
                "options": [
                    "Static methods of base class can be hidden by static methods of derived class",
                    "Instance methods can be hidden",
                    "Cannot hide any method",
                    "Only private methods can be hidden"
                ],
                "answer": 0,
                "explanation": "Static methods can be hidden in derived class by defining a static method with same signature."
            }
        ],
        "Inheritance": [
            {
                "id": "INH001",
                "question": "Which of the following describes inheritance in OOP?",
                "options": [
                    "A class can access only its own members",
                    "A class can acquire properties and methods of another class",
                    "A class can inherit from multiple unrelated programs",
                    "Inheritance is not supported in OOP"
                ],
                "answer": 1,
                "explanation": "Inheritance allows a class (derived) to acquire properties and behaviors from another class (base)."
            },
            {
                "id": "INH002",
                "question": "Which of the following types of inheritance is allowed in Java?",
                "options": [
                    "Single inheritance",
                    "Multiple inheritance using classes",
                    "Multilevel inheritance",
                    "Both 1 and 3"
                ],
                "answer": 3,
                "explanation": "Java supports single and multilevel inheritance. Multiple inheritance with classes is not allowed."
            },
            {
                "id": "INH003",
                "question": "Which of the following allows a derived class to redefine a base class method?",
                "options": [
                    "Function overloading",
                    "Function overriding",
                    "Encapsulation",
                    "Abstraction"
                ],
                "answer": 1,
                "explanation": "Function overriding allows a derived class to provide a new implementation for a base class method."
            },
            {
                "id": "INH004",
                "question": "Which of the following is a feature of multilevel inheritance?",
                "options": [
                    "A derived class inherits from multiple base classes",
                    "Inheritance chain can have multiple levels",
                    "Base class can inherit from derived class",
                    "Not supported in Java or C++"
                ],
                "answer": 1,
                "explanation": "Multilevel inheritance occurs when a class is derived from another derived class, forming an inheritance chain."
            },
            {
                "id": "INH005",
                "question": "Which of the following is true about multiple inheritance in C++?",
                "options": [
                    "Derived class inherits from more than one base class",
                    "Not supported in C++",
                    "Only one base class is allowed",
                    "Allowed only via virtual functions"
                ],
                "answer": 0,
                "explanation": "C++ supports multiple inheritance where a derived class can inherit from multiple base classes."
            },
            {
                "id": "INH006",
                "question": "Which of the following problem may arise in multiple inheritance?",
                "options": [
                    "Diamond problem",
                    "Memory leak",
                    "Stack overflow",
                    "Segmentation fault"
                ],
                "answer": 0,
                "explanation": "Diamond problem occurs when a derived class inherits from two classes that have a common base class."
            },
            {
                "id": "INH007",
                "question": "Which of the following resolves the diamond problem in C++?",
                "options": [
                    "Virtual inheritance",
                    "Function overloading",
                    "Static binding",
                    "Operator overloading"
                ],
                "answer": 0,
                "explanation": "Virtual inheritance ensures only one copy of the base class is inherited in case of multiple inheritance."
            },
            {
                "id": "INH008",
                "question": "Which of the following access specifiers allows derived class to access base class members?",
                "options": [
                    "private",
                    "protected",
                    "default",
                    "static"
                ],
                "answer": 1,
                "explanation": "Protected members are accessible in derived classes but not outside the class hierarchy."
            },
            {
                "id": "INH009",
                "question": "Which of the following is true about single inheritance?",
                "options": [
                    "Derived class inherits from one base class",
                    "Derived class inherits from multiple base classes",
                    "Derived class cannot inherit",
                    "Base class inherits from derived class"
                ],
                "answer": 0,
                "explanation": "Single inheritance allows a class to inherit from exactly one base class."
            },
            {
                "id": "INH010",
                "question": "Which of the following is true about hierarchical inheritance?",
                "options": [
                    "Multiple base classes have a single derived class",
                    "Single base class has multiple derived classes",
                    "Derived class cannot inherit",
                    "Base class inherits from derived class"
                ],
                "answer": 1,
                "explanation": "Hierarchical inheritance occurs when multiple derived classes inherit from a single base class."
            },
            {
                "id": "INH011",
                "question": "Which of the following is true about hybrid inheritance?",
                "options": [
                    "Combination of two or more types of inheritance",
                    "Only single inheritance",
                    "Only multiple inheritance",
                    "Not allowed in C++"
                ],
                "answer": 0,
                "explanation": "Hybrid inheritance is a combination of two or more types of inheritance."
            },
            {
                "id": "INH012",
                "question": "Which of the following keywords is used to inherit a class in Java?",
                "options": [
                    "implements",
                    "extends",
                    "inherits",
                    "super"
                ],
                "answer": 1,
                "explanation": "The 'extends' keyword is used in Java to inherit from a base class."
            },
            {
                "id": "INH013",
                "question": "Which of the following is true about base class constructor execution?",
                "options": [
                    "Base class constructor is executed before derived class constructor",
                    "Derived class constructor is executed before base class constructor",
                    "Only derived class constructor executes",
                    "Base class constructor is never executed"
                ],
                "answer": 0,
                "explanation": "Base class constructor executes first to initialize base part of the object before derived class constructor runs."
            },
            {
                "id": "INH014",
                "question": "Which of the following is true about destructor execution in inheritance?",
                "options": [
                    "Derived class destructor executes first, then base class destructor",
                    "Base class destructor executes first",
                    "Only derived class destructor executes",
                    "Destructors do not execute"
                ],
                "answer": 0,
                "explanation": "Derived class destructor executes first, followed by base class destructor to properly release resources."
            },
            {
                "id": "INH015",
                "question": "Which of the following is true about protected members in inheritance?",
                "options": [
                    "Cannot be accessed by derived class",
                    "Can be accessed by derived class but not by outside world",
                    "Accessible everywhere",
                    "Only accessible in base class"
                ],
                "answer": 1,
                "explanation": "Protected members are accessible within derived classes but not from outside the class hierarchy."
            },
            {
                "id": "INH016",
                "question": "Which of the following is true about private members and inheritance?",
                "options": [
                    "Private members are inherited and accessible directly in derived class",
                    "Private members are inherited but not accessible directly",
                    "Private members cannot be inherited at all",
                    "Private members are converted to public"
                ],
                "answer": 1,
                "explanation": "Private members are inherited but cannot be accessed directly in the derived class."
            },
            {
                "id": "INH017",
                "question": "Which of the following is true about overriding in inheritance?",
                "options": [
                    "Derived class method can replace base class method",
                    "Overriding only occurs in base class",
                    "Overloading is same as overriding",
                    "Cannot occur in inheritance"
                ],
                "answer": 0,
                "explanation": "Overriding allows derived class to redefine the behavior of a base class method."
            },
            {
                "id": "INH018",
                "question": "Which of the following is true about virtual functions in C++ inheritance?",
                "options": [
                    "Enable runtime polymorphism",
                    "Cannot be overridden",
                    "Execute at compile time",
                    "Cannot be inherited"
                ],
                "answer": 0,
                "explanation": "Virtual functions allow derived class methods to be called at runtime through base class pointers, enabling dynamic polymorphism."
            },
            {
                "id": "INH019",
                "question": "Which of the following is true about interface inheritance in Java?",
                "options": [
                    "Class can implement multiple interfaces",
                    "Class can extend multiple classes",
                    "Interface cannot be inherited",
                    "Interface cannot contain abstract methods"
                ],
                "answer": 0,
                "explanation": "Java allows a class to implement multiple interfaces providing multiple inheritance of type safely."
            },
            {
                "id": "INH020",
                "question": "Which of the following is true about super keyword in Java inheritance?",
                "options": [
                    "Access base class members",
                    "Access current class members only",
                    "Access static members only",
                    "Cannot be used with inheritance"
                ],
                "answer": 0,
                "explanation": "'super' is used to refer to base class methods or variables in derived class."
            },
            {
                "id": "INH021",
                "question": "Which of the following is true about final class and inheritance?",
                "options": [
                    "Final class cannot be inherited",
                    "Final class can be inherited",
                    "Final class must be abstract",
                    "Final class has no methods"
                ],
                "answer": 0,
                "explanation": "A final class in Java cannot be inherited."
            },
            {
                "id": "INH022",
                "question": "Which of the following is true about hybrid inheritance in C++?",
                "options": [
                    "Combination of multiple inheritance types",
                    "Same as single inheritance",
                    "Not allowed in C++",
                    "Cannot be used with virtual functions"
                ],
                "answer": 0,
                "explanation": "Hybrid inheritance combines more than one type of inheritance (single, multiple, multilevel)."
            },
            {
                "id": "INH023",
                "question": "Which of the following correctly describes hierarchical inheritance?",
                "options": [
                    "Multiple base classes, single derived",
                    "Single base class, multiple derived",
                    "Derived class inherits multiple classes",
                    "Cannot occur in C++"
                ],
                "answer": 1,
                "explanation": "Hierarchical inheritance occurs when a single base class has multiple derived classes."
            },
            {
                "id": "INH024",
                "question": "Which of the following is true about constructor execution in multilevel inheritance?",
                "options": [
                    "Base class constructors executed first",
                    "Derived class constructors executed first",
                    "Only top-level constructor executes",
                    "Constructors are not called"
                ],
                "answer": 0,
                "explanation": "Constructors execute in the order of inheritance, from base to derived class."
            },
            {
                "id": "INH025",
                "question": "Which of the following is true about access specifiers and inheritance in C++?",
                "options": [
                    "Private members not accessible in derived class",
                    "Protected members accessible in derived class",
                    "Public members accessible everywhere",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "All statements are correct; access specifiers control member visibility in inheritance."
            },
            {
                "id": "INH026",
                "question": "Which of the following is true about overriding a base class method?",
                "options": [
                    "Derived class method must have same name and parameters",
                    "Derived class method can have different return type incompatible with base",
                    "Only private methods can be overridden",
                    "Overriding does not require inheritance"
                ],
                "answer": 0,
                "explanation": "Method overriding requires same method name and compatible parameters in derived class."
            },
            {
                "id": "INH027",
                "question": "Which of the following is true about abstract class inheritance?",
                "options": [
                    "Cannot be inherited",
                    "Must be inherited by derived class",
                    "Derived class must implement abstract methods",
                    "All of the above"
                ],
                "answer": 2,
                "explanation": "Derived class inheriting an abstract class must implement its abstract methods to be concrete."
            },
            {
                "id": "INH028",
                "question": "Which of the following is true about interface inheritance in Java?",
                "options": [
                    "Class can implement multiple interfaces",
                    "Interface can extend multiple interfaces",
                    "All methods are abstract by default",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "All statements are correct; interfaces allow multiple inheritance and abstract methods by default."
            },
            {
                "id": "INH029",
                "question": "Which of the following is true about 'super()' in Java?",
                "options": [
                    "Calls base class constructor",
                    "Calls derived class constructor",
                    "Calls only static members",
                    "Cannot be used in constructors"
                ],
                "answer": 0,
                "explanation": "'super()' is used to call the base class constructor from derived class."
            },
            {
                "id": "INH030",
                "question": "Which of the following is true about virtual inheritance in C++?",
                "options": [
                    "Prevents multiple copies of base class in diamond problem",
                    "Prevents derived class from accessing base class",
                    "Prevents overriding",
                    "Prevents multilevel inheritance"
                ],
                "answer": 0,
                "explanation": "Virtual inheritance ensures only one copy of the base class exists in multiple inheritance scenarios."
            },
            {
                "id": "INH031",
                "question": "Which of the following is true about polymorphic behavior in inheritance?",
                "options": [
                    "Derived class object can be referred by base class pointer",
                    "Base class object cannot be assigned to derived class pointer",
                    "Virtual functions enable runtime method selection",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Polymorphism allows base class pointers to refer to derived objects, and virtual functions enable runtime selection."
            },
            {
                "id": "INH032",
                "question": "Which of the following is true about multiple inheritance in Java?",
                "options": [
                    "Allowed with classes",
                    "Allowed with interfaces",
                    "Not allowed at all",
                    "Allowed with abstract classes only"
                ],
                "answer": 1,
                "explanation": "Java allows multiple inheritance only with interfaces, not with classes."
            },
            {
                "id": "INH033",
                "question": "Which of the following is true about multilevel inheritance?",
                "options": [
                    "Derived class inherits indirectly from base class",
                    "Base class inherits from derived class",
                    "Cannot be used with abstract classes",
                    "Cannot be used with interfaces"
                ],
                "answer": 0,
                "explanation": "In multilevel inheritance, a derived class inherits from a class which is itself derived from another class."
            },
            {
                "id": "INH034",
                "question": "Which of the following is true about hierarchical inheritance?",
                "options": [
                    "Multiple base classes inherit from single derived class",
                    "Single base class has multiple derived classes",
                    "Derived class cannot inherit",
                    "Cannot be implemented in Java"
                ],
                "answer": 1,
                "explanation": "Hierarchical inheritance occurs when one base class has multiple derived classes."
            },
            {
                "id": "INH035",
                "question": "Which of the following is true about access of base class constructors in derived class?",
                "options": [
                    "Private base class constructor cannot be accessed",
                    "Protected base class constructor can be accessed",
                    "Public base class constructor can be accessed",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Private constructors are inaccessible, protected constructors are accessible in derived classes, public constructors are accessible everywhere."
            },
            {
                "id": "INH036",
                "question": "Which of the following is true about constructor chaining in inheritance?",
                "options": [
                    "Derived class constructor calls base class constructor",
                    "Base class constructor calls derived class constructor",
                    "Only default constructor can be chained",
                    "Constructor chaining is not allowed"
                ],
                "answer": 0,
                "explanation": "Constructor chaining occurs when derived class constructor calls base class constructor to initialize inherited members."
            },
            {
                "id": "INH037",
                "question": "Which of the following is true about destructor in inheritance?",
                "options": [
                    "Derived class destructor executes first",
                    "Base class destructor executes first",
                    "Only base destructor executes",
                    "Only derived destructor executes"
                ],
                "answer": 0,
                "explanation": "In C++ inheritance, derived class destructor executes first followed by base class destructor."
            },
            {
                "id": "INH038",
                "question": "Which of the following is true about private members and inheritance?",
                "options": [
                    "Private members are not accessible in derived class",
                    "Private members are inherited and accessible",
                    "Private members are converted to protected",
                    "Private members are converted to public"
                ],
                "answer": 0,
                "explanation": "Private members are inherited but cannot be accessed directly in derived class."
            },
            {
                "id": "INH039",
                "question": "Which of the following is true about protected members and inheritance?",
                "options": [
                    "Accessible only in base class",
                    "Accessible in derived classes",
                    "Accessible outside class",
                    "Cannot be inherited"
                ],
                "answer": 1,
                "explanation": "Protected members are accessible within derived classes but not outside the class hierarchy."
            },
            {
                "id": "INH040",
                "question": "Which of the following is true about overriding and access specifiers?",
                "options": [
                    "Derived method cannot reduce visibility of base method",
                    "Derived method can reduce visibility",
                    "Overriding ignores access specifiers",
                    "Access specifiers do not affect inheritance"
                ],
                "answer": 0,
                "explanation": "When overriding, derived class method cannot have lower visibility than base class method."
            },
            {
                "id": "INH041",
                "question": "Which of the following is true about abstract base class and inheritance?",
                "options": [
                    "Abstract base class can have concrete and abstract methods",
                    "Derived class must implement abstract methods",
                    "Cannot instantiate abstract base class",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "All statements are correct regarding abstract base class and inheritance."
            },
            {
                "id": "INH042",
                "question": "Which of the following describes interface inheritance in Java?",
                "options": [
                    "Derived class can implement multiple interfaces",
                    "Interfaces cannot extend other interfaces",
                    "Derived class cannot implement interface",
                    "Interface members are private by default"
                ],
                "answer": 0,
                "explanation": "Java allows a class to implement multiple interfaces, supporting multiple inheritance of type."
            },
            {
                "id": "INH043",
                "question": "Which of the following is true about super keyword in Java inheritance?",
                "options": [
                    "Access base class members",
                    "Call base class constructor",
                    "Can be used to override methods",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "'super' keyword can be used to access base members and call base constructor."
            },
            {
                "id": "INH044",
                "question": "Which of the following is true about virtual inheritance in C++?",
                "options": [
                    "Prevents multiple copies of base class",
                    "Enables dynamic memory allocation",
                    "Allows private inheritance only",
                    "Prevents destructor calls"
                ],
                "answer": 0,
                "explanation": "Virtual inheritance ensures only one base class copy exists in multiple inheritance scenarios."
            },
            {
                "id": "INH045",
                "question": "Which of the following is true about polymorphic base class pointer?",
                "options": [
                    "Can point to derived class object",
                    "Cannot point to derived class",
                    "Can only point to base class",
                    "Cannot point to any object"
                ],
                "answer": 0,
                "explanation": "Base class pointer can point to derived class object enabling runtime polymorphism."
            },
            {
                "id": "INH046",
                "question": "Which of the following is true about method hiding in Java?",
                "options": [
                    "Static method in base class can be hidden by static method in derived class",
                    "Instance method can be hidden",
                    "Overridden method is hidden automatically",
                    "Cannot hide methods in Java"
                ],
                "answer": 0,
                "explanation": "Static methods can be hidden in derived class by another static method with same signature."
            },
            {
                "id": "INH047",
                "question": "Which of the following is true about diamond problem in C++?",
                "options": [
                    "Occurs in multiple inheritance",
                    "Resolved using virtual inheritance",
                    "Base class is inherited multiple times",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "All statements are correct; diamond problem arises in multiple inheritance and is resolved using virtual inheritance."
            },
            {
                "id": "INH048",
                "question": "Which of the following is true about dynamic binding in inheritance?",
                "options": [
                    "Determines method to call at runtime",
                    "Determines method to call at compile time",
                    "Static members use dynamic binding",
                    "Constructors use dynamic binding"
                ],
                "answer": 0,
                "explanation": "Dynamic binding determines which method to call at runtime for polymorphic behavior."
            },
            {
                "id": "INH049",
                "question": "Which of the following is true about hybrid inheritance?",
                "options": [
                    "Combination of single, multiple, and multilevel inheritance",
                    "Cannot be used in C++",
                    "Only allowed in Java",
                    "Does not support virtual functions"
                ],
                "answer": 0,
                "explanation": "Hybrid inheritance combines different types of inheritance to form complex hierarchies."
            },
            {
                "id": "INH050",
                "question": "Which of the following is true about constructor in derived class?",
                "options": [
                    "Derived constructor must call base class constructor",
                    "Derived constructor cannot call base constructor",
                    "Base constructor is ignored",
                    "Only default constructor is called"
                ],
                "answer": 0,
                "explanation": "Derived class constructor calls base class constructor to initialize inherited members properly."
            }
        ],
        "Class & Object": [
            {
                "id": "CO001",
                "question": "Which of the following defines a class in C++?",
                "options": [
                    "class ClassName { /* members */ };",
                    "Class ClassName { /* members */ };",
                    "class ClassName();",
                    "def ClassName { }"
                ],
                "answer": 0,
                "explanation": "In C++, a class is defined using 'class ClassName { /* members */ };'."
            },
            {
                "id": "CO002",
                "question": "Which of the following correctly creates an object in C++?",
                "options": [
                    "ClassName obj;",
                    "obj = new ClassName();",
                    "ClassName obj = ClassName();",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "All mentioned syntaxes can create objects in C++."
            },
            {
                "id": "CO003",
                "question": "Which of the following is true about object in OOP?",
                "options": [
                    "Instance of a class",
                    "Stores data and behavior",
                    "Created at runtime",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "An object is an instance of a class, storing data (attributes) and behavior (methods)."
            },
            {
                "id": "CO004",
                "question": "Which of the following defines member function in a class?",
                "options": [
                    "Function declared inside class",
                    "Function declared outside class",
                    "Global function",
                    "Static function only"
                ],
                "answer": 0,
                "explanation": "A member function is declared inside a class and operates on its data members."
            },
            {
                "id": "CO005",
                "question": "Which of the following is true about object memory allocation in C++?",
                "options": [
                    "Static objects allocated on stack",
                    "Dynamic objects allocated on heap",
                    "Objects can have both stack and heap allocation",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Objects can be allocated statically (stack) or dynamically (heap) depending on declaration."
            },
            {
                "id": "CO006",
                "question": "Which of the following is true about 'this' pointer in C++?",
                "options": [
                    "Refers to current object",
                    "Refers to base class object",
                    "Refers to static members",
                    "Cannot be used in member function"
                ],
                "answer": 0,
                "explanation": "'this' pointer refers to the current instance of the class calling the member function."
            },
            {
                "id": "CO007",
                "question": "Which of the following is true about encapsulation?",
                "options": [
                    "Bundling data and methods together",
                    "Hides internal state using access specifiers",
                    "Enhances security",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Encapsulation combines data and methods and controls access using access specifiers."
            },
            {
                "id": "CO008",
                "question": "Which of the following is correct syntax for defining a class constructor in C++?",
                "options": [
                    "ClassName();",
                    "void ClassName();",
                    "ClassName(void);",
                    "All constructors must return int"
                ],
                "answer": 0,
                "explanation": "A constructor has the same name as the class and no return type."
            },
            {
                "id": "CO009",
                "question": "Which of the following is true about default constructor?",
                "options": [
                    "Takes no parameters",
                    "Automatically provided by compiler if none defined",
                    "Can be explicitly defined",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Default constructor takes no parameters and can be compiler-generated or user-defined."
            },
            {
                "id": "CO010",
                "question": "Which of the following is true about parameterized constructor?",
                "options": [
                    "Takes arguments to initialize objects",
                    "Can be overloaded",
                    "Used for specific initialization",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Parameterized constructors take arguments and can be overloaded for different initializations."
            },
            {
                "id": "CO011",
                "question": "Which of the following is true about copy constructor in C++?",
                "options": [
                    "Initializes object using another object of same class",
                    "Shallow copy by default",
                    "Can be overloaded",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Copy constructor creates a new object as a copy of existing object; default is shallow copy."
            },
            {
                "id": "CO012",
                "question": "Which of the following is true about destructor in C++?",
                "options": [
                    "Has same name as class with ~ prefix",
                    "No return type and no parameters",
                    "Called automatically when object goes out of scope",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Destructor cleans up resources; defined as ~ClassName() with no parameters or return type."
            },
            {
                "id": "CO013",
                "question": "Which of the following is true about object creation in Java?",
                "options": [
                    "Using new keyword",
                    "Reference variable stores object address",
                    "Garbage collected automatically",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "In Java, objects are created using 'new', references store addresses, and garbage collector frees memory."
            },
            {
                "id": "CO014",
                "question": "Which of the following is true about static member variables?",
                "options": [
                    "Shared among all objects",
                    "Belongs to class, not object",
                    "Can be accessed using class name",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Static members are shared across all objects and belong to the class itself."
            },
            {
                "id": "CO015",
                "question": "Which of the following is true about static member functions?",
                "options": [
                    "Cannot access non-static members directly",
                    "Can be called using class name",
                    "Shared among all objects",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Static functions belong to class, cannot access instance members directly, and are shared among all objects."
            },
            {
                "id": "CO016",
                "question": "Which of the following is true about friend function in C++?",
                "options": [
                    "Can access private and protected members",
                    "Not a member of class",
                    "Declared using friend keyword",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Friend functions are not members but can access private/protected members of the class."
            },
            {
                "id": "CO017",
                "question": "Which of the following is true about object reference in Java?",
                "options": [
                    "Reference stores memory address of object",
                    "Reference can be null",
                    "Garbage collector reclaims object when no reference exists",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Java references store addresses; unreferenced objects are garbage collected."
            },
            {
                "id": "CO018",
                "question": "Which of the following is true about 'new' operator in C++?",
                "options": [
                    "Allocates memory on heap",
                    "Returns pointer to object",
                    "Must be paired with delete to free memory",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "'new' allocates dynamic memory and returns pointer; 'delete' frees memory."
            },
            {
                "id": "CO019",
                "question": "Which of the following is true about 'delete' operator in C++?",
                "options": [
                    "Frees memory allocated by new",
                    "Calls destructor for object",
                    "Prevents memory leak",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "'delete' frees dynamically allocated memory and calls the object's destructor."
            },
            {
                "id": "CO020",
                "question": "Which of the following is true about default object initialization?",
                "options": [
                    "Static objects initialized to zero",
                    "Local objects not initialized automatically",
                    "Dynamic objects require constructor",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Default initialization depends on storage type; static objects zero-initialized, local uninitialized, dynamic uses constructor."
            },
            {
                "id": "CO021",
                "question": "Which of the following is true about object copying in C++?",
                "options": [
                    "Assignment operator performs shallow copy by default",
                    "Copy constructor used to initialize new object",
                    "Deep copy requires custom implementation",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "C++ copies objects using default shallow copy; deep copy requires user-defined logic."
            },
            {
                "id": "CO022",
                "question": "Which of the following is true about object arrays in C++?",
                "options": [
                    "Can store multiple objects of same class",
                    "Each object calls constructor",
                    "Destructors called in reverse order",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Object arrays call constructors for each element; destructors called in reverse order."
            },
            {
                "id": "CO023",
                "question": "Which of the following is true about reference vs pointer in C++?",
                "options": [
                    "Reference must be initialized",
                    "Pointer can be null",
                    "Reference cannot be reseated",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "References are bound to object at initialization; pointers can be null and reseated."
            },
            {
                "id": "CO024",
                "question": "Which of the following is true about const objects?",
                "options": [
                    "Cannot modify members",
                    "Can call const member functions",
                    "Useful for safety",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Const objects cannot modify data but can call const-qualified member functions."
            },
            {
                "id": "CO025",
                "question": "Which of the following is true about access specifiers in C++ class?",
                "options": [
                    "Private members accessible only within class",
                    "Protected members accessible in derived class",
                    "Public members accessible everywhere",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Access specifiers control visibility; private, protected, and public behave accordingly."
            },
            {
                "id": "CO026",
                "question": "Which of the following is true about constructor overloading?",
                "options": [
                    "Multiple constructors with different parameters",
                    "Allows different initialization styles",
                    "Compiler selects constructor based on arguments",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Constructor overloading lets a class have multiple constructors with different parameter lists."
            },
            {
                "id": "CO027",
                "question": "Which of the following is true about destructor overloading?",
                "options": [
                    "Destructors cannot be overloaded",
                    "Destructors can take parameters",
                    "Multiple destructors allowed",
                    "Destructor must return int"
                ],
                "answer": 0,
                "explanation": "C++ allows only one destructor per class; destructors cannot be overloaded."
            },
            {
                "id": "CO028",
                "question": "Which of the following is true about member initializer list in C++?",
                "options": [
                    "Used to initialize members before constructor body",
                    "Efficient for constant and reference members",
                    "Syntax: ClassName() : member(value) {}",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Member initializer lists allow efficient initialization of members before executing constructor body."
            },
            {
                "id": "CO029",
                "question": "Which of the following is true about dynamic object creation in C++?",
                "options": [
                    "Allocated using new keyword",
                    "Stored on heap",
                    "Must be deleted to avoid memory leak",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Dynamic objects use heap memory and must be manually freed using delete."
            },
            {
                "id": "CO030",
                "question": "Which of the following is true about object assignment in C++?",
                "options": [
                    "Performs shallow copy by default",
                    "Can be customized with operator=",
                    "Copies member values to target object",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Assignment copies member values by default (shallow) and can be customized using assignment operator."
            },
            {
                "id": "CO031",
                "question": "Which of the following is true about object slicing?",
                "options": [
                    "Occurs when derived object assigned to base object",
                    "Derived-specific members are lost",
                    "Common in value-based assignment",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Object slicing happens when a derived object is assigned to a base object, losing derived-specific data."
            },
            {
                "id": "CO032",
                "question": "Which of the following is true about friend class in C++?",
                "options": [
                    "Can access private/protected members of another class",
                    "Declared using friend keyword",
                    "Not a member of the class",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Friend classes can access private/protected members and are declared using friend keyword but are not class members."
            },
            {
                "id": "CO033",
                "question": "Which of the following is true about nested class?",
                "options": [
                    "Class defined inside another class",
                    "Can access private members of outer class",
                    "Helps in encapsulation",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Nested classes are defined within another class and can access private members of outer class."
            },
            {
                "id": "CO034",
                "question": "Which of the following is true about constant member function in C++?",
                "options": [
                    "Cannot modify object data members",
                    "Can be called by const objects",
                    "Declared with const keyword after parameter list",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Const member functions do not modify object state and can be invoked by const objects."
            },
            {
                "id": "CO035",
                "question": "Which of the following is true about virtual functions in class?",
                "options": [
                    "Supports runtime polymorphism",
                    "Declared using virtual keyword",
                    "Called through base class pointer",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Virtual functions allow derived class methods to be called at runtime through base class pointers."
            },
            {
                "id": "CO036",
                "question": "Which of the following is true about abstract class in C++?",
                "options": [
                    "Contains at least one pure virtual function",
                    "Cannot instantiate objects directly",
                    "Used as base class for polymorphism",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Abstract class cannot be instantiated and typically contains pure virtual functions."
            },
            {
                "id": "CO037",
                "question": "Which of the following is true about class template in C++?",
                "options": [
                    "Allows generic programming",
                    "Syntax: template<class T> class ClassName {}",
                    "Can create objects with different data types",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Class templates enable generic programming and allow creating objects with various data types."
            },
            {
                "id": "CO038",
                "question": "Which of the following is true about object lifetime?",
                "options": [
                    "Stack object destroyed at scope exit",
                    "Heap object destroyed using delete",
                    "Global object exists until program termination",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Object lifetime depends on storage type: stack, heap, or global."
            },
            {
                "id": "CO039",
                "question": "Which of the following is true about aggregation in classes?",
                "options": [
                    "Class contains object of another class",
                    "Represents has-a relationship",
                    "Lifetime of contained object independent",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Aggregation represents a has-a relationship where contained object's lifetime is independent of container."
            },
            {
                "id": "CO040",
                "question": "Which of the following is true about composition in classes?",
                "options": [
                    "Class contains object of another class",
                    "Represents has-a relationship",
                    "Lifetime of contained object dependent on container",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Composition is a strong form of aggregation where contained object's lifetime depends on the container."
            },
            {
                "id": "CO041",
                "question": "Which of the following is true about multiple objects of a class?",
                "options": [
                    "Each object has its own copy of non-static members",
                    "Static members are shared among all objects",
                    "Objects can be created on stack or heap",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Each object has its own data except static members, which are shared; objects can be stack or heap allocated."
            },
            {
                "id": "CO042",
                "question": "Which of the following is true about inline member functions?",
                "options": [
                    "Suggested to compiler for inline expansion",
                    "Declared using inline keyword",
                    "Reduces function call overhead",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Inline functions reduce call overhead; compiler may or may not expand them inline."
            },
            {
                "id": "CO043",
                "question": "Which of the following is true about class access specifiers?",
                "options": [
                    "Default in C++ class is private",
                    "Default in struct is public",
                    "Controls visibility to outside world",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Access specifiers control visibility; class defaults to private, struct defaults to public."
            },
            {
                "id": "CO044",
                "question": "Which of the following is true about abstract base class in C++?",
                "options": [
                    "Can contain pure virtual and normal functions",
                    "Cannot be instantiated",
                    "Used to enforce derived class behavior",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Abstract base class contains pure virtual functions and cannot be instantiated."
            },
            {
                "id": "CO045",
                "question": "Which of the following is true about object reference in C++?",
                "options": [
                    "Must be initialized at declaration",
                    "Cannot be null",
                    "Acts as alias for object",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "C++ references must be initialized and act as alias for existing objects."
            },
            {
                "id": "CO046",
                "question": "Which of the following is true about static object in C++?",
                "options": [
                    "Exists throughout program lifetime",
                    "Initialized only once",
                    "Accessible globally if public",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Static objects have program lifetime, initialized once, and accessible according to visibility."
            },
            {
                "id": "CO047",
                "question": "Which of the following is true about object composition vs inheritance?",
                "options": [
                    "Composition uses has-a relationship",
                    "Inheritance uses is-a relationship",
                    "Composition preferred for flexibility",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Composition and inheritance represent has-a and is-a relationships, respectively; composition increases flexibility."
            },
            {
                "id": "CO048",
                "question": "Which of the following is true about object initialization order?",
                "options": [
                    "Base class initialized first",
                    "Member objects initialized in declaration order",
                    "Derived class constructor executes after base",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Initialization order: base class first, then member objects in order, then derived constructor."
            },
            {
                "id": "CO049",
                "question": "Which of the following is true about object method invocation?",
                "options": [
                    "Member function called using object name",
                    "Can access private/protected members if within class",
                    "Static member function can be called using class name",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Member functions invoked using object; static functions via class name; private/protected rules apply."
            },
            {
                "id": "CO050",
                "question": "Which of the following is true about object lifetime and scope?",
                "options": [
                    "Stack object destroyed at end of scope",
                    "Heap object exists until delete",
                    "Global/static object exists till program ends",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Object lifetime depends on storage type: stack, heap, or static/global."
            }
        ],
        "Constructors": [
            {
                "id": "CON001",
                "question": "Which of the following is true about a constructor in C++?",
                "options": [
                    "Has same name as the class",
                    "Has no return type",
                    "Automatically called when object is created",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Constructors have the same name as the class, no return type, and are invoked automatically when an object is created."
            },
            {
                "id": "CON002",
                "question": "Which of the following correctly declares a default constructor?",
                "options": [
                    "ClassName();",
                    "void ClassName();",
                    "ClassName(void);",
                    "int ClassName();"
                ],
                "answer": 0,
                "explanation": "A default constructor has the same name as the class and no parameters or return type."
            },
            {
                "id": "CON003",
                "question": "Which of the following is true about parameterized constructors?",
                "options": [
                    "Accepts arguments to initialize object",
                    "Can be overloaded",
                    "Used for specific initialization",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Parameterized constructors take arguments and can be overloaded for different types of initialization."
            },
            {
                "id": "CON004",
                "question": "Which of the following is true about copy constructor in C++?",
                "options": [
                    "Initializes new object using existing object",
                    "Default performs shallow copy",
                    "Can be overloaded",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Copy constructor initializes a new object from an existing one; default is shallow copy; overloading is allowed."
            },
            {
                "id": "CON005",
                "question": "Which of the following is true about constructor overloading?",
                "options": [
                    "Multiple constructors in class with different parameters",
                    "Compiler chooses constructor based on arguments",
                    "Helps in flexible initialization",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Constructor overloading allows multiple constructors with different parameters for flexible object initialization."
            },
            {
                "id": "CON006",
                "question": "Which of the following is true about a destructor?",
                "options": [
                    "Has same name as class with ~ prefix",
                    "No return type and no parameters",
                    "Called automatically when object goes out of scope",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Destructor cleans up resources; ~ClassName() with no parameters or return type, called automatically at scope exit."
            },
            {
                "id": "CON007",
                "question": "Which of the following is true about constructor chaining?",
                "options": [
                    "One constructor calls another constructor of same class",
                    "Occurs only in derived classes",
                    "Cannot be done in C++",
                    "Requires new keyword"
                ],
                "answer": 0,
                "explanation": "Constructor chaining allows one constructor to call another in the same class using initializer list or 'this()' in Java."
            },
            {
                "id": "CON008",
                "question": "Which of the following is true about 'this' pointer in constructors?",
                "options": [
                    "Refers to the current object being constructed",
                    "Cannot be used in constructors",
                    "Refers to static members",
                    "Only used in Java, not C++"
                ],
                "answer": 0,
                "explanation": "'this' pointer refers to the current object during construction and can be used to access members or pass object reference."
            },
            {
                "id": "CON009",
                "question": "Which of the following is true about explicit constructor?",
                "options": [
                    "Declared using explicit keyword in C++",
                    "Prevents implicit type conversion",
                    "Used for single argument constructors",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Explicit keyword prevents compiler from using single argument constructors for implicit conversions."
            },
            {
                "id": "CON010",
                "question": "Which of the following is true about default constructor provided by compiler?",
                "options": [
                    "Provided only if no user-defined constructor exists",
                    "Initializes members to default values",
                    "Used to create objects without arguments",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Compiler provides a default constructor only if none is defined; it initializes members and allows default object creation."
            },
            {
                "id": "CON011",
                "question": "Which of the following is true about constructor in Java?",
                "options": [
                    "Has same name as class",
                    "No return type",
                    "Automatically invoked when object is created",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Java constructors are named same as class, have no return type, and invoked automatically on object creation."
            },
            {
                "id": "CON012",
                "question": "Which of the following is true about super() in Java constructor?",
                "options": [
                    "Calls parent class constructor",
                    "Must be first statement in constructor",
                    "Used for constructor chaining in inheritance",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "super() calls the parent class constructor and must be the first statement in derived class constructor."
            },
            {
                "id": "CON013",
                "question": "Which of the following is true about constructor in derived class?",
                "options": [
                    "Base class constructor is called before derived",
                    "Derived constructor executes after base",
                    "Used to initialize inherited members",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Constructor order: base class constructor runs first, then derived constructor initializes its members."
            },
            {
                "id": "CON014",
                "question": "Which of the following is true about virtual constructor in C++?",
                "options": [
                    "C++ does not support virtual constructors",
                    "Used to create objects polymorphically",
                    "Implemented using factory functions",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "C++ lacks virtual constructors; polymorphic creation is achieved via factory methods."
            },
            {
                "id": "CON015",
                "question": "Which of the following is true about constructor for const object?",
                "options": [
                    "Can initialize const members",
                    "Cannot modify after initialization",
                    "Must be used for reference members",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Constructors are used to initialize const and reference members since they cannot be assigned later."
            },
            {
                "id": "CON016",
                "question": "Which of the following is true about constructor for reference members?",
                "options": [
                    "Must be initialized in initializer list",
                    "Cannot be left uninitialized",
                    "Cannot be assigned in constructor body",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Reference members must be initialized in initializer list; cannot be assigned in body."
            },
            {
                "id": "CON017",
                "question": "Which of the following is true about order of constructor execution in multiple inheritance in C++?",
                "options": [
                    "Base class constructors executed first",
                    "Order depends on inheritance declaration",
                    "Derived class constructor executes last",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "In multiple inheritance, base class constructors run first in order declared; derived constructor runs last."
            },
            {
                "id": "CON018",
                "question": "Which of the following is true about explicit constructor in Java?",
                "options": [
                    "No explicit keyword in Java",
                    "Single argument constructor is implicit",
                    "Constructor overloading allowed",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Java does not have explicit keyword; overloading constructors is allowed."
            },
            {
                "id": "CON019",
                "question": "Which of the following is true about constructor in abstract class in Java?",
                "options": [
                    "Can have constructor",
                    "Called when derived class object created",
                    "Used to initialize abstract class members",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Abstract classes can have constructors; they are called during derived object creation."
            },
            {
                "id": "CON020",
                "question": "Which of the following is true about constructor in interface in Java?",
                "options": [
                    "Interfaces cannot have constructors",
                    "Used to initialize static members only",
                    "Can be called using implementing class",
                    "All of the above"
                ],
                "answer": 0,
                "explanation": "Interfaces cannot have constructors as they cannot be instantiated directly."
            },
            {
                "id": "CON021",
                "question": "Which of the following is true about default constructor in Java?",
                "options": [
                    "Provided by compiler if none defined",
                    "Initializes members to default values",
                    "No arguments",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Compiler provides default constructor when none is defined; it initializes members with default values."
            },
            {
                "id": "CON022",
                "question": "Which of the following is true about constructor overloading in Java?",
                "options": [
                    "Multiple constructors with different parameters",
                    "Compiler selects based on arguments",
                    "Helps flexible object creation",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Constructor overloading in Java allows multiple constructors; selection is based on arguments passed."
            },
            {
                "id": "CON023",
                "question": "Which of the following is true about calling one constructor from another in Java?",
                "options": [
                    "Use this() keyword",
                    "Must be first statement",
                    "Allows constructor chaining",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Java uses this() to call another constructor in same class; must be first statement."
            },
            {
                "id": "CON024",
                "question": "Which of the following is true about private constructors?",
                "options": [
                    "Cannot be used to create object from outside",
                    "Used in singleton design pattern",
                    "Can be called within class only",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Private constructors restrict object creation to within class; commonly used for singleton pattern."
            },
            {
                "id": "CON025",
                "question": "Which of the following is true about constructor and inheritance in C++?",
                "options": [
                    "Base class constructor executes first",
                    "Derived constructor executes after base",
                    "Constructor of derived class can call base using initializer list",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "In C++ inheritance, base constructor executes first; derived constructor may call base explicitly using initializer list."
            },
            {
                "id": "CON026",
                "question": "Which of the following is true about constructor in multiple inheritance in C++?",
                "options": [
                    "Base class constructors execute in order of inheritance declaration",
                    "Derived constructor executes after all base constructors",
                    "Used to initialize all inherited members",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "In multiple inheritance, base constructors execute in the order declared, then derived constructor initializes its members."
            },
            {
                "id": "CON027",
                "question": "Which of the following is true about constructor with static members?",
                "options": [
                    "Static members initialized only once",
                    "All objects share static members",
                    "Constructor can initialize static members",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Static members are shared across objects and can be initialized by constructors or static initializer."
            },
            {
                "id": "CON028",
                "question": "Which of the following is true about dynamic object creation in C++ with constructors?",
                "options": [
                    "Memory allocated using new keyword",
                    "Constructor called automatically",
                    "Must delete object to free memory",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Dynamic objects are created with new; constructor is invoked; delete is used to free memory."
            },
            {
                "id": "CON029",
                "question": "Which of the following is true about copy constructor with dynamic memory?",
                "options": [
                    "Default copy constructor performs shallow copy",
                    "Deep copy requires user-defined copy constructor",
                    "Used to avoid shared pointer issues",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Dynamic memory requires deep copy; default shallow copy may cause shared pointer problems."
            },
            {
                "id": "CON030",
                "question": "Which of the following is true about delegating constructor in C++11?",
                "options": [
                    "One constructor can call another in same class",
                    "Helps avoid code duplication",
                    "Uses initializer list syntax",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Delegating constructors call other constructors in same class to avoid repeating initialization code."
            },
            {
                "id": "CON031",
                "question": "Which of the following is true about explicit constructors in C++?",
                "options": [
                    "Prevents implicit type conversion",
                    "Useful for single argument constructors",
                    "Declared using explicit keyword",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Explicit prevents compiler from using single argument constructors for implicit conversions."
            },
            {
                "id": "CON032",
                "question": "Which of the following is true about constructor in abstract class in C++?",
                "options": [
                    "Abstract class can have constructor",
                    "Constructor called when derived object is created",
                    "Used to initialize base class members",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Abstract classes can have constructors; invoked during derived object creation to initialize base members."
            },
            {
                "id": "CON033",
                "question": "Which of the following is true about constructor and const object?",
                "options": [
                    "Const members must be initialized in constructor",
                    "Constructor cannot modify const member afterward",
                    "Initializer list is required for const members",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Const members cannot be assigned later; constructor uses initializer list to initialize them."
            },
            {
                "id": "CON034",
                "question": "Which of the following is true about constructor and reference members?",
                "options": [
                    "Reference members must be initialized in initializer list",
                    "Cannot assign in constructor body",
                    "Ensures reference is bound at creation",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "References must be initialized in constructor initializer list; cannot be reassigned later."
            },
            {
                "id": "CON035",
                "question": "Which of the following is true about constructor and virtual functions?",
                "options": [
                    "Virtual functions called inside constructor call base version",
                    "Derived version not called during base constructor",
                    "Avoid calling virtual functions in constructor",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "During base class constructor, virtual function calls resolve to base version; derived version not called."
            },
            {
                "id": "CON036",
                "question": "Which of the following is true about constructor in singleton pattern?",
                "options": [
                    "Constructor is private",
                    "Controls single instance creation",
                    "Accessed through static method",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Singleton pattern uses private constructor to prevent multiple instances and provides static method for access."
            },
            {
                "id": "CON037",
                "question": "Which of the following is true about base and derived constructor in Java?",
                "options": [
                    "Base class constructor called using super()",
                    "Must be first statement in derived constructor",
                    "Initializes inherited members",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Java uses super() in derived constructor to call base constructor; must be first statement."
            },
            {
                "id": "CON038",
                "question": "Which of the following is true about constructor and exception handling in C++?",
                "options": [
                    "Constructor can throw exceptions",
                    "Destructor may need to handle partial construction",
                    "Avoid resource leak with RAII",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Constructors can throw exceptions; destructors and RAII ensure resources are released if construction fails."
            },
            {
                "id": "CON039",
                "question": "Which of the following is true about constructor and inheritance in Java?",
                "options": [
                    "Derived class constructor calls base class constructor",
                    "super() used explicitly or implicitly",
                    "Initializes inherited members",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Java automatically calls base constructor first; can use super() explicitly for base initialization."
            },
            {
                "id": "CON040",
                "question": "Which of the following is true about constructor and default arguments?",
                "options": [
                    "Constructor can have default arguments",
                    "Allows flexible object creation",
                    "Overloading may conflict with default arguments",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Default arguments in constructors allow flexible creation; conflicts may arise with overloaded constructors."
            },
            {
                "id": "CON041",
                "question": "Which of the following is true about constructor and inline function?",
                "options": [
                    "Constructors can be inline",
                    "Suggested to reduce call overhead",
                    "Used mainly for small constructors",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Small constructors can be defined inline to reduce function call overhead."
            },
            {
                "id": "CON042",
                "question": "Which of the following is true about delegating constructor in Java?",
                "options": [
                    "Use this() to call another constructor",
                    "Must be first statement",
                    "Helps reduce duplicate code",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Java allows constructor chaining within same class using this(), must be first statement."
            },
            {
                "id": "CON043",
                "question": "Which of the following is true about constructor in final class in Java?",
                "options": [
                    "Constructor works normally",
                    "Class cannot be inherited",
                    "Used to create objects of final class",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Final class cannot be subclassed, but constructors work to create its objects."
            },
            {
                "id": "CON044",
                "question": "Which of the following is true about private constructor in Java?",
                "options": [
                    "Cannot instantiate from outside class",
                    "Useful for factory methods",
                    "Used in singleton pattern",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Private constructors restrict instantiation; used in singleton and factory patterns."
            },
            {
                "id": "CON045",
                "question": "Which of the following is true about object creation and constructor in C++?",
                "options": [
                    "Constructor called automatically during object creation",
                    "For dynamic objects, constructor called by new",
                    "Ensures proper initialization of object",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Constructors are automatically invoked during stack or heap object creation to initialize members."
            },
            {
                "id": "CON046",
                "question": "Which of the following is true about constructor in nested class?",
                "options": [
                    "Can have constructor like any class",
                    "Initialized when nested object created",
                    "Access rules same as normal classes",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Nested classes can have constructors; they are invoked when nested objects are created."
            },
            {
                "id": "CON047",
                "question": "Which of the following is true about constructor in anonymous class in Java?",
                "options": [
                    "Cannot have explicit constructor",
                    "Initialized using instance initializer block",
                    "Used to initialize anonymous class object",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Anonymous classes cannot define explicit constructors; instance initializer blocks are used instead."
            },
            {
                "id": "CON048",
                "question": "Which of the following is true about constructor and exception safety?",
                "options": [
                    "Constructor must ensure resource cleanup if exception thrown",
                    "Use RAII to handle resources",
                    "Partial constructed objects must not leak resources",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Constructors should ensure exception safety by releasing allocated resources using RAII or similar techniques."
            },
            {
                "id": "CON049",
                "question": "Which of the following is true about constructor in struct in C++?",
                "options": [
                    "Struct can have constructors",
                    "Can be parameterized or default",
                    "Same rules as class constructors",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "C++ structs can have constructors similar to classes, including default and parameterized constructors."
            },
            {
                "id": "CON050",
                "question": "Which of the following is true about inline constructor in C++?",
                "options": [
                    "Suggested for very small constructors",
                    "Defined inside class body",
                    "May reduce function call overhead",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Inline constructors defined inside class body are suggested for small constructors to reduce overhead."
            }
        ],
        "Functions": [
            {
                "id": "FUN001",
                "question": "Which of the following is true about a function in C/C++?",
                "options": [
                    "Has a name and a body",
                    "Can accept parameters",
                    "May return a value",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Functions have a name, optional parameters, and may return a value to the caller."
            },
            {
                "id": "FUN002",
                "question": "Which of the following correctly defines a function with no return value in C++?",
                "options": [
                    "void func();",
                    "int func();",
                    "func() {}",
                    "return func();"
                ],
                "answer": 0,
                "explanation": "void keyword indicates the function does not return a value."
            },
            {
                "id": "FUN003",
                "question": "Which of the following is true about function overloading in C++?",
                "options": [
                    "Functions with same name but different parameters",
                    "Return type can be same or different",
                    "Compiler selects function based on arguments",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Function overloading allows multiple functions with same name but different parameter types/counts; compiler resolves call."
            },
            {
                "id": "FUN004",
                "question": "Which of the following is true about inline functions?",
                "options": [
                    "Suggested for small functions",
                    "Reduces function call overhead",
                    "Declared using inline keyword",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Inline functions reduce call overhead and are suggested for small functions; compiler may choose to inline."
            },
            {
                "id": "FUN005",
                "question": "Which of the following is true about recursive functions?",
                "options": [
                    "Function calls itself",
                    "Requires base case",
                    "Can solve problems iteratively",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Recursive functions call themselves; need a base case to terminate; some problems can also be solved iteratively."
            },
            {
                "id": "FUN006",
                "question": "Which of the following is true about return statement in functions?",
                "options": [
                    "Terminates function execution",
                    "Returns value to caller if required",
                    "Optional in void functions",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Return statement ends function execution and returns value if the function is non-void; optional for void functions."
            },
            {
                "id": "FUN007",
                "question": "Which of the following is true about default arguments in C++ functions?",
                "options": [
                    "Specified in function declaration",
                    "Used if argument not provided by caller",
                    "Must appear at rightmost parameters",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Default arguments are specified in declaration, used when caller omits them, and must be the rightmost parameters."
            },
            {
                "id": "FUN008",
                "question": "Which of the following is true about static functions in C++?",
                "options": [
                    "Visible only in the file where defined",
                    "Cannot be called outside the file",
                    "Used for internal linkage",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Static functions have file-level scope and provide internal linkage."
            },
            {
                "id": "FUN009",
                "question": "Which of the following is true about function prototype in C/C++?",
                "options": [
                    "Declares function before definition",
                    "Includes return type and parameters",
                    "Helps compiler with type checking",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Function prototypes declare function signature before definition for compiler checking."
            },
            {
                "id": "FUN010",
                "question": "Which of the following is true about parameter passing by value?",
                "options": [
                    "Copies actual value to function",
                    "Changes inside function do not affect caller",
                    "Used for primitive types",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Pass by value copies data; function modifications do not affect caller's variable."
            },
            {
                "id": "FUN011",
                "question": "Which of the following is true about parameter passing by reference in C++?",
                "options": [
                    "Function receives reference to actual variable",
                    "Changes affect caller variable",
                    "Declared using & in parameter",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Pass by reference allows function to modify caller variable; declared using &."
            },
            {
                "id": "FUN012",
                "question": "Which of the following is true about function pointer in C/C++?",
                "options": [
                    "Holds address of a function",
                    "Can be used to call function indirectly",
                    "Useful in callbacks",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Function pointers store function addresses and enable indirect invocation or callback mechanisms."
            },
            {
                "id": "FUN013",
                "question": "Which of the following is true about lambda functions in C++11?",
                "options": [
                    "Anonymous functions",
                    "Can capture variables from enclosing scope",
                    "Used for short inline functionality",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Lambdas are anonymous functions with optional capture lists, useful for inline operations."
            },
            {
                "id": "FUN014",
                "question": "Which of the following is true about pure virtual function?",
                "options": [
                    "Declared with =0",
                    "No definition in base class",
                    "Forces derived class to implement",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Pure virtual functions enforce overriding in derived classes and are declared using =0."
            },
            {
                "id": "FUN015",
                "question": "Which of the following is true about inline recursion?",
                "options": [
                    "Not recommended due to call overhead",
                    "May be expanded inline by compiler",
                    "Mostly used for small recursive calls",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Inline recursion may be expanded by compiler but is generally not recommended for large recursion due to stack usage."
            },
            {
                "id": "FUN016",
                "question": "Which of the following is true about friend function?",
                "options": [
                    "Not a member of class",
                    "Can access private/protected members",
                    "Declared using friend keyword",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Friend functions can access class internals without being members; declared with friend keyword."
            },
            {
                "id": "FUN017",
                "question": "Which of the following is true about overloading vs overriding?",
                "options": [
                    "Overloading: same function name, different parameters",
                    "Overriding: derived class redefines base virtual function",
                    "Overloading resolved at compile-time, overriding at runtime",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Overloading is compile-time polymorphism; overriding is runtime polymorphism using virtual functions."
            },
            {
                "id": "FUN018",
                "question": "Which of the following is true about recursion base case?",
                "options": [
                    "Prevents infinite recursion",
                    "Stops further recursive calls",
                    "Essential for correctness",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Base case terminates recursion and prevents stack overflow."
            },
            {
                "id": "FUN019",
                "question": "Which of the following is true about variadic functions?",
                "options": [
                    "Accept variable number of arguments",
                    "Use ellipsis (...) in parameter list",
                    "va_list, va_start, va_end macros used",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Variadic functions use ellipsis and macros to handle variable argument lists."
            },
            {
                "id": "FUN020",
                "question": "Which of the following is true about function in Java?",
                "options": [
                    "All methods are functions in Java",
                    "Can return values or void",
                    "Can be static or instance",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Java functions (methods) can be static/instance, may return value or void, and belong to classes."
            },
            {
                "id": "FUN021",
                "question": "Which of the following is true about static method in Java?",
                "options": [
                    "Belongs to class, not object",
                    "Called using class name",
                    "Cannot access non-static members directly",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Static methods belong to class, cannot access instance members without object reference, called via class name."
            },
            {
                "id": "FUN022",
                "question": "Which of the following is true about final method in Java?",
                "options": [
                    "Cannot be overridden by derived class",
                    "May be static or instance",
                    "Improves runtime safety",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Final methods prevent overriding and may be static or instance, ensuring stability."
            },
            {
                "id": "FUN023",
                "question": "Which of the following is true about abstract method in Java?",
                "options": [
                    "Declared without body",
                    "Must be implemented in derived class",
                    "Only in abstract classes",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Abstract methods are declared without implementation and must be overridden in derived classes; defined in abstract class only."
            },
            {
                "id": "FUN024",
                "question": "Which of the following is true about constructor vs function in C++?",
                "options": [
                    "Constructor has same name as class",
                    "No return type for constructor",
                    "Functions can have any name and return type",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Constructors are special functions with class name and no return type; regular functions can have any name and return type."
            },
            {
                "id": "FUN025",
                "question": "Which of the following is true about recursive function memory?",
                "options": [
                    "Each call has separate stack frame",
                    "Local variables stored in stack",
                    "Deep recursion may cause stack overflow",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Each recursive call has its own stack frame; deep recursion can overflow stack memory."
            },
            {
                "id": "FUN026",
                "question": "Which of the following is true about tail recursion?",
                "options": [
                    "Recursive call is the last operation",
                    "Can be optimized by compiler into iteration",
                    "Reduces stack usage",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Tail recursion occurs when the recursive call is the last statement; compilers can optimize it to avoid extra stack frames."
            },
            {
                "id": "FUN027",
                "question": "Which of the following is true about non-tail recursion?",
                "options": [
                    "Recursive call not the last operation",
                    "Cannot be optimized easily",
                    "Uses more stack frames",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Non-tail recursion requires additional operations after recursive call, making optimization harder and using more stack frames."
            },
            {
                "id": "FUN028",
                "question": "Which of the following is true about function templates in C++?",
                "options": [
                    "Allow generic programming",
                    "Works with multiple data types",
                    "Defined using template keyword",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Function templates allow writing a single function for multiple data types using the template keyword."
            },
            {
                "id": "FUN029",
                "question": "Which of the following is true about inline recursive functions?",
                "options": [
                    "Compilers may ignore inline request",
                    "Used for small recursive functions",
                    "Cannot always reduce overhead",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Inline is a request; recursive functions may not always be inlined due to multiple calls."
            },
            {
                "id": "FUN030",
                "question": "Which of the following is true about friend function vs member function?",
                "options": [
                    "Friend is not a class member",
                    "Can access private/protected members",
                    "Useful for operator overloading",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Friend functions are non-members with access to class internals; commonly used for operators."
            },
            {
                "id": "FUN031",
                "question": "Which of the following is true about local and global functions?",
                "options": [
                    "Local functions exist only inside block (C does not support nested functions)",
                    "Global functions accessible throughout file or program",
                    "Global functions can access global variables",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "C++ supports local (block-scope) and global (file/program-scope) functions with respective access."
            },
            {
                "id": "FUN032",
                "question": "Which of the following is true about recursion depth?",
                "options": [
                    "Limited by system stack",
                    "Too deep recursion may cause stack overflow",
                    "Depends on function call size and local variables",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Recursion depth is limited by stack size; large recursion can lead to stack overflow."
            },
            {
                "id": "FUN033",
                "question": "Which of the following is true about static local variables in functions?",
                "options": [
                    "Retains value between calls",
                    "Initialized only once",
                    "Has function scope but static lifetime",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Static local variables keep value between calls; scope is local but lifetime is entire program."
            },
            {
                "id": "FUN034",
                "question": "Which of the following is true about const parameters in functions?",
                "options": [
                    "Cannot be modified inside function",
                    "Used for safer programming",
                    "Improves readability and prevents accidental change",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Const parameters prevent modification inside function, improving safety and clarity."
            },
            {
                "id": "FUN035",
                "question": "Which of the following is true about overloaded functions in Java?",
                "options": [
                    "Same name, different parameter list",
                    "Return type may be same or different",
                    "Resolved at compile time",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Java resolves overloaded functions at compile time based on parameter types/count; name can be same."
            },
            {
                "id": "FUN036",
                "question": "Which of the following is true about overridden methods in Java?",
                "options": [
                    "Derived class redefines base class method",
                    "Must have same signature",
                    "Resolved at runtime (dynamic dispatch)",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Overridden methods must have same signature; runtime polymorphism allows derived version to be called."
            },
            {
                "id": "FUN037",
                "question": "Which of the following is true about recursion vs iteration?",
                "options": [
                    "Recursion may use more memory (stack frames)",
                    "Iteration generally uses fixed memory",
                    "Some problems easier with recursion",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Recursion uses stack; iteration uses loop variables; recursion is more natural for some problems."
            },
            {
                "id": "FUN038",
                "question": "Which of the following is true about anonymous functions (lambdas) in Java?",
                "options": [
                    "Introduced in Java 8",
                    "Useful for functional interfaces",
                    "Can be passed as parameters",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Java lambdas are anonymous, used with functional interfaces, and can be passed to methods."
            },
            {
                "id": "FUN039",
                "question": "Which of the following is true about function call stack?",
                "options": [
                    "Stores return addresses",
                    "Stores local variables",
                    "Handles nested and recursive calls",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Function call stack tracks return addresses, local variables, and manages recursion/nested calls."
            },
            {
                "id": "FUN040",
                "question": "Which of the following is true about static methods in C++ class?",
                "options": [
                    "Belongs to class, not object",
                    "Cannot access non-static members directly",
                    "Called using ClassName::method()",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Static methods are class-level, cannot access instance members without object reference."
            },
            {
                "id": "FUN041",
                "question": "Which of the following is true about recursive function return value?",
                "options": [
                    "Value propagates back through recursion",
                    "Used to compute final result",
                    "Must combine recursive calls if multiple",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Recursive functions return values that propagate back through calls; multiple calls may need combining."
            },
            {
                "id": "FUN042",
                "question": "Which of the following is true about inline function vs macro?",
                "options": [
                    "Inline functions are type-safe",
                    "Macros are not type-checked",
                    "Inline functions may replace macro usage",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Inline functions are safer than macros due to type checking and scope."
            },
            {
                "id": "FUN043",
                "question": "Which of the following is true about function with array parameters in C/C++?",
                "options": [
                    "Array decays to pointer",
                    "Size information lost in function",
                    "Pass by reference required for size safety",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Arrays decay to pointers; function loses size info; pass by reference or size parameter needed for safety."
            },
            {
                "id": "FUN044",
                "question": "Which of the following is true about virtual functions in C++?",
                "options": [
                    "Declared with virtual keyword",
                    "Supports runtime polymorphism",
                    "Overridden in derived class",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Virtual functions enable runtime polymorphism; can be overridden in derived classes."
            },
            {
                "id": "FUN045",
                "question": "Which of the following is true about function templates vs class templates?",
                "options": [
                    "Function templates for single function logic",
                    "Class templates for entire class generic types",
                    "Both use template keyword",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Function templates generalize functions; class templates generalize classes; both use template keyword."
            },
            {
                "id": "FUN046",
                "question": "Which of the following is true about recursion vs stack usage?",
                "options": [
                    "Each recursive call uses stack frame",
                    "Excess recursion may cause overflow",
                    "Iteration generally uses less stack",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Recursion uses stack frames per call; deep recursion may overflow; iteration avoids extra frames."
            },
            {
                "id": "FUN047",
                "question": "Which of the following is true about function scope in C++?",
                "options": [
                    "Local variables exist only inside function",
                    "Global variables accessible inside function unless shadowed",
                    "Static local variables persist across calls",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Function scope limits local variable visibility; global accessible unless shadowed; static locals persist."
            },
            {
                "id": "FUN048",
                "question": "Which of the following is true about function return type deduction in C++14?",
                "options": [
                    "auto return type deduced from return statement",
                    "Helps reduce boilerplate",
                    "Useful in templated/complex types",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "C++14 allows auto return type deduction to simplify code and handle complex return types."
            },
            {
                "id": "FUN049",
                "question": "Which of the following is true about function overloading and default parameters?",
                "options": [
                    "May conflict if default arguments create ambiguity",
                    "Compiler resolves carefully",
                    "Used to provide multiple options for caller",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Overloading combined with default parameters may conflict; compiler checks and may produce ambiguity errors."
            },
            {
                "id": "FUN050",
                "question": "Which of the following is true about function recursion vs iteration performance?",
                "options": [
                    "Iteration usually faster due to no stack overhead",
                    "Recursion more readable for some problems",
                    "Tail recursion can optimize recursion",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Iteration avoids stack overhead, recursion is natural for some problems, tail recursion can optimize memory use."
            }
        ],
        "Exception Handling": [
            {
                "id": "EXC001",
                "question": "Which of the following is true about exception handling in C++?",
                "options": [
                    "Allows separation of error handling from normal code",
                    "Uses try, catch, and throw keywords",
                    "Can propagate exceptions to caller",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "C++ exception handling allows structured error handling using try, catch, throw, and can propagate exceptions."
            },
            {
                "id": "EXC002",
                "question": "Which of the following is true about try block?",
                "options": [
                    "Contains code that may throw exceptions",
                    "Must be followed by catch or finally (Java)",
                    "Can be nested inside other try blocks",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Try block encloses code that might throw exceptions; must have catch/finally (Java) and can be nested."
            },
            {
                "id": "EXC003",
                "question": "Which of the following is true about catch block?",
                "options": [
                    "Handles specific exception types",
                    "Executed only if exception occurs",
                    "Can have multiple catch blocks for different exceptions",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Catch blocks handle exceptions; can specify types and multiple blocks handle different exceptions."
            },
            {
                "id": "EXC004",
                "question": "Which of the following is true about throw keyword in C++/Java?",
                "options": [
                    "Used to raise an exception",
                    "Transfers control to nearest catch block",
                    "Can throw objects or primitive types (C++), only objects (Java)",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Throw raises an exception; in Java, only objects can be thrown; in C++ any type can be thrown."
            },
            {
                "id": "EXC005",
                "question": "Which of the following is true about finally block in Java?",
                "options": [
                    "Always executed regardless of exception",
                    "Used to release resources",
                    "Optional with try-catch",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Finally block executes always to release resources; optional but recommended."
            },
            {
                "id": "EXC006",
                "question": "Which of the following is true about checked exceptions in Java?",
                "options": [
                    "Checked at compile time",
                    "Must be handled or declared using throws",
                    "Includes IOException, SQLException",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Checked exceptions must be caught or declared; compiler enforces handling."
            },
            {
                "id": "EXC007",
                "question": "Which of the following is true about unchecked exceptions in Java?",
                "options": [
                    "Not checked at compile time",
                    "Includes RuntimeException and subclasses",
                    "Handling is optional",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Unchecked exceptions are runtime exceptions; compiler does not require handling."
            },
            {
                "id": "EXC008",
                "question": "Which of the following is true about multiple catch blocks in C++/Java?",
                "options": [
                    "Allows handling different exception types",
                    "Executed in order of appearance",
                    "First matching catch block handles exception",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Multiple catch blocks are evaluated in order; first match handles the exception."
            },
            {
                "id": "EXC009",
                "question": "Which of the following is true about rethrowing exceptions in C++/Java?",
                "options": [
                    "Allows exception to propagate to caller",
                    "Used inside catch block",
                    "Syntax: throw; (C++) or throw e; (Java)",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Exceptions can be rethrown from catch to propagate; syntax differs in C++ and Java."
            },
            {
                "id": "EXC010",
                "question": "Which of the following is true about exception hierarchy in Java?",
                "options": [
                    "Throwable is superclass",
                    "Errors and Exceptions are subclasses",
                    "Checked and unchecked exceptions inherit from Exception",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Java exception hierarchy: Throwable → Error / Exception; checked and unchecked derive from Exception."
            },
            {
                "id": "EXC011",
                "question": "Which of the following is true about std::exception in C++?",
                "options": [
                    "Base class for standard exceptions",
                    "Provides what() method for message",
                    "Can be inherited for custom exceptions",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "std::exception is the base class; what() provides message; custom exceptions can inherit it."
            },
            {
                "id": "EXC012",
                "question": "Which of the following is true about catching all exceptions in C++?",
                "options": [
                    "Use catch(...) syntax",
                    "Catches any type thrown",
                    "Usually placed last after specific catch blocks",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "catch(...) catches any exception type; should be last to avoid masking specific catches."
            },
            {
                "id": "EXC013",
                "question": "Which of the following is true about nested try blocks?",
                "options": [
                    "Try block inside another try",
                    "Inner try can have its own catch",
                    "Exceptions propagate outward if not handled",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Nested try blocks allow localized handling; unhandled exceptions propagate outward."
            },
            {
                "id": "EXC014",
                "question": "Which of the following is true about custom exceptions in Java?",
                "options": [
                    "User-defined by extending Exception class",
                    "Can define constructors and methods",
                    "Used for application-specific error handling",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Custom exceptions extend Exception, can have custom methods, and handle specific application errors."
            },
            {
                "id": "EXC015",
                "question": "Which of the following is true about throwing multiple exceptions in Java 7+?",
                "options": [
                    "Use multi-catch: catch(IOException | SQLException e)",
                    "Reduces redundant code",
                    "Single block handles multiple types",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Java 7+ supports multi-catch to handle multiple exception types in one block."
            },
            {
                "id": "EXC016",
                "question": "Which of the following is true about stack unwinding in C++?",
                "options": [
                    "Occurs when exception is thrown",
                    "Destructors of local objects are called",
                    "Ensures resources are released",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Stack unwinding calls destructors for local objects as exception propagates, ensuring resource cleanup."
            },
            {
                "id": "EXC017",
                "question": "Which of the following is true about exception specification in C++?",
                "options": [
                    "Deprecated in C++11",
                    "Used to declare which exceptions a function may throw",
                    "May use noexcept in modern C++",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Old throw specifications deprecated; C++11 uses noexcept to indicate function does not throw."
            },
            {
                "id": "EXC018",
                "question": "Which of the following is true about checked vs unchecked exceptions in Java?",
                "options": [
                    "Checked must be handled",
                    "Unchecked are runtime exceptions",
                    "Handling unchecked is optional",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Checked exceptions require handling; unchecked exceptions do not."
            },
            {
                "id": "EXC019",
                "question": "Which of the following is true about finally block execution?",
                "options": [
                    "Executed even if return occurs in try/catch",
                    "Executed even if exception is thrown",
                    "Used to close streams and resources",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Finally executes always to release resources, even on return or exception."
            },
            {
                "id": "EXC020",
                "question": "Which of the following is true about nested exceptions in Java?",
                "options": [
                    "One exception caused by another",
                    "Use initCause() or constructor with cause",
                    "Helps debug exception chains",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Nested exceptions allow tracking original cause; initCause() links them."
            },
            {
                "id": "EXC021",
                "question": "Which of the following is true about exception propagation in C++?",
                "options": [
                    "Exception moves up the call stack if not caught locally",
                    "Can be caught by caller function",
                    "Ensures higher-level error handling",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Exceptions propagate up the call stack if not handled locally, allowing higher-level functions to catch them."
            },
            {
                "id": "EXC022",
                "question": "Which of the following is true about exception propagation in Java?",
                "options": [
                    "Exceptions propagate to caller method",
                    "Unhandled exceptions may terminate program",
                    "Finally block executes during propagation",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Java exceptions propagate to caller if uncaught; finally block still executes during propagation."
            },
            {
                "id": "EXC023",
                "question": "Which of the following is true about nested try-catch in Java?",
                "options": [
                    "Inner try handles specific exceptions",
                    "Outer try can catch remaining exceptions",
                    "Helps isolate error handling",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Nested try-catch allows inner handling of specific exceptions while outer can catch others, isolating errors."
            },
            {
                "id": "EXC024",
                "question": "Which of the following is true about multiple exceptions in C++?",
                "options": [
                    "Catch specific exceptions first",
                    "Use general exception catch later",
                    "Prevents masking specific exceptions",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Order matters: catch specific exceptions first, general later to avoid masking."
            },
            {
                "id": "EXC025",
                "question": "Which of the following is true about std::runtime_error in C++?",
                "options": [
                    "Derived from std::exception",
                    "Represents runtime errors",
                    "Can be thrown and caught",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "std::runtime_error is standard C++ exception for runtime issues, inheriting from std::exception."
            },
            {
                "id": "EXC026",
                "question": "Which of the following is true about resource management with exceptions?",
                "options": [
                    "RAII ensures proper cleanup in C++",
                    "Finally block releases resources in Java",
                    "Prevents memory leaks and dangling pointers",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "RAII (C++) and finally (Java) ensure resources are cleaned up during exception handling."
            },
            {
                "id": "EXC027",
                "question": "Which of the following is true about std::bad_alloc exception in C++?",
                "options": [
                    "Thrown when memory allocation fails",
                    "Derived from std::exception",
                    "Can be caught to handle allocation failure",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "std::bad_alloc is thrown on new operator failure; can be caught to prevent program crash."
            },
            {
                "id": "EXC028",
                "question": "Which of the following is true about exception safety in C++?",
                "options": [
                    "Functions should leave program in consistent state",
                    "Avoid resource leaks during exception",
                    "Use RAII and smart pointers",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Exception-safe code ensures no leaks, consistent state, and uses RAII or smart pointers."
            },
            {
                "id": "EXC029",
                "question": "Which of the following is true about try-with-resources in Java?",
                "options": [
                    "Introduced in Java 7",
                    "Automatically closes resources implementing AutoCloseable",
                    "Simplifies resource management",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Try-with-resources automatically closes AutoCloseable resources, simplifying cleanup."
            },
            {
                "id": "EXC030",
                "question": "Which of the following is true about nested exceptions in C++?",
                "options": [
                    "Can capture original exception",
                    "Use std::nested_exception and std::throw_with_nested",
                    "Useful for wrapping exceptions in libraries",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "C++ nested exceptions track original causes; throw_with_nested wraps exceptions for library code."
            },
            {
                "id": "EXC031",
                "question": "Which of the following is true about exception handling best practices?",
                "options": [
                    "Catch only expected exceptions",
                    "Avoid using exceptions for normal control flow",
                    "Always release resources",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Good practice: catch only expected exceptions, avoid control-flow misuse, and ensure resource cleanup."
            },
            {
                "id": "EXC032",
                "question": "Which of the following is true about throwing exceptions across modules?",
                "options": [
                    "Exception can propagate through multiple functions",
                    "Modules must be designed to handle exceptions properly",
                    "Helps centralized error handling",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Exceptions can cross module boundaries, enabling centralized handling if modules follow proper design."
            },
            {
                "id": "EXC033",
                "question": "Which of the following is true about catching by reference vs by value in C++?",
                "options": [
                    "Prefer catching exceptions by const reference",
                    "Avoids slicing",
                    "Efficient and safe",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Catching by const reference prevents object slicing and is efficient."
            },
            {
                "id": "EXC034",
                "question": "Which of the following is true about exception hierarchy in C++?",
                "options": [
                    "std::exception is base class",
                    "std::runtime_error and std::logic_error are derived",
                    "Custom exceptions can derive from std::exception",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "C++ standard exceptions inherit from std::exception; custom exceptions can follow same hierarchy."
            },
            {
                "id": "EXC035",
                "question": "Which of the following is true about throwing literals in C++?",
                "options": [
                    "C++ allows throwing int, char, string, or objects",
                    "Not type-safe",
                    "Best practice: throw objects derived from std::exception",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Throwing literals works but is not type-safe; best practice is throwing std::exception derived objects."
            },
            {
                "id": "EXC036",
                "question": "Which of the following is true about exception specification in modern C++?",
                "options": [
                    "Use noexcept to declare function does not throw",
                    "Helps compiler optimization",
                    "Improves program safety",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "noexcept specifies non-throwing functions, enabling optimization and safety."
            },
            {
                "id": "EXC037",
                "question": "Which of the following is true about exception logging?",
                "options": [
                    "Capture exception type and message",
                    "Capture stack trace if possible",
                    "Useful for debugging and auditing",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Logging exception details, including stack trace, helps debug and track errors."
            },
            {
                "id": "EXC038",
                "question": "Which of the following is true about rethrowing in Java?",
                "options": [
                    "Can rethrow caught exception",
                    "Use throw; or throw e; syntax",
                    "Preserves stack trace if using throw",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Java allows rethrowing to propagate exception; using throw preserves stack trace."
            },
            {
                "id": "EXC039",
                "question": "Which of the following is true about exception handling cost?",
                "options": [
                    "Try-catch blocks may slightly increase runtime",
                    "Throwing exceptions is more expensive than return codes",
                    "Used only for exceptional cases",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Exception handling has runtime cost; throwing is more expensive than return codes; use for true exceptional conditions."
            },
            {
                "id": "EXC040",
                "question": "Which of the following is true about resource acquisition and exception safety in C++?",
                "options": [
                    "RAII objects release resources in destructors",
                    "Prevents leaks during exceptions",
                    "Smart pointers are RAII-compliant",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "RAII objects and smart pointers ensure resources are safely released even during exceptions."
            },
            {
                "id": "EXC041",
                "question": "Which of the following is true about exception chaining in Java?",
                "options": [
                    "One exception caused by another",
                    "Helps track root cause",
                    "Use initCause() to link exceptions",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Exception chaining links exceptions to preserve root cause for debugging."
            },
            {
                "id": "EXC042",
                "question": "Which of the following is true about handling multiple exceptions in Java?",
                "options": [
                    "Use multi-catch feature (Java 7+)",
                    "Reduces redundant catch code",
                    "Allows single block for multiple types",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Java 7+ supports multi-catch for handling multiple exception types in a single block."
            },
            {
                "id": "EXC043",
                "question": "Which of the following is true about exception-safe assignment in C++?",
                "options": [
                    "Copy-and-swap idiom ensures strong exception guarantee",
                    "Object remains valid if exception occurs",
                    "Prevents partially modified state",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Copy-and-swap idiom provides strong exception guarantee in assignment operators."
            },
            {
                "id": "EXC044",
                "question": "Which of the following is true about exception handling and program termination?",
                "options": [
                    "Unhandled exception may terminate program",
                    "std::terminate is called in C++",
                    "Default handler prints message and aborts",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Uncaught exceptions trigger program termination using std::terminate in C++, default handler prints message."
            },
            {
                "id": "EXC045",
                "question": "Which of the following is true about exception propagation in destructors?",
                "options": [
                    "Throwing exceptions in destructor is dangerous",
                    "May call std::terminate if another exception active",
                    "Prefer noexcept destructors in C++11",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Exceptions in destructors during stack unwinding can terminate program; noexcept recommended."
            },
            {
                "id": "EXC046",
                "question": "Which of the following is true about exception handling in multi-threaded programs?",
                "options": [
                    "Exceptions in one thread do not affect others",
                    "Each thread should handle its own exceptions",
                    "Uncaught exceptions may terminate thread",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "In multithreading, exceptions are local to threads; unhandled exceptions may terminate the thread."
            },
            {
                "id": "EXC047",
                "question": "Which of the following is true about standard exception categories in C++?",
                "options": [
                    "logic_error for logical errors",
                    "runtime_error for runtime issues",
                    "std::exception base class for all standard exceptions",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Standard exceptions are organized into logic_error and runtime_error; all inherit from std::exception."
            },
            {
                "id": "EXC048",
                "question": "Which of the following is true about exception specification removal in modern C++?",
                "options": [
                    "Old throw() specifications deprecated",
                    "Use noexcept for indicating non-throwing functions",
                    "Improves compiler optimization",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Old throw specifications deprecated; noexcept used to declare functions as non-throwing."
            },
            {
                "id": "EXC049",
                "question": "Which of the following is true about exception handling in Java constructors?",
                "options": [
                    "Constructors can throw exceptions",
                    "Exceptions propagate to caller",
                    "Must handle or declare checked exceptions",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Java constructors may throw exceptions; checked exceptions must be declared or handled by caller."
            },
            {
                "id": "EXC050",
                "question": "Which of the following is true about best practice for exception messages?",
                "options": [
                    "Include meaningful details",
                    "Avoid exposing sensitive information",
                    "Log for debugging and audit",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Good practice is to provide meaningful, safe, and loggable exception messages."
            }
        ],
        "extra_qs": [
            {
                "id": "EXTRA001",
                "question": "Which of the following is TRUE about Java String immutability?",
                "options": [
                    "Strings can be modified after creation",
                    "String literal points to same object if content same",
                    "StringBuilder behaves same as String",
                    "Strings can be resized in memory"
                ],
                "answer": 1,
                "explanation": "Java Strings are immutable; literals with same content refer to same object; StringBuilder is mutable."
            },
            {
                "id": "EXTRA002",
                "question": "Which of the following is TRUE about C++ virtual destructors?",
                "options": [
                    "Called automatically when object deleted via base pointer",
                    "Cannot be pure virtual",
                    "Cannot have parameters",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Virtual destructor ensures derived class cleanup; cannot have parameters; can be pure virtual if needed."
            },
            {
                "id": "EXTRA003",
                "question": "Which of the following is TRUE about Java interfaces and abstract classes?",
                "options": [
                    "Interfaces can have multiple inheritance",
                    "Abstract class can have constructors",
                    "Interfaces cannot have instance variables",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Interfaces support multiple inheritance, cannot have instance variables; abstract class can have constructors."
            },
            {
                "id": "EXTRA004",
                "question": "Which of the following statements about C++ const reference parameter is TRUE?",
                "options": [
                    "Cannot modify original variable",
                    "Avoids copying large objects",
                    "Can bind to temporary objects",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Const references cannot modify original, save copy overhead, and allow binding to temporaries."
            },
            {
                "id": "EXTRA005",
                "question": "What is output?\n\nint a=10;\nint *p=&a;\nint **q=&p;\ncout<<**q;",
                "options": [
                    "10",
                    "Address of a",
                    "Compilation error",
                    "Depends on compiler"
                ],
                "answer": 0,
                "explanation": "**q dereferences twice → value of a → 10."
            },
            {
                "id": "EXTRA006",
                "question": "Which of the following is TRUE about Java method hiding?",
                "options": [
                    "Occurs with static methods",
                    "Overriding happens with instance methods",
                    "Base static method can be hidden in derived class",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Static methods cannot be overridden, only hidden; instance methods override normally."
            },
            {
                "id": "EXTRA007",
                "question": "Which of the following is TRUE about Java enums?",
                "options": [
                    "Enum values are constants",
                    "Can have fields and methods",
                    "Cannot extend other classes",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Enum constants; can have fields/methods; cannot extend other classes (implicitly extend Enum)."
            },
            {
                "id": "EXTRA008",
                "question": "Which of the following is TRUE about C++ template functions?",
                "options": [
                    "Enable generic programming",
                    "Type is determined at compile-time",
                    "Can be overloaded with different types",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Templates allow type-generic functions; type resolved at compile-time; can overload templates."
            },
            {
                "id": "EXTRA009",
                "question": "Which of the following is TRUE about Java pass-by-value?",
                "options": [
                    "Primitive types are copied",
                    "Object references are copied",
                    "Modifying object through reference affects original",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Java passes primitive values directly; object references are copied; modifying object via reference affects original."
            },
            {
                "id": "EXTRA010",
                "question": "Which of the following is TRUE about C++ function pointers?",
                "options": [
                    "Can store address of a function",
                    "Can be passed as arguments",
                    "Supports dynamic function calls",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Function pointers store addresses; can be passed to other functions; enable indirect calls."
            },
            {
                "id": "EXTRA011",
                "question": "Which of the following is TRUE about Java static block execution?",
                "options": [
                    "Executes before main method",
                    "Executed only once per class loading",
                    "Can throw unchecked exceptions",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Static block executes once before main; can throw unchecked exceptions."
            },
            {
                "id": "EXTRA012",
                "question": "Which of the following is TRUE about C++ multiple inheritance?",
                "options": [
                    "A class can inherit from multiple base classes",
                    "Diamond problem exists",
                    "Virtual inheritance can solve diamond problem",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "C++ allows multiple inheritance; diamond problem occurs; virtual inheritance resolves it."
            },
            {
                "id": "EXTRA013",
                "question": "Which of the following is TRUE about Java try-with-resources?",
                "options": [
                    "Automatically closes resources",
                    "Works only with AutoCloseable objects",
                    "Reduces need for finally block",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Try-with-resources auto-closes resources implementing AutoCloseable, reducing finally block usage."
            },
            {
                "id": "EXTRA014",
                "question": "Which of the following is TRUE about C++ reference variables?",
                "options": [
                    "Must be initialized",
                    "Cannot be null",
                    "Cannot be reassigned to another object",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "References must be initialized, cannot be null, cannot rebind to another object."
            },
            {
                "id": "EXTRA015",
                "question": "Which of the following is TRUE about Java synchronized methods?",
                "options": [
                    "Used to avoid race conditions",
                    "Only one thread can access at a time per object",
                    "Can be static or instance method",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Synchronization prevents concurrent access; works on object or class (static); ensures thread safety."
            },
            {
                "id": "EXTRA016",
                "question": "Which of the following is TRUE about C++ new operator?",
                "options": [
                    "Allocates memory on heap",
                    "Calls constructor for objects",
                    "Must be paired with delete to free memory",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "new allocates memory on heap, calls constructor, delete must free it."
            },
            {
                "id": "EXTRA017",
                "question": "Which of the following is TRUE about Java anonymous classes?",
                "options": [
                    "Do not have a name",
                    "Can implement interfaces",
                    "Can extend classes",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Anonymous classes have no name; can implement interfaces or extend classes."
            },
            {
                "id": "EXTRA018",
                "question": "Which of the following is TRUE about C++ const member function?",
                "options": [
                    "Cannot modify object members",
                    "Can be called on const objects",
                    "Cannot call non-const member functions",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Const member function cannot modify object; callable on const objects; cannot call non-const functions."
            },
            {
                "id": "EXTRA019",
                "question": "Which of the following is TRUE about Java super keyword?",
                "options": [
                    "Used to call parent class constructor",
                    "Used to access parent class methods",
                    "Used to access parent class variables",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "super can access parent constructor, methods, and variables."
            },
            {
                "id": "EXTRA020",
                "question": "Which of the following is TRUE about C++ friend class?",
                "options": [
                    "Can access private members of another class",
                    "Does not violate encapsulation completely",
                    "Not inherited",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Friend class can access private members; not inherited; partially bypasses encapsulation."
            },
            {
                "id": "EXTRA021",
                "question": "Which of the following is TRUE about Java transient keyword?",
                "options": [
                    "Prevents variable from serialization",
                    "Used with instance variables",
                    "Does not affect static variables",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Transient prevents serialization; works on instance vars; static variables never serialized."
            },
            {
                "id": "EXTRA022",
                "question": "Which of the following is TRUE about C++ function overloading and default arguments?",
                "options": [
                    "Overloaded functions can have default arguments",
                    "Default arguments must be last",
                    "Cannot have ambiguous calls",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Default arguments allowed; must appear at end; avoid ambiguity in overloading."
            },
            {
                "id": "EXTRA023",
                "question": "Which of the following is TRUE about Java varargs?",
                "options": [
                    "Allow variable number of arguments",
                    "Must be last parameter",
                    "Can be combined with other parameters",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Varargs allow flexible argument count; must be last parameter; can combine with other parameters."
            },
            {
                "id": "EXTRA024",
                "question": "Which of the following is TRUE about C++ exception specifications?",
                "options": [
                    "Deprecated in C++11",
                    "Used to declare exceptions thrown by function",
                    "Not enforced at runtime",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Exception specifications are deprecated; declare potential throws; mostly compile-time checked."
            },
            {
                "id": "EXTRA025",
                "question": "Which of the following is TRUE about Java String pool?",
                "options": [
                    "Helps save memory",
                    "String literals refer to same object",
                    "New String() creates new object",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "String pool avoids duplicate literals; new creates new object outside pool."
            },
            {
                "id": "EXTRA026",
                "question": "Which of the following is TRUE about C++ volatile keyword?",
                "options": [
                    "Prevents compiler optimization",
                    "Used for hardware registers or multithreading",
                    "Forces every read/write to memory",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Volatile prevents optimization; used for special memory locations; ensures memory access."
            },
            {
                "id": "EXTRA027",
                "question": "Which of the following is TRUE about Java package-private access?",
                "options": [
                    "Accessible within same package",
                    "Not accessible from other packages",
                    "Default if no modifier is specified",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Package-private (default) allows access within package, not outside."
            },
            {
                "id": "EXTRA028",
                "question": "Which of the following is TRUE about C++ noexcept specifier?",
                "options": [
                    "Indicates function does not throw exceptions",
                    "Compiler may optimize based on it",
                    "Helps with noexcept move constructors",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Noexcept indicates no exceptions; compiler can optimize; important for move semantics."
            },
            {
                "id": "EXTRA029",
                "question": "Which of the following is TRUE about Java synchronized block?",
                "options": [
                    "Can lock on any object",
                    "Reduces scope compared to synchronized method",
                    "Improves performance when fine-grained locking",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Synchronized block allows object-level lock; scope limited; better performance for small critical section."
            },
            {
                "id": "EXTRA030",
                "question": "Which of the following is TRUE about C++ default constructors?",
                "options": [
                    "Automatically provided if no constructor defined",
                    "Can be explicitly defined",
                    "Used to initialize objects without parameters",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Default constructors provided if none defined; can define explicitly; initializes objects without arguments."
            },
            {
                "id": "EXTRA031",
                "question": "Which of the following is TRUE about Java static nested class?",
                "options": [
                    "Cannot access outer class instance variables directly",
                    "Can have static members",
                    "Instantiated without outer class object",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Static nested class independent of outer instance; can have static members; instantiated separately."
            },
            {
                "id": "EXTRA032",
                "question": "Which of the following is TRUE about C++ rvalue references?",
                "options": [
                    "Used for move semantics",
                    "Denoted by &&",
                    "Allow optimization by transferring resources",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Rvalue references support move semantics, use &&, and optimize resource transfer."
            },
            {
                "id": "EXTRA033",
                "question": "Which of the following is TRUE about Java finally block with return?",
                "options": [
                    "Executes even if try has return",
                    "Can override return value if modifies variable",
                    "Useful for cleanup",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Finally block executes even with return; can affect returned values if modifies; useful for cleanup."
            },
            {
                "id": "EXTRA034",
                "question": "Which of the following is TRUE about C++ pure virtual function?",
                "options": [
                    "Declared using =0",
                    "Makes class abstract",
                    "Must be implemented in derived class to instantiate",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Pure virtual function uses =0; class becomes abstract; derived class must implement to instantiate."
            },
            {
                "id": "EXTRA035",
                "question": "Which of the following is TRUE about Java try-catch nesting?",
                "options": [
                    "Inner try-catch can handle exceptions from outer try",
                    "Outer try-catch can handle exceptions from inner try",
                    "Multiple catch blocks allowed",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Nested try-catch allows handling at appropriate level; multiple catch blocks allowed."
            },
            {
                "id": "EXTRA036",
                "question": "Which of the following is TRUE about C++ inline friend function?",
                "options": [
                    "Can be defined inside class",
                    "Can be inline",
                    "Accesses private members",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Friend functions can be inline; defined inside class; access private members."
            },
            {
                "id": "EXTRA037",
                "question": "Which of the following is TRUE about Java finalizer (deprecated)?",
                "options": [
                    "Called by garbage collector before object destruction",
                    "Not guaranteed to run timely",
                    "Should not be used for critical resource release",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Finalize called by GC; timing uncertain; not recommended for resource release."
            },
            {
                "id": "EXTRA038",
                "question": "Which of the following is TRUE about C++ multiple catch blocks?",
                "options": [
                    "Catches must be ordered from derived to base",
                    "C++ checks catch blocks sequentially",
                    "Only first matching catch executes",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Catch blocks checked in order; derived before base; first matching executes."
            },
            {
                "id": "EXTRA039",
                "question": "Which of the following is TRUE about Java abstract method?",
                "options": [
                    "Declared without body",
                    "Must be in abstract class",
                    "Implemented in derived class",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Abstract method has no body; only in abstract class; must be implemented in subclass."
            },
            {
                "id": "EXTRA040",
                "question": "Which of the following is TRUE about C++ operator overloading?",
                "options": [
                    "Cannot overload new/delete operators",
                    "Can overload +,-,*, etc.",
                    "Cannot change operator precedence",
                    "All of the above"
                ],
                "answer": 2,
                "explanation": "C++ allows overloading most operators; new/delete can be overloaded; precedence fixed."
            },
            {
                "id": "EXTRA041",
                "question": "Which of the following is TRUE about Java default method in interface?",
                "options": [
                    "Has a body",
                    "Can be overridden",
                    "Introduced in Java 8",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Default methods have body; can be overridden; introduced in Java 8."
            },
            {
                "id": "EXTRA042",
                "question": "Which of the following is TRUE about C++ constructor overloading?",
                "options": [
                    "Multiple constructors with different parameters",
                    "Called based on object initialization",
                    "Can call other constructors via delegation (C++11)",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Constructor overloading allows multiple constructors; selected by initialization; delegation allowed in C++11."
            },
            {
                "id": "EXTRA043",
                "question": "Which of the following is TRUE about Java object cloning?",
                "options": [
                    "Uses Object.clone() method",
                    "Performs shallow copy by default",
                    "Class must implement Cloneable interface",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Clone method exists; shallow copy unless overridden; class must implement Cloneable."
            },
            {
                "id": "EXTRA044",
                "question": "Which of the following is TRUE about C++ virtual base class?",
                "options": [
                    "Used in multiple inheritance",
                    "Avoids duplicate base instances",
                    "Constructor called once",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Virtual base class prevents duplication in diamond inheritance; constructor called once."
            },
            {
                "id": "EXTRA045",
                "question": "Which of the following is TRUE about Java Thread safe singleton?",
                "options": [
                    "Use synchronized block",
                    "Use double-checked locking",
                    "Use enum singleton",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "All approaches ensure thread-safe singleton creation in Java."
            },
            {
                "id": "EXTRA046",
                "question": "Which of the following is TRUE about C++ static member variables?",
                "options": [
                    "Shared among all objects",
                    "Can be private or public",
                    "Initialized outside class",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Static members shared; access modifier flexible; initialization outside class required."
            },
            {
                "id": "EXTRA047",
                "question": "Which of the following is TRUE about Java constructor chaining?",
                "options": [
                    "Uses this() for same class constructor",
                    "Uses super() for parent constructor",
                    "Called in constructor first statement",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Constructor chaining uses this() or super(); must be first statement."
            },
            {
                "id": "EXTRA048",
                "question": "Which of the following is TRUE about C++ default arguments in member functions?",
                "options": [
                    "Specified in declaration, not definition",
                    "Can reduce number of overloads",
                    "Cannot create ambiguity",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Default args specified in declaration; reduce overloads; avoid ambiguous calls."
            },
            {
                "id": "EXTRA049",
                "question": "Which of the following is TRUE about Java Exception hierarchy?",
                "options": [
                    "Throwable is superclass",
                    "Error and Exception are subclasses",
                    "Checked and unchecked exceptions differ",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "Throwable is top; Error and Exception derive; checked exceptions must be declared/handled."
            },
            {
                "id": "EXTRA050",
                "question": "Which of the following is TRUE about C++ RAII principle?",
                "options": [
                    "Resource allocation tied to object lifetime",
                    "Destructor releases resource",
                    "Helps exception safety",
                    "All of the above"
                ],
                "answer": 3,
                "explanation": "RAII binds resource to object lifetime; destructor frees resource; ensures safety during exceptions."
            }
        ]
    }
}