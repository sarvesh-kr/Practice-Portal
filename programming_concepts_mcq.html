<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Programming MCQs - Exam Prep</title>
<style>
body { margin:0; font-family: Arial, sans-serif; display:flex; min-height:100vh; background:#f9f9f9; }
#sidebar { width:250px; background:#2c3e50; color:white; padding:20px; box-sizing:border-box; position:sticky; top:0; height:100vh; overflow:auto; }
#sidebar h2 { text-align:center; margin-bottom:20px; }
#sidebar ul { list-style:none; padding:0; }
#sidebar li { padding:10px; cursor:pointer; border-bottom:1px solid #34495e; }
#sidebar li:hover { background:#34495e; }
#content { flex:1; padding:20px; box-sizing:border-box; overflow-y:auto; }
.section { display:none; }
.question { margin-bottom:20px; padding:15px; border:1px solid #ddd; border-radius:8px; background:#fff; }
.question h3 { margin:0 0 10px 0; font-size:1.1em; }
.options label { display:block; margin-bottom:5px; cursor:pointer; padding:5px; border-radius:5px; }
.options input[type="radio"] { margin-right:8px; }
.options label.correct { background:#d4edda; }
.options label.wrong { background:#f8d7da; }
.feedback { margin-top:5px; font-weight:bold; }
.explanation { font-style:italic; color:#555; display:none; margin-top:5px; }
.mark-review { margin-top:5px; display:block; }
.progress { margin-bottom:15px; font-weight:bold; }
#scoreSummary { margin-top:20px; padding:10px; background:#3498db; border-radius:8px; display:none; }
@media(max-width:768px){ body { flex-direction:column; } #sidebar{width:100%; height:auto; position:relative;} }
</style>
</head>
<body>

<div id="sidebar">
<h2>Sections</h2>
<ul id="sectionList"></ul>
<button onclick="showScore()" style="margin-top:10px;width:100%;padding:8px;background:#27ae60;color:white;border:none;border-radius:5px;cursor:pointer;">Show Score Summary</button>
<div id="scoreSummary"></div>
</div>

<div id="content">
<!-- Sections dynamically populated testt-->
</div>

<script>
// ================= Question Collections (5 per section) =================
const data = {
"Programming Concepts":[
  { id:"PC001", question:"Which of the following is a primitive type in Java?", options:["String","int","Array","Object"], answer:1, explanation:"int is a primitive type in Java." },
  { id:"PC002", question:"Which language is platform independent?", options:["C++","Java","C","Assembly"], answer:1, explanation:"Java bytecode runs on JVM which makes it platform independent." },
  { id:"PC003", question:"Which of the following is not a primitive type in C?", options:["int","float","double","String"], answer:3, explanation:"String is not a primitive type in C." },
  { id:"PC004", question:"Which of these is not a valid C++ access specifier?", options:["public","protected","friendly","private"], answer:2, explanation:"'friendly' is not a C++ access specifier." },
  { id:"PC005", question:"Which of the following supports operator overloading?", options:["Java","C","C++","Python"], answer:2, explanation:"C++ supports operator overloading." },
  { id:"PC006", question:"Which keyword is used to inherit a class in C++?", options:["extends","inherits",":","super"], answer:2, explanation:"C++ uses ':' to denote inheritance." },
  { id:"PC007", question:"Which of these is not a Java keyword?", options:["static","Boolean","private","try"], answer:1, explanation:"Boolean is not a keyword in Java (boolean is)." },
  { id:"PC008", question:"Which of these is a loop construct available in C?", options:["for","loop","repeat","foreach"], answer:0, explanation:"'for' is a loop in C." },
  { id:"PC009", question:"Which of the following is a correct comment in C++?", options:["// comment","/* comment */","# comment","<!-- comment -->"], answer:0, explanation:"'//' is a single-line comment in C++." },
  { id:"PC010", question:"Java source code is compiled into:", options:["Machine code","Bytecode","Assembly code","Intermediate C code"], answer:1, explanation:"Java is compiled to bytecode executed by JVM." },
  { id:"PC011", question:"Which of these is not a C data type?", options:["int","float","decimal","char"], answer:2, explanation:"'decimal' is not a standard C data type." },
  { id:"PC012", question:"Which operator is used to access members of a structure in C?", options:[".","->","::","*"], answer:0, explanation:"The '.' operator accesses struct members." },
  { id:"PC013", question:"In Java, which operator is used for equality comparison?", options:["=","==","===","equals"], answer:1, explanation:"'==' compares primitive values in Java." },
  { id:"PC014", question:"Which of these is not a valid loop in Java?", options:["for","repeat","while","do-while"], answer:1, explanation:"Java does not have a 'repeat' loop." },
  { id:"PC015", question:"Which of these is the correct way to declare an array in C++?", options:["int arr[];","array int arr;","int arr();","int[] arr;"], answer:0, explanation:"int arr[] is correct in C++." },
  { id:"PC016", question:"Which of the following is the size of an int in most 32-bit C/C++ compilers?", options:["2 bytes","4 bytes","8 bytes","Depends on JVM"], answer:1, explanation:"On most 32-bit systems, int is 4 bytes." },
  { id:"PC017", question:"Which one is the correct syntax for main in C++?", options:["main()","int main()","void main()","Main()"], answer:1, explanation:"Standard C++ uses int main()." },
  { id:"PC018", question:"Which of the following is not a Java access specifier?", options:["public","default","internal","private"], answer:2, explanation:"Java does not have 'internal' access specifier." },
  { id:"PC019", question:"The value of a boolean in Java can be:", options:["0 or 1","true or false","1 or -1","yes or no"], answer:1, explanation:"Boolean values in Java are true or false." },
  { id:"PC020", question:"Which is the correct way to allocate memory dynamically in C++?", options:["malloc()","new","alloc()","create()"], answer:1, explanation:"new is used for dynamic memory in C++." },
  { id:"PC021", question:"C++ was developed by:", options:["Dennis Ritchie","Bjarne Stroustrup","James Gosling","Guido van Rossum"], answer:1, explanation:"Bjarne Stroustrup developed C++." },
  { id:"PC022", question:"Which of the following is a valid identifier in C?", options:["9var","_var","var-name","var name"], answer:1, explanation:"Identifiers cannot start with digits and cannot have space." },
  { id:"PC023", question:"Which is not supported by Java?", options:["Pointers","Interfaces","Threads","Inheritance"], answer:0, explanation:"Java does not support explicit pointers." },
  { id:"PC024", question:"Which operator is used to get the address of a variable in C?", options:["&","*","%","$"], answer:0, explanation:"& yields the address of a variable." },
  { id:"PC025", question:"Which is the correct way to print in C++?", options:["cout <<","printf()","print()","echo"], answer:0, explanation:"cout << is standard output in C++." },
  { id:"PC026", question:"Which of these is a Java string literal?", options:["\"Hello\"","'Hello'","`Hello`","<Hello>"], answer:0, explanation:"String literals in Java use double quotes." },
  { id:"PC027", question:"Which of these cannot be used for conditional branching in C?", options:["if","goto","continue","switch"], answer:2, explanation:"continue is not a branching statement." },
  { id:"PC028", question:"What is the default value of an int variable in Java?", options:["0","null","undefined","depends"], answer:0, explanation:"Default value of int is 0." },
  { id:"PC029", question:"Which of these is an escape sequence in C?", options:["\\n","\\t","\\\\","all of these"], answer:3, explanation:"All listed sequences are valid." },
  { id:"PC030", question:"Which package is automatically imported in Java?", options:["java.io","java.lang","java.util","java.net"], answer:1, explanation:"java.lang is automatically imported." },
  { id:"PC031", question:"Which of these operators has highest precedence in C?", options:["*","=","&&","||"], answer:0, explanation:"Multiplication has higher precedence." },
  { id:"PC032", question:"Which of these is used for single-line comment in C++?", options:["//","/* */","#","<!--"], answer:0, explanation:"// denotes single-line comment." },
  { id:"PC033", question:"What does JVM stand for?", options:["Java Virtual Machine","Java Variable Model","Java Visual Mode","Java Verified Machine"], answer:0, explanation:"JVM stands for Java Virtual Machine." },
  { id:"PC034", question:"Which is used for dynamic binding in C++?", options:["virtual","static","final","const"], answer:0, explanation:"virtual enables dynamic dispatch." },
  { id:"PC035", question:"What is the size of a float in Java?", options:["4 bytes","8 bytes","2 bytes","depends"], answer:0, explanation:"float occupies 4 bytes in Java." },
  { id:"PC036", question:"In C, what is returned by malloc() on failure?", options:["NULL","0","-1","garbage"], answer:0, explanation:"malloc returns NULL on failure." },
  { id:"PC037", question:"Which of these is an illegal Java identifier?", options:["var","_var","$var","1var"], answer:3, explanation:"Identifiers cannot begin with a digit." },
  { id:"PC038", question:"Which operator is overloaded by default in Java?", options:["+ (string concatenation)","+ (arithmetic)","==","++"], answer:0, explanation:"+' is overloaded for string concatenation." },
  { id:"PC039", question:"Which of these is not a valid C loop?", options:["for","while","repeat","do-while"], answer:2, explanation:"C has no repeat loop." },
  { id:"PC040", question:"Which method must be implemented by all threads in Java?", options:["run()","start()","main()","init()"], answer:0, explanation:"run() must be overridden." },
  { id:"PC041", question:"Which keyword prevents method overriding in Java?", options:["final","static","private","protected"], answer:0, explanation:"final prevents overriding." },
  { id:"PC042", question:"What does scanf() return in C?", options:["Number of items read","First value read","Address","None"], answer:0, explanation:"scanf returns the count of items successfully read." },
  { id:"PC043", question:"Which is used to terminate a loop in C++?", options:["break","exit","terminate","stop"], answer:0, explanation:"break exits a loop immediately." },
  { id:"PC044", question:"Which of these cannot hold fractional values?", options:["float","double","char","long double"], answer:2, explanation:"char holds single character, not fractions." },
  { id:"PC045", question:"Which is not a Java primitive type?", options:["int","float","String","double"], answer:2, explanation:"String is an object, not primitive." },
  { id:"PC046", question:"Which C++ header is needed for cout?", options:["<iostream>","<stdio.h>","<stdlib.h>","<conio.h>"], answer:0, explanation:"iostream is required for cout." },
  { id:"PC047", question:"Which of the following is a valid C++ keyword?", options:["friend","virtual","extends","implements"], answer:1, explanation:"virtual is a C++ keyword." },
  { id:"PC048", question:"Which of these is a checked exception in Java?", options:["IOException","NullPointerException","RuntimeException","ArithmeticException"], answer:0, explanation:"IOException is checked at compile time." },
  { id:"PC049", question:"Which symbol is used for pointer declaration in C?", options:["*","&","%","#"], answer:0, explanation:"* declares pointers." },
  { id:"PC050", question:"Which method is used to start a thread in Java?", options:["start()","run()","execute()","init()"], answer:0, explanation:"start() begins thread execution." },
  { id:"PC051", question:"Which operator is used to access object members in Java?", options:[".","->","::","*"], answer:0, explanation:"In Java, '.' is used to access object members." },
{ id:"PC052", question:"Which of these is a valid declaration of a constant in C?", options:["const int x = 5;","int const x;","final int x = 5;","#define x 5;"], answer:0, explanation:"const int x = 5; declares a constant in C." },
{ id:"PC053", question:"Which of the following is true about C++ constructors?", options:["They have no return type","They must be static","They can return void","They must be virtual"], answer:0, explanation:"Constructors in C++ do not have a return type." },
{ id:"PC054", question:"Which of these is a correct way to declare a pointer in C?", options:["int *p;","int p*;","*int p;","pointer int p;"], answer:0, explanation:"int *p; declares a pointer to int." },
{ id:"PC055", question:"Which Java keyword is used to inherit a class?", options:["implements","extends","inherits","super"], answer:1, explanation:"The 'extends' keyword is used for inheritance." },
{ id:"PC056", question:"Which of the following is not a valid Java identifier?", options:["myVar","_var","$var","3var"], answer:3, explanation:"Identifiers cannot start with a digit." },
{ id:"PC057", question:"Which of these operators cannot be overloaded in C++?", options:["+","=","::","*"], answer:2, explanation:"Scope resolution operator '::' cannot be overloaded." },
{ id:"PC058", question:"Which of the following is true about Java interfaces?", options:["They can contain concrete methods","They cannot contain variables","They support multiple inheritance","They can be instantiated"], answer:2, explanation:"Interfaces support multiple inheritance in Java." },
{ id:"PC059", question:"Which of these is a valid floating-point literal in C++?", options:["12.34","12,34","12.34f","Both 12.34 and 12.34f"], answer:3, explanation:"12.34 is double, 12.34f is float; both are valid literals." },
{ id:"PC060", question:"Which of these is used to terminate a program in C?", options:["exit()","stop()","end()","terminate()"], answer:0, explanation:"exit() terminates the program." },
{ id:"PC061", question:"Which keyword in Java is used to prevent method overriding?", options:["static","final","const","private"], answer:1, explanation:"The final keyword prevents method overriding." },
{ id:"PC062", question:"Which of these operators has the highest precedence in C?", options:["*","==","&&","||"], answer:0, explanation:"Multiplication '*' has the highest precedence among these." },
{ id:"PC063", question:"Which of the following is true about 'do-while' loop in C++?", options:["Executes zero or more times","Executes at least once","Executes exactly once","Cannot execute"], answer:1, explanation:"do-while executes at least once before checking condition." },
{ id:"PC064", question:"Which of the following is a valid C++ class member access specifier?", options:["public","private","protected","All of these"], answer:3, explanation:"public, private, and protected are valid specifiers." },
{ id:"PC065", question:"Which method in Java must be implemented for a thread?", options:["run()","start()","main()","execute()"], answer:0, explanation:"run() method must be implemented for thread execution." },
{ id:"PC066", question:"Which of these is not a Java primitive type?", options:["int","double","String","boolean"], answer:2, explanation:"String is an object, not a primitive type." },
{ id:"PC067", question:"Which operator is used to access structure members via pointer in C?", options:["->",".","*","&"], answer:0, explanation:"The '->' operator is used with pointers to struct members." },
{ id:"PC068", question:"Which C++ header file is required for standard input/output?", options:["<iostream>","<stdio.h>","<stdlib.h>","<conio.h>"], answer:0, explanation:"<iostream> is required for cin/cout in C++." },
{ id:"PC069", question:"Which of these is the correct way to declare a constant in C++?", options:["const int x = 5;","int const x;","#define x 5","All of these"], answer:3, explanation:"All listed methods declare constants in C++." },
{ id:"PC070", question:"Which of the following is true about Java constructors?", options:["They can be overloaded","They must return int","They can be static","They can be abstract"], answer:0, explanation:"Constructors can be overloaded but cannot be static or abstract." },
{ id:"PC071", question:"Which of these is used to create a new object in Java?", options:["new","create","instantiate","object"], answer:0, explanation:"'new' keyword is used to create objects." },
{ id:"PC072", question:"Which of the following is true about Java garbage collection?", options:["Manually invoked by delete","Automatically managed","Not supported","Needs destructor"], answer:1, explanation:"Java garbage collection is automatic." },
{ id:"PC073", question:"Which of the following is a valid comment in C?", options:["// comment","/* comment */","Both","<!-- comment -->"], answer:2, explanation:"Both // and /* */ are valid comments in C." },
{ id:"PC074", question:"Which of the following is a valid escape sequence in C/C++?", options:["\\n","\\t","\\\\","All of these"], answer:3, explanation:"All listed are valid escape sequences." },
{ id:"PC075", question:"Which operator is used for equality comparison in Java?", options:["=","==","===","equals"], answer:1, explanation:"'==' compares primitive values in Java." },
{ id:"PC076", question:"Which is the default value of a boolean in Java?", options:["true","false","0","null"], answer:1, explanation:"The default value of boolean is false." },
{ id:"PC077", question:"Which of the following is not a valid data type in C?", options:["int","float","double","boolean"], answer:3, explanation:"boolean is not a standard C data type." },
{ id:"PC078", question:"Which keyword in C++ defines a friend function?", options:["friend","private","protected","public"], answer:0, explanation:"friend keyword defines friend functions." },
{ id:"PC079", question:"Which of these is a valid Java literal?", options:["123","12.34","'c'","All of these"], answer:3, explanation:"All listed are valid literals in Java." },
{ id:"PC080", question:"Which of the following is used to access the superclass constructor in Java?", options:["super","this","parent","base"], answer:0, explanation:"super keyword is used to call superclass constructor." },
{ id:"PC081", question:"Which of the following is true about C++ destructor?", options:["Has no return type","Can be overloaded","Must be static","Called manually"], answer:0, explanation:"Destructor has no return type and is called automatically." },
{ id:"PC082", question:"Which of these cannot be used as a Java identifier?", options:["$var","_var","varName","class"], answer:3, explanation:"class is a reserved keyword and cannot be an identifier." },
{ id:"PC083", question:"Which of these is true for Java abstract class?", options:["Can be instantiated","Cannot have abstract methods","Can have concrete and abstract methods","None"], answer:2, explanation:"Abstract classes can have both concrete and abstract methods." },
{ id:"PC084", question:"Which of the following is a correct array declaration in C++?", options:["int arr[10];","int arr();","array int arr;","int[] arr;"], answer:0, explanation:"int arr[10]; declares an array of size 10 in C++." },
{ id:"PC085", question:"Which of the following is correct way to declare a function pointer in C?", options:["int (*func)();","int func*();","int &func();","func int*();"], answer:0, explanation:"int (*func)() is correct function pointer declaration." },
{ id:"PC086", question:"Which of these is true about Java final keyword?", options:["Used with classes","Used with methods","Used with variables","All of these"], answer:3, explanation:"final can be used with class, method, or variable." },
{ id:"PC087", question:"Which of the following is used for standard input in C?", options:["scanf()","cin","input()","read()"], answer:0, explanation:"scanf() is used in C for standard input." },
{ id:"PC088", question:"Which operator is used for scope resolution in C++?", options:["::",".","->","?:"], answer:0, explanation:"'::' is scope resolution operator in C++." },
{ id:"PC089", question:"Which of the following is used to terminate a program in C++?", options:["exit()","stop()","terminate()","end()"], answer:0, explanation:"exit() terminates the program." },
{ id:"PC090", question:"Which of these is correct way to declare multiple variables of same type in C?", options:["int a,b,c;","int a b c;","int a; b; c;","int a,b,c()"], answer:0, explanation:"int a,b,c; declares three int variables." },
{ id:"PC091", question:"Which of these is a valid Java wrapper class?", options:["Integer","int","Float","Both Integer and Float"], answer:3, explanation:"Integer and Float are wrapper classes; int and float are primitives." },
{ id:"PC092", question:"Which of these is not a storage class in C?", options:["auto","register","mutable","static"], answer:2, explanation:"mutable is not a C storage class." },
{ id:"PC093", question:"Which of the following is true about C++ virtual function?", options:["Supports runtime polymorphism","Cannot be overridden","Must be private","Cannot return value"], answer:0, explanation:"Virtual functions enable runtime polymorphism." },
{ id:"PC094", question:"Which of these is correct way to declare constant in Java?", options:["final int x = 5;","const int x = 5;","#define x 5","int const x;"], answer:0, explanation:"final keyword declares constants in Java." },
{ id:"PC095", question:"Which is the default value of object references in Java?", options:["null","0","undefined","none"], answer:0, explanation:"Default value for object references is null." },
{ id:"PC096", question:"Which operator is used to multiply in C?", options:["*","x","%","+"], answer:0, explanation:"* is the multiplication operator in C." },
{ id:"PC097", question:"Which of the following is correct way to declare an integer array in Java?", options:["int[] arr;","int arr[];","Both","None"], answer:2, explanation:"Both int[] arr; and int arr[]; are valid." },
{ id:"PC098", question:"Which of these is true for Java method overloading?", options:["Same name, different parameter lists","Same name, same parameter list","Same name, different return type","Cannot overload methods"], answer:0, explanation:"Overloading requires different parameter lists." },
{ id:"PC099", question:"Which of these is used to deallocate memory allocated by new in C++?", options:["delete","free","dispose","remove"], answer:0, explanation:"delete frees memory allocated by new." },
{ id:"PC100", question:"Which of these is the correct syntax for a switch statement in C?", options:["switch(expr){case val: ...}","switch expr case val: ...","switch(expr) case val: ...","switch{expr case val: ...}"], answer:0, explanation:"switch(expr){case val: ...} is correct syntax." }

],
"Program Control":[
{ id:"PC101", question:"Which loop executes at least once in C/C++?", options:["for","while","do-while","None"], answer:2, explanation:"do-while loop executes at least once before checking condition." },
{ id:"PC102", question:"Which statement immediately exits a loop in C++?", options:["exit","break","continue","return"], answer:1, explanation:"break exits the nearest enclosing loop immediately." },
{ id:"PC103", question:"Which statement skips current iteration in a loop?", options:["break","continue","pass","skip"], answer:1, explanation:"continue skips the remaining code in the current iteration." },
{ id:"PC104", question:"Which loop is best when the number of iterations is known?", options:["for","while","do-while","None"], answer:0, explanation:"for loop is ideal when iterations are known." },
{ id:"PC105", question:"Which of these is recursion?", options:["Function calling itself","Loop","Nested function","None"], answer:0, explanation:"Recursion occurs when a function calls itself." },
{ id:"PC106", question:"What is the base case in recursion?", options:["Condition to terminate recursion","Initial call","Recursive function body","Function prototype"], answer:0, explanation:"The base case stops the recursion to prevent infinite calls." },
{ id:"PC107", question:"Which statement ends a function and returns a value?", options:["exit","return","break","stop"], answer:1, explanation:"return is used to exit a function and return a value." },
{ id:"PC108", question:"Which of these loops is controlled by condition checked before execution?", options:["for","while","do-while","None"], answer:1, explanation:"while loop checks condition before executing." },
{ id:"PC109", question:"Which type of recursion is when recursive call is the last statement?", options:["Tail recursion","Head recursion","Indirect recursion","Nested recursion"], answer:0, explanation:"Tail recursion has the recursive call as the last statement." },
{ id:"PC110", question:"Which type of recursion calls another function which in turn calls it back?", options:["Direct recursion","Indirect recursion","Mutual recursion","Tail recursion"], answer:1, explanation:"Indirect recursion involves two or more functions calling each other." },
{ id:"PC111", question:"Which is correct way to define a function in C?", options:["returnType funcName(parameters){ body }","func funcName(parameters){ body }","def funcName(parameters): body","function funcName(){}"], answer:0, explanation:"C uses returnType funcName(parameters){ body } syntax." },
{ id:"PC112", question:"Which of these is correct function prototype in C++?", options:["int add(int,int);","int add(a,b);","add(int,int);","function add(int,int);"], answer:0, explanation:"int add(int,int); is a valid prototype." },
{ id:"PC113", question:"Which statement jumps to a specific case in switch?", options:["case","goto","continue","break"], answer:0, explanation:"case identifies a block to execute in a switch statement." },
{ id:"PC114", question:"Which is invalid in C++ recursion?", options:["Missing base case","Infinite recursion","Mutual recursion","Tail recursion"], answer:0, explanation:"Recursion without a base case leads to infinite recursion." },
{ id:"PC115", question:"Which of these is true about function overloading in C++?", options:["Same name, different parameters","Same name, same parameters","Different name, same parameters","Not allowed"], answer:0, explanation:"Function overloading requires different parameter lists." },
{ id:"PC116", question:"Which keyword is used to return a value in Java?", options:["exit","return","break","yield"], answer:1, explanation:"return exits a method and provides a value." },
{ id:"PC117", question:"Which is correct syntax to call a function in C?", options:["func();","call func();","function func();","invoke func();"], answer:0, explanation:"func(); is the correct call syntax." },
{ id:"PC118", question:"Which loop always checks condition after executing body?", options:["for","while","do-while","None"], answer:2, explanation:"do-while loop checks condition after execution." },
{ id:"PC119", question:"Which of the following is true about nested loops?", options:["Inner loop completes all iterations per outer iteration","Inner loop runs only once","Outer loop runs only once","Cannot nest loops"], answer:0, explanation:"Inner loop runs completely for each iteration of outer loop." },
{ id:"PC120", question:"Which of the following is true about recursion in Java?", options:["Each recursive call has its own stack frame","Recursion shares same stack frame","Java does not support recursion","Recursion is memoryless"], answer:0, explanation:"Each call has its own stack frame in Java recursion." },
{ id:"PC121", question:"Which of these is used to define a function in Java?", options:["returnType funcName(parameters){ }","def funcName(parameters): { }","function funcName()","method funcName()"], answer:0, explanation:"Java functions (methods) are defined with returnType, name, and parameters." },
{ id:"PC122", question:"Which of these terminates the current iteration in Java loops?", options:["break","continue","exit","stop"], answer:1, explanation:"continue skips to next iteration." },
{ id:"PC123", question:"Which of these is true about recursion stack?", options:["LIFO order","FIFO order","Random order","Cannot predict"], answer:0, explanation:"Recursion uses LIFO stack to track calls." },
{ id:"PC124", question:"Which of these loops is suitable when number of iterations is unknown?", options:["for","while","do-while","None"], answer:1, explanation:"while loop is used when iterations are unknown." },
{ id:"PC125", question:"Which is correct way to pass parameters in C function?", options:["By value","By reference","Both","None"], answer:0, explanation:"C defaults to pass-by-value." },
{ id:"PC126", question:"Which is the correct way to return multiple values from a function in C++?", options:["Using reference parameters","Using pointers","Using structures","All of these"], answer:3, explanation:"All listed methods can return multiple values." },
{ id:"PC127", question:"Which of these is true about break in switch statement?", options:["Exits the switch","Skips iteration","Exits function","Terminates program"], answer:0, explanation:"break exits the switch block." },
{ id:"PC128", question:"Which of these loops can be infinite if condition never fails?", options:["for","while","do-while","All of these"], answer:3, explanation:"All loops can be infinite if conditions never fail." },
{ id:"PC129", question:"Which of these functions can call itself indirectly?", options:["Mutual recursion","Tail recursion","Head recursion","Iterative function"], answer:0, explanation:"Mutual recursion involves two functions calling each other." },
{ id:"PC130", question:"Which of these statements is true for function in C++?", options:["Functions can be recursive","Functions cannot be recursive","Functions must return void","Functions cannot have parameters"], answer:0, explanation:"C++ functions can call themselves recursively." },
{ id:"PC131", question:"Which statement immediately terminates a function in C/C++?", options:["return","break","exit","stop"], answer:0, explanation:"return ends function execution and optionally returns value." },
{ id:"PC132", question:"Which of these loops executes exactly n times when iterating from i=0 to i<n?", options:["for","while","do-while","Infinite loop"], answer:0, explanation:"for loop can be controlled to execute exactly n times." },
{ id:"PC133", question:"Which of these is an advantage of recursion?", options:["Simpler code for problems like factorial, Fibonacci","Faster execution","No stack usage","No base case needed"], answer:0, explanation:"Recursion simplifies implementation of problems like factorial and Fibonacci." },
{ id:"PC134", question:"Which of these is true about function parameters in Java?", options:["Passed by value","Passed by reference","Both","None"], answer:0, explanation:"Java passes parameters by value." },
{ id:"PC135", question:"Which of these is true about tail recursion?", options:["Recursive call is last statement","Recursive call is first statement","Cannot use loops","Not memory efficient"], answer:0, explanation:"Tail recursion has recursive call as the last statement." },
{ id:"PC136", question:"Which of the following is true about nested functions in C++?", options:["C++ does not support nested functions","Supported by default","Requires special keyword","Allowed only in classes"], answer:0, explanation:"C++ does not support nested functions." },
{ id:"PC137", question:"Which of these is valid syntax for recursion in Java?", options:["method calls itself","method calls another method which calls itself","Both","None"], answer:2, explanation:"Both direct and indirect recursion are valid." },
{ id:"PC138", question:"Which of these loops is used when condition is checked before loop execution?", options:["for","while","do-while","None"], answer:1, explanation:"while and for check condition before executing." },
{ id:"PC139", question:"Which of these is true about continue in loops?", options:["Skips rest of current iteration","Terminates loop","Terminates function","Stops program"], answer:0, explanation:"continue skips rest of current iteration." },
{ id:"PC140", question:"Which of these is true about return in C/C++?", options:["Returns control to caller","Can return value","Both","None"], answer:2, explanation:"return returns control and optionally value." },
{ id:"PC141", question:"Which loop executes zero or more times in C?", options:["for","while","do-while","None"], answer:0, explanation:"for can execute zero times if initial condition fails." },
{ id:"PC142", question:"Which of these is true about recursion memory usage?", options:["Uses call stack","Does not use stack","Uses heap","None"], answer:0, explanation:"Recursion uses call stack to store function calls." },
{ id:"PC143", question:"Which of these is true about function overloading in C++?", options:["Same function name, different parameters","Different function name, same parameters","Cannot overload","Overloading changes return type"], answer:0, explanation:"Overloading requires same name, different parameters." },
{ id:"PC144", question:"Which of these loops executes at least once regardless of condition?", options:["for","while","do-while","None"], answer:2, explanation:"do-while executes at least once." },
{ id:"PC145", question:"Which of these is used to call a function in C++?", options:["func();","call func();","execute func();","run func();"], answer:0, explanation:"func(); is the standard call." },
{ id:"PC146", question:"Which of these is true about infinite recursion?", options:["Leads to stack overflow","Executes normally","Consumes heap only","Safe to use"], answer:0, explanation:"Infinite recursion causes stack overflow." },
{ id:"PC147", question:"Which of these statements is valid in Java for function call?", options:["obj.method();","method.obj();","call method();","method.call();"], answer:0, explanation:"obj.method() is valid for instance methods." },
{ id:"PC148", question:"Which of these loops is best when number of iterations is unknown?", options:["for","while","do-while","None"], answer:1, explanation:"while loop is best when iterations are unknown." },
{ id:"PC149", question:"Which statement is used to skip remaining code in iteration in C/C++?", options:["break","continue","return","stop"], answer:1, explanation:"continue skips remaining code in current iteration." },
{ id:"PC150", question:"Which of these is true about function stack frame?", options:["Stores parameters, return address, local variables","Stores only parameters","Stores only local variables","None"], answer:0, explanation:"Stack frame stores parameters, return address, and local variables." },
{ id:"PC151", question:"Which of these is true about recursive function calls in C++?", options:["Each call has its own local variables","All calls share same variables","Recursion is impossible in C++","Recursion is memoryless"], answer:0, explanation:"Each recursive call has its own local variables stored in stack." },
{ id:"PC152", question:"Which of these is valid in Java for recursion?", options:["A method calling itself","A method calling another method which calls it","Both","None"], answer:2, explanation:"Both direct and indirect recursion are valid in Java." },
{ id:"PC153", question:"Which loop executes at least once in Java?", options:["for","while","do-while","None"], answer:2, explanation:"do-while loop executes at least once." },
{ id:"PC154", question:"Which of these statements exits the current loop iteration in Java?", options:["break","continue","exit","stop"], answer:1, explanation:"continue skips the rest of the current iteration." },
{ id:"PC155", question:"Which of these is true about function parameters in C++?", options:["Default is pass by value","Default is pass by reference","Always pass by pointer","Cannot pass parameters"], answer:0, explanation:"C++ passes parameters by value by default." },
{ id:"PC156", question:"Which of these is an advantage of tail recursion?", options:["Optimized stack usage","Faster execution","Cannot be optimized","Consumes more memory"], answer:0, explanation:"Tail recursion can be optimized to avoid extra stack frames." },
{ id:"PC157", question:"Which of these is true about break in nested loops?", options:["Exits innermost loop only","Exits all loops","Skips iteration","Terminates program"], answer:0, explanation:"break exits only the innermost enclosing loop." },
{ id:"PC158", question:"Which is correct syntax to define a function returning integer in C?", options:["int func(){ }","func int(){ }","return int func(){ }","int return func(){ }"], answer:0, explanation:"int func(){ } defines a function returning int." },
{ id:"PC159", question:"Which of these loops is ideal when iterations are unknown and condition is checked first?", options:["for","while","do-while","None"], answer:1, explanation:"while loop checks condition before execution." },
{ id:"PC160", question:"Which of these statements is true about recursive calls in Java?", options:["Each call is stored in stack","All share same frame","Java does not support recursion","Recursion uses heap"], answer:0, explanation:"Each recursive call has its own stack frame." },
{ id:"PC161", question:"Which keyword can be used to declare default arguments in C++ functions?", options:["default","=","const","final"], answer:1, explanation:"Default arguments are specified using '=' in function declaration." },
{ id:"PC162", question:"Which of these is correct for infinite loop in C?", options:["for(;;)","while(1)","do {} while(1)","All of these"], answer:3, explanation:"All listed forms create an infinite loop." },
{ id:"PC163", question:"Which of these statements skips the rest of current iteration in C++?", options:["break","continue","return","exit"], answer:1, explanation:"continue skips remaining code in current iteration." },
{ id:"PC164", question:"Which is true for recursion in C++ regarding termination?", options:["Must have base case","Can omit base case","Recursion always terminates","None"], answer:0, explanation:"Base case is required to terminate recursion." },
{ id:"PC165", question:"Which is correct syntax for a switch statement in Java?", options:["switch(expr){ case val: ... }","switch expr case val: ...","switch(expr) case val: ...","switch{expr case val: ... }"], answer:0, explanation:"switch(expr){ case val: ... } is correct syntax." },
{ id:"PC166", question:"Which of these loops is executed zero or more times in C++?", options:["for","while","do-while","None"], answer:0, explanation:"for loop may execute zero times if initial condition fails." },
{ id:"PC167", question:"Which is true about recursive functions in C++?", options:["Must call themselves directly","Must have base case","Cannot call other functions","Cannot return value"], answer:1, explanation:"Recursive functions must have a base case to terminate." },
{ id:"PC168", question:"Which statement in Java immediately exits a method?", options:["break","return","continue","stop"], answer:1, explanation:"return exits the current method." },
{ id:"PC169", question:"Which of these is valid for passing multiple values from a function in C++?", options:["Reference parameters","Pointer parameters","Structs","All of these"], answer:3, explanation:"All listed approaches can be used." },
{ id:"PC170", question:"Which of these is used to iterate a known number of times?", options:["for loop","while loop","do-while loop","if statement"], answer:0, explanation:"for loop is ideal for known iteration counts." },
{ id:"PC171", question:"Which of these is true about recursion stack?", options:["Uses LIFO","Uses FIFO","Random","None"], answer:0, explanation:"Recursion uses LIFO order." },
{ id:"PC172", question:"Which of these statements is used to terminate the nearest enclosing loop?", options:["break","continue","return","exit"], answer:0, explanation:"break exits the nearest enclosing loop." },
{ id:"PC173", question:"Which of these statements skips remaining iteration code in Java?", options:["break","continue","return","stop"], answer:1, explanation:"continue skips current iteration." },
{ id:"PC174", question:"Which of these is true about recursive function in Java?", options:["Each call has unique stack frame","Calls share stack frame","Cannot use recursion","Recursion is not allowed"], answer:0, explanation:"Each call has a unique stack frame." },
{ id:"PC175", question:"Which of these loops executes at least once even if condition is false?", options:["for","while","do-while","None"], answer:2, explanation:"do-while executes at least once." },
{ id:"PC176", question:"Which of these is true about break inside switch-case?", options:["Exits switch","Exits loop","Skips iteration","Terminates program"], answer:0, explanation:"break exits switch block." },
{ id:"PC177", question:"Which of these is correct function call in C++?", options:["func();","call func();","execute func();","invoke func();"], answer:0, explanation:"func(); is correct syntax." },
{ id:"PC178", question:"Which of these is true about default parameters in C++?", options:["Can be omitted in call","Must be supplied","Not supported","Always required"], answer:0, explanation:"Default parameters may be omitted when calling the function." },
{ id:"PC179", question:"Which is true for nested loops in C++?", options:["Inner loop completes all iterations per outer loop iteration","Inner loop runs once","Outer loop runs once","Cannot nest"], answer:0, explanation:"Inner loop executes completely for each outer iteration." },
{ id:"PC180", question:"Which of these is true for recursion memory consumption?", options:["Consumes stack","Consumes heap","No memory","Consumes registers only"], answer:0, explanation:"Recursion consumes stack memory for each call." },
{ id:"PC181", question:"Which of these is true for a function returning void?", options:["Cannot return value","Can return value","Must return int","Must return float"], answer:0, explanation:"Void functions cannot return a value." },
{ id:"PC182", question:"Which of these is true about tail recursion optimization?", options:["Reduces stack usage","Increases stack usage","Not allowed","Slower"], answer:0, explanation:"Tail recursion can be optimized to reuse stack frames." },
{ id:"PC183", question:"Which of these is true about recursion in general?", options:["Simplifies certain problems","Always faster than loops","Uses no memory","Cannot be used"], answer:0, explanation:"Recursion simplifies some problems like factorial and tree traversal." },
{ id:"PC184", question:"Which of these loops is best for unknown iteration counts?", options:["while","for","do-while","None"], answer:0, explanation:"while loop is best when number of iterations is unknown." },
{ id:"PC185", question:"Which of these is true about continue in loops?", options:["Skips current iteration","Exits loop","Terminates function","Stops program"], answer:0, explanation:"continue skips remaining code in current iteration." },
{ id:"PC186", question:"Which of these is true about base case in recursion?", options:["Prevents infinite recursion","Optional","Recursion cannot terminate without it","Both A and C"], answer:3, explanation:"Base case prevents infinite recursion and ensures termination." },
{ id:"PC187", question:"Which of these is true for function call stack in C++?", options:["Stores local variables, parameters, return address","Stores only local variables","Stores only parameters","Stores nothing"], answer:0, explanation:"Stack frame stores local variables, parameters, and return address." },
{ id:"PC188", question:"Which of these is true for mutually recursive functions?", options:["Two functions calling each other","Function calling itself","Cannot exist","Only for Java"], answer:0, explanation:"Mutual recursion occurs when two functions call each other." },
{ id:"PC189", question:"Which statement is used to terminate function execution in C/C++?", options:["return","break","continue","stop"], answer:0, explanation:"return terminates function execution." },
{ id:"PC190", question:"Which of these is true for function overloading?", options:["Same name, different parameters","Different name, same parameters","Cannot overload","Overload changes return type"], answer:0, explanation:"Overloading requires same name and different parameters." },
{ id:"PC191", question:"Which is true about recursion stack frames?", options:["Each call has its own frame","All calls share one frame","Uses heap","Uses global memory"], answer:0, explanation:"Each recursive call has its own stack frame." },
{ id:"PC192", question:"Which of these loops may never execute if condition fails initially?", options:["for","while","do-while","None"], answer:0, explanation:"for loop may not execute if initial condition fails." },
{ id:"PC193", question:"Which of these is true about return in Java?", options:["Exits method and optionally returns value","Only exits method","Exits loop","Exits program"], answer:0, explanation:"return exits the method and optionally returns a value." },
{ id:"PC194", question:"Which of these is true for infinite loop prevention in recursion?", options:["Always provide base case","Recursion never ends","No need base case","Use while loop instead"], answer:0, explanation:"Base case prevents infinite recursion." },
{ id:"PC195", question:"Which is correct in C++ to define a function with no parameters?", options:["void func()","void func(void)","Both","None"], answer:2, explanation:"Both void func() and void func(void) are valid." },
{ id:"PC196", question:"Which of these is true for while loop in C++?", options:["Condition checked before execution","Executes at least once","Condition checked after execution","Cannot execute"], answer:0, explanation:"while loop checks condition before executing." },
{ id:"PC197", question:"Which of these is true about nested recursion?", options:["A recursive function calls itself with another recursive call","Function calls itself once","Cannot exist","Only in Java"], answer:0, explanation:"Nested recursion involves recursive calls inside other recursive calls." },
{ id:"PC198", question:"Which statement is used to skip current iteration in Java loop?", options:["continue","break","return","exit"], answer:0, explanation:"continue skips current iteration." },
{ id:"PC199", question:"Which is true about recursion in general?", options:["Can simplify problem-solving","Always uses less memory","Faster than loops","Cannot use with loops"], answer:0, explanation:"Recursion can simplify complex problems like tree traversal." },
{ id:"PC200", question:"Which of these is true for return type in C++ function?", options:["Must match declared type","Can differ","Always void","Can differ for recursion"], answer:0, explanation:"Return value must match declared function type." },
{ id:"PC201", question:"Which of these loops can execute zero times if initial condition fails?", options:["for","while","do-while","All"], answer:0, explanation:"for loop may execute zero times if initialization condition fails." },
{ id:"PC202", question:"Which statement exits only the innermost loop in C++?", options:["break","continue","return","exit"], answer:0, explanation:"break exits only the innermost loop." },
{ id:"PC203", question:"Which of these statements skips remaining iteration code in C/C++?", options:["break","continue","return","stop"], answer:1, explanation:"continue skips the rest of the current iteration." },
{ id:"PC204", question:"Which of these is true for nested loops?", options:["Inner loop executes fully per outer iteration","Inner loop executes once","Outer loop executes once","Cannot nest loops"], answer:0, explanation:"Inner loop completes all iterations for each outer loop iteration." },
{ id:"PC205", question:"Which is true about recursion base case?", options:["Prevents infinite recursion","Optional","Not required","Always first line"], answer:0, explanation:"Base case ensures recursion terminates." },
{ id:"PC206", question:"Which is true for mutual recursion?", options:["Two functions call each other","Function calls itself","Not allowed in C","Only in Java"], answer:0, explanation:"Mutual recursion involves two functions calling each other." },
{ id:"PC207", question:"Which of these is true for tail recursion optimization?", options:["Reduces stack usage","Increases stack usage","Not allowed","Slower"], answer:0, explanation:"Tail recursion can be optimized to reuse stack frames." },
{ id:"PC208", question:"Which of these is true for function overloading in C++?", options:["Same name, different parameters","Different name, same parameters","Overloading not allowed","Changes return type"], answer:0, explanation:"Function overloading requires same name and different parameter lists." },
{ id:"PC209", question:"Which of these is true about recursive call stack?", options:["LIFO order","FIFO order","Random","None"], answer:0, explanation:"Recursive calls are stored in LIFO order." },
{ id:"PC210", question:"Which of these is true about function parameters in Java?", options:["Passed by value","Passed by reference","Always pointer","Cannot pass"], answer:0, explanation:"Java passes parameters by value (primitives) and reference (objects) semantics." },
{ id:"PC211", question:"Which is correct syntax for a function returning void in C++?", options:["void func()","void func(void)","Both","None"], answer:2, explanation:"Both void func() and void func(void) are valid." },
{ id:"PC212", question:"Which of these is true about infinite loop prevention in recursion?", options:["Always provide base case","Recursion never ends","No base case needed","Use loops instead"], answer:0, explanation:"Base case prevents infinite recursion." },
{ id:"PC213", question:"Which of these statements immediately terminates a function in C++?", options:["return","break","continue","exit"], answer:0, explanation:"return terminates function execution and optionally returns a value." },
{ id:"PC214", question:"Which of these loops executes at least once regardless of condition?", options:["for","while","do-while","None"], answer:2, explanation:"do-while executes at least once." },
{ id:"PC215", question:"Which of these is true for nested recursion?", options:["Recursive function calls itself inside another recursive call","Calls itself once","Cannot exist","Only in Java"], answer:0, explanation:"Nested recursion occurs when a recursive call is inside another recursive call." },
{ id:"PC216", question:"Which of these is true for break in nested switch or loops?", options:["Exits current block only","Exits all blocks","Skips iteration","Terminates program"], answer:0, explanation:"break exits the nearest enclosing loop or switch." },
{ id:"PC217", question:"Which is true about continue in nested loops?", options:["Skips current iteration of innermost loop","Exits all loops","Terminates function","Stops program"], answer:0, explanation:"continue affects only the innermost loop." },
{ id:"PC218", question:"Which of these loops is best for known number of iterations?", options:["for","while","do-while","None"], answer:0, explanation:"for loop is ideal when iteration count is known." },
{ id:"PC219", question:"Which of these loops is best when iteration count is unknown?", options:["for","while","do-while","None"], answer:1, explanation:"while loop is suitable for unknown iteration counts." },
{ id:"PC220", question:"Which of these is true about recursion memory usage?", options:["Uses call stack","Uses heap","No memory","Uses registers only"], answer:0, explanation:"Recursion uses call stack for each function call." },
{ id:"PC221", question:"Which of these is true about function return type?", options:["Must match declared type","Can differ","Always void","Can differ for recursion"], answer:0, explanation:"Return value must match declared type." },
{ id:"PC222", question:"Which is true about default function parameters in C++?", options:["Can be omitted in call","Must be supplied","Not supported","Always required"], answer:0, explanation:"Default parameters may be omitted in the function call." },
{ id:"PC223", question:"Which of these is true about recursion efficiency?", options:["May consume more stack","Always faster than loops","No stack usage","No effect"], answer:0, explanation:"Recursion may consume more stack and memory." },
{ id:"PC224", question:"Which of these is true about recursive Fibonacci implementation?", options:["Exponential time complexity","Linear time","Constant time","Impossible"], answer:0, explanation:"Naive recursive Fibonacci has exponential complexity." },
{ id:"PC225", question:"Which of these is true for function scope in C++?", options:["Local variables accessible only inside function","Local variables accessible globally","All variables are global","Cannot define local variables"], answer:0, explanation:"Local variables are accessible only inside their function." },
{ id:"PC226", question:"Which of these is true about recursion termination?", options:["Base case required","Optional","Recursion always terminates","Cannot terminate"], answer:0, explanation:"Base case is required for recursion to terminate." },
{ id:"PC227", question:"Which of these statements correctly defines a function in Java?", options:["returnType funcName(parameters) { }","def funcName(parameters): { }","function funcName() { }","method funcName() { }"], answer:0, explanation:"Java methods are defined with returnType, name, and parameters." },
{ id:"PC228", question:"Which of these is true about return in Java?", options:["Exits method and optionally returns value","Only exits loop","Exits function without value","Exits program"], answer:0, explanation:"return exits method and optionally returns a value." },
{ id:"PC229", question:"Which of these is true about recursion depth in C++?", options:["Limited by stack size","Unlimited","No limit in heap","Cannot recur"], answer:0, explanation:"Recursion depth is limited by stack size." },
{ id:"PC230", question:"Which of these is true about recursive function parameters?", options:["Each call gets its own copy","All calls share parameters","Cannot pass parameters","Parameters are global"], answer:0, explanation:"Each recursive call gets its own copy of parameters." },
{ id:"PC231", question:"Which of these statements is used to exit the nearest enclosing loop in C/C++?", options:["break","continue","return","exit"], answer:0, explanation:"break exits the nearest loop." },
{ id:"PC232", question:"Which of these is true for static local variables in recursion?", options:["Value persists across calls","Reinitialized each call","Cannot declare static","Always global"], answer:0, explanation:"Static local variable retains value across recursive calls." },
{ id:"PC233", question:"Which of these is true for while loop execution?", options:["Condition checked before execution","Executes at least once","Condition checked after execution","Cannot execute"], answer:0, explanation:"while loop checks condition before execution." },
{ id:"PC234", question:"Which is true for do-while loop in C++?", options:["Executes at least once","May execute zero times","Cannot execute","Executes only once"], answer:0, explanation:"do-while executes at least once regardless of condition." },
{ id:"PC235", question:"Which of these is true about infinite loops in C++?", options:["May occur if condition never fails","Cannot occur","Always terminates","Illegal"], answer:0, explanation:"Infinite loops can occur if loop condition never becomes false." },
{ id:"PC236", question:"Which of these is true about recursion and stack overflow?", options:["Infinite recursion may cause stack overflow","Recursion never causes stack issues","Always safe","Only in Java"], answer:0, explanation:"Excessive recursion without base case causes stack overflow." },
{ id:"PC237", question:"Which of these statements skips current iteration in Java loops?", options:["continue","break","return","exit"], answer:0, explanation:"continue skips current iteration." },
{ id:"PC238", question:"Which of these is true for nested loops break?", options:["Exits innermost loop","Exits all loops","Skips iteration","Terminates program"], answer:0, explanation:"break exits innermost loop only." },
{ id:"PC239", question:"Which of these is true for tail recursion?", options:["Recursive call is last statement","Recursive call is first statement","Cannot optimize","Slower than loops"], answer:0, explanation:"Tail recursion has the recursive call as last statement and can be optimized." },
{ id:"PC240", question:"Which of these is true about recursion vs iteration?", options:["Recursion can be simpler for problems like tree traversal","Recursion always faster","Recursion never uses stack","Recursion is iterative"], answer:0, explanation:"Recursion simplifies some problems, though not always faster." },
{ id:"PC241", question:"Which of these is true about function calls in C++?", options:["Uses stack for each call","Uses heap for each call","No memory used","Uses global memory"], answer:0, explanation:"Each function call uses stack memory." },
{ id:"PC242", question:"Which of these is true for break in switch-case?", options:["Exits switch","Exits loop","Skips iteration","Terminates program"], answer:0, explanation:"break exits switch block." },
{ id:"PC243", question:"Which of these is correct to call a function with no parameters in C++?", options:["func();","func(void);","Both","None"], answer:2, explanation:"Both func(); and func(void); are valid." },
{ id:"PC244", question:"Which of these is true for continue in nested loops?", options:["Affects innermost loop only","Exits all loops","Terminates program","Skips function"], answer:0, explanation:"continue affects only the innermost loop." },
{ id:"PC245", question:"Which of these is true for mutual recursion?", options:["Two functions call each other","Function calls itself","Cannot exist","Only in Java"], answer:0, explanation:"Mutual recursion involves two functions calling each other." },
{ id:"PC246", question:"Which is true for recursive factorial implementation?", options:["Uses recursion","Can be implemented iteratively","Both","None"], answer:2, explanation:"Factorial can be implemented recursively or iteratively." },
{ id:"PC247", question:"Which of these statements exits only current iteration in C++?", options:["continue","break","return","exit"], answer:0, explanation:"continue skips current iteration." },
{ id:"PC248", question:"Which of these is true for recursion termination?", options:["Requires base case","Optional","Not needed","Never terminates"], answer:0, explanation:"Base case is required to terminate recursion." },
{ id:"PC249", question:"Which of these is true for local variables in recursion?", options:["Each call gets its own copy","All calls share same","Cannot declare local","Always global"], answer:0, explanation:"Each recursive call has its own local variables." },
{ id:"PC250", question:"Which is true for loops and recursion in program control?", options:["Both control execution flow","Only loops control flow","Only recursion controls flow","Neither controls flow"], answer:0, explanation:"Both loops and recursion control program execution flow." }
],
"Variables & Binding":[
{ id:"SV01", question:"Which variable is accessible throughout the entire program?", options:["Local","Block","Global","Static local"], answer:2, explanation:"Global variables are accessible throughout the program." },
{ id:"SV02", question:"The scope of a local variable is:", options:["Entire program","Within the function","Within the class","Within the file"], answer:1, explanation:"Local variables are accessible only inside the function where declared." },
{ id:"SV03", question:"Block scope in C/C++ refers to variables declared:", options:["Inside loops or braces","Inside functions only","Globally","Inside classes"], answer:0, explanation:"Block-scoped variables exist only within {}." },
{ id:"SV04", question:"Which keyword restricts variable scope to a file in C/C++?", options:["extern","static","register","volatile"], answer:1, explanation:"static at global level restricts scope to the file." },
{ id:"SV05", question:"In Java, instance variables have scope:", options:["Method","Object","Class","Package"], answer:1, explanation:"Instance variables belong to objects." },

{ id:"SV06", question:"Which variable retains its value between function calls?", options:["Local","Static local","Global","Auto"], answer:1, explanation:"Static local variables retain value across calls." },
{ id:"SV07", question:"Which of these has the smallest scope?", options:["Global","Local","Block","Static"], answer:2, explanation:"Block scope is the smallest." },
{ id:"SV08", question:"Which variable is stored in stack memory?", options:["Global","Static","Local","Extern"], answer:2, explanation:"Local variables are stored in stack." },
{ id:"SV09", question:"Which keyword allows access to a global variable defined in another file?", options:["static","extern","register","volatile"], answer:1, explanation:"extern allows cross-file access." },
{ id:"SV10", question:"In Java, local variables must be:", options:["Initialized automatically","Initialized before use","Static","Public"], answer:1, explanation:"Java local variables must be initialized." },

{ id:"SV11", question:"Which scope applies to variables declared inside a class in Java?", options:["Block","Method","Instance/Class","File"], answer:2, explanation:"Class and instance variables belong to class scope." },
{ id:"SV12", question:"Which variable exists as long as the program runs?", options:["Local","Block","Global","Register"], answer:2, explanation:"Global variables exist for entire program duration." },
{ id:"SV13", question:"Which scope is limited to a loop body?", options:["Local","Block","Global","Static"], answer:1, explanation:"Loop variables have block scope." },
{ id:"SV14", question:"What happens if a local variable hides a global variable?", options:["Error","Global inaccessible","Both accessible","Compiler warning only"], answer:1, explanation:"Local variable shadows the global variable." },
{ id:"SV15", question:"Which is NOT a scope type?", options:["Global","Local","Dynamic","Block"], answer:2, explanation:"Dynamic is not a scope type." },

{ id:"SV16", question:"In C, default storage class for local variables is:", options:["static","extern","auto","register"], answer:2, explanation:"auto is the default storage class." },
{ id:"SV17", question:"Which variable scope is determined at compile time?", options:["Dynamic","Static","Runtime","Heap"], answer:1, explanation:"Static scope is compile-time." },
{ id:"SV18", question:"In Java, class variables are declared using:", options:["static","final","public","volatile"], answer:0, explanation:"static defines class variables." },
{ id:"SV19", question:"Which scope applies to parameters of a function?", options:["Global","Local","Block","File"], answer:1, explanation:"Function parameters are local to the function." },
{ id:"SV20", question:"Which of these variables are shared among all objects in Java?", options:["Instance","Local","Static","Block"], answer:2, explanation:"Static variables are shared." },

{ id:"SV21", question:"Which variable scope helps in data hiding?", options:["Global","Public","Local","Static"], answer:2, explanation:"Local scope improves data hiding." },
{ id:"SV22", question:"Which variable cannot be accessed outside its function?", options:["Global","Static","Local","Extern"], answer:2, explanation:"Local variables are function-scoped." },
{ id:"SV23", question:"In C++, scope resolution operator is used to access:", options:["Local","Global","Block","Register"], answer:1, explanation:":: accesses global variables when shadowed." },
{ id:"SV24", question:"Which scope exists only within a pair of braces?", options:["Local","Block","Global","Static"], answer:1, explanation:"Block scope exists inside {}." },
{ id:"SV25", question:"Which variable type has file-level scope?", options:["Local","Global static","Register","Auto"], answer:1, explanation:"Static global variables have file scope." },

{ id:"SV26", question:"Which scope is most restrictive?", options:["Global","Class","Function","Block"], answer:3, explanation:"Block scope is most restrictive." },
{ id:"SV27", question:"Which variable scope improves modularity?", options:["Global","Local","Extern","Register"], answer:1, explanation:"Local scope improves modularity." },
{ id:"SV28", question:"Which variable is destroyed after function execution?", options:["Static","Global","Local","Extern"], answer:2, explanation:"Local variables are destroyed after function exits." },
{ id:"SV29", question:"Which of these scopes applies to variables inside switch cases?", options:["Function","Block","Global","Class"], answer:1, explanation:"Variables inside switch cases have block scope." },
{ id:"SV30", question:"Which of these is a Java block scope variable?", options:["Instance","Static","Loop variable","Class variable"], answer:2, explanation:"Loop variables have block scope." },

{ id:"SV31", question:"Which scope prevents name conflicts?", options:["Global","Local","Extern","Public"], answer:1, explanation:"Local scope reduces name conflicts." },
{ id:"SV32", question:"Which variable exists in memory even after function returns?", options:["Local","Block","Static local","Auto"], answer:2, explanation:"Static local variables persist." },
{ id:"SV33", question:"Which scope is applicable to lambda variables in Java?", options:["Global","Local","Effectively final","Static"], answer:2, explanation:"Lambda uses effectively final variables." },
{ id:"SV34", question:"Which scope applies to enum constants?", options:["Block","Function","Class","Local"], answer:2, explanation:"Enum constants belong to class scope." },
{ id:"SV35", question:"Which variable scope is least secure?", options:["Local","Block","Global","Static"], answer:2, explanation:"Global scope is least secure." },

{ id:"SV36", question:"Which keyword restricts scope within the same file?", options:["extern","static","auto","register"], answer:1, explanation:"static restricts file-level scope." },
{ id:"SV37", question:"Which scope applies to variables declared in header files?", options:["Local","Global","Block","Function"], answer:1, explanation:"Header variables are global unless static." },
{ id:"SV38", question:"Which scope applies to method variables in Java?", options:["Class","Local","Block","Package"], answer:1, explanation:"Method variables are local." },
{ id:"SV39", question:"Which variable has both local scope and static lifetime?", options:["Local","Static local","Global","Register"], answer:1, explanation:"Static local variables have local scope but static lifetime." },
{ id:"SV40", question:"Which of these is NOT affected by scope rules?", options:["Variable","Function","Object","Keyword"], answer:3, explanation:"Keywords are language-defined." },

{ id:"SV41", question:"Which scope applies to variables declared inside try block?", options:["Local","Block","Function","Class"], answer:1, explanation:"try block creates block scope." },
{ id:"SV42", question:"Which variable scope is resolved using :: in C++?", options:["Local","Global","Block","Static"], answer:1, explanation:":: resolves global scope." },
{ id:"SV43", question:"Which scope allows maximum accessibility?", options:["Block","Local","Class","Global"], answer:3, explanation:"Global scope allows maximum accessibility." },
{ id:"SV44", question:"Which of these is Javas default scope for class members?", options:["private","public","protected","package-private"], answer:3, explanation:"Default access is package-private." },
{ id:"SV45", question:"Which scope rule applies in both C++ and Java?", options:["Dynamic","Static","Runtime","Heap"], answer:1, explanation:"Both use static (lexical) scoping." },

{ id:"SV46", question:"Which variable scope is evaluated at compile time?", options:["Dynamic","Static","Heap","Runtime"], answer:1, explanation:"Static scope is compile-time." },
{ id:"SV47", question:"Which variable scope is safest for multithreading?", options:["Global","Local","Static","Extern"], answer:1, explanation:"Local variables are thread-safe." },
{ id:"SV48", question:"Which scope applies to variables declared in main()?", options:["Global","Local","Block","Class"], answer:1, explanation:"Variables in main() are local." },
{ id:"SV49", question:"Which scope is limited to a single iteration of loop?", options:["Local","Block","Global","Static"], answer:1, explanation:"Loop variables have block scope." },
{ id:"SV50", question:"Which scope helps avoid unintended side effects?", options:["Global","Local","Extern","Static"], answer:1, explanation:"Local scope avoids side effects." },
{ id:"BV01", question:"Binding refers to:", options:["Memory allocation","Association between name and entity","Compilation","Execution"], answer:1, explanation:"Binding is the association of a name with its attribute (value, type, memory)." },
{ id:"BV02", question:"Which binding occurs at compile time?", options:["Dynamic","Static","Late","Runtime"], answer:1, explanation:"Static binding occurs at compile time." },
{ id:"BV03", question:"Which binding occurs at runtime?", options:["Static","Early","Dynamic","Compile"], answer:2, explanation:"Dynamic binding occurs at runtime." },
{ id:"BV04", question:"In C, binding of variable type happens at:", options:["Runtime","Compile time","Link time","Execution end"], answer:1, explanation:"C uses static typing; type binding is compile-time." },
{ id:"BV05", question:"Which language supports dynamic method binding?", options:["C","C++","Java","Assembly"], answer:2, explanation:"Java supports dynamic method binding via runtime polymorphism." },

{ id:"BV06", question:"Which binding improves execution speed?", options:["Dynamic","Late","Static","Heap"], answer:2, explanation:"Static binding is faster as its resolved at compile time." },
{ id:"BV07", question:"Function overloading uses which binding?", options:["Dynamic","Static","Late","Runtime"], answer:1, explanation:"Function overloading is resolved at compile time (static binding)." },
{ id:"BV08", question:"Function overriding uses which binding in Java?", options:["Static","Compile","Dynamic","Early"], answer:2, explanation:"Method overriding uses dynamic binding." },
{ id:"BV09", question:"Which keyword enforces early binding in Java?", options:["static","virtual","final","abstract"], answer:2, explanation:"final methods cannot be overridden, so binding is static." },
{ id:"BV10", question:"Which binding depends on object type at runtime?", options:["Static","Compile","Dynamic","Early"], answer:2, explanation:"Dynamic binding depends on runtime object type." },

{ id:"BV11", question:"Which binding is used with virtual functions in C++?", options:["Static","Dynamic","Compile","Early"], answer:1, explanation:"Virtual functions use dynamic binding." },
{ id:"BV12", question:"Which binding is used by default in C++?", options:["Dynamic","Static","Late","Runtime"], answer:1, explanation:"C++ uses static binding by default." },
{ id:"BV13", question:"Which binding occurs before execution?", options:["Dynamic","Runtime","Static","Late"], answer:2, explanation:"Static binding occurs before execution." },
{ id:"BV14", question:"Which binding allows polymorphism?", options:["Static","Dynamic","Early","Compile"], answer:1, explanation:"Dynamic binding enables runtime polymorphism." },
{ id:"BV15", question:"Which binding is memory efficient?", options:["Dynamic","Late","Static","Heap"], answer:2, explanation:"Static binding avoids runtime lookup overhead." },

{ id:"BV16", question:"Which binding resolves method call using reference type?", options:["Dynamic","Static","Late","Runtime"], answer:1, explanation:"Static binding depends on reference type." },
{ id:"BV17", question:"Which binding resolves method call using object type?", options:["Static","Compile","Dynamic","Early"], answer:2, explanation:"Dynamic binding uses object type." },
{ id:"BV18", question:"In Java, static methods use:", options:["Dynamic binding","Late binding","Static binding","Virtual binding"], answer:2, explanation:"Static methods are bound at compile time." },
{ id:"BV19", question:"Which binding is associated with overloading?", options:["Dynamic","Runtime","Static","Late"], answer:2, explanation:"Overloading is resolved at compile time." },
{ id:"BV20", question:"Which binding is associated with overriding?", options:["Static","Compile","Dynamic","Early"], answer:2, explanation:"Overriding uses dynamic binding." },

{ id:"BV21", question:"Which binding allows method call flexibility?", options:["Static","Early","Dynamic","Compile"], answer:2, explanation:"Dynamic binding allows flexible method resolution." },
{ id:"BV22", question:"Which binding occurs when variable name is linked to memory?", options:["Name binding","Type binding","Value binding","Storage binding"], answer:3, explanation:"Storage binding links variable to memory location." },
{ id:"BV23", question:"Binding of variable value happens at:", options:["Compile","Runtime","Link","Load"], answer:1, explanation:"Value binding occurs at runtime." },
{ id:"BV24", question:"Which binding occurs during linking?", options:["Type","Name","Storage","Late"], answer:2, explanation:"Storage binding may occur during linking." },
{ id:"BV25", question:"Which binding is common in interpreted languages?", options:["Static","Early","Dynamic","Compile"], answer:2, explanation:"Interpreted languages use dynamic binding." },

{ id:"BV26", question:"Which binding supports late decision making?", options:["Static","Dynamic","Compile","Early"], answer:1, explanation:"Dynamic binding allows late decisions." },
{ id:"BV27", question:"Which binding increases runtime overhead?", options:["Static","Early","Dynamic","Compile"], answer:2, explanation:"Dynamic binding incurs runtime lookup cost." },
{ id:"BV28", question:"Which binding is safer for large systems?", options:["Dynamic","Static","Late","Runtime"], answer:1, explanation:"Static binding reduces runtime errors." },
{ id:"BV29", question:"Which binding is used in C function calls?", options:["Dynamic","Late","Static","Virtual"], answer:2, explanation:"C uses static binding." },
{ id:"BV30", question:"Which binding cannot support polymorphism?", options:["Dynamic","Late","Static","Runtime"], answer:2, explanation:"Static binding does not support runtime polymorphism." },

{ id:"BV31", question:"Which binding improves maintainability?", options:["Static","Dynamic","Early","Compile"], answer:1, explanation:"Dynamic binding improves flexibility and maintainability." },
{ id:"BV32", question:"Which binding resolves calls using v-table in C++?", options:["Static","Compile","Dynamic","Early"], answer:2, explanation:"Virtual table supports dynamic binding." },
{ id:"BV33", question:"Which binding is decided by compiler?", options:["Dynamic","Runtime","Static","Late"], answer:2, explanation:"Compiler decides static binding." },
{ id:"BV34", question:"Which binding depends on inheritance hierarchy?", options:["Static","Compile","Dynamic","Early"], answer:2, explanation:"Dynamic binding depends on inheritance." },
{ id:"BV35", question:"Which binding uses method signature only?", options:["Dynamic","Static","Late","Runtime"], answer:1, explanation:"Static binding uses method signature." },

{ id:"BV36", question:"Which binding applies to final methods in Java?", options:["Dynamic","Runtime","Static","Late"], answer:2, explanation:"Final methods use static binding." },
{ id:"BV37", question:"Which binding is resolved during execution?", options:["Compile","Static","Dynamic","Early"], answer:2, explanation:"Dynamic binding occurs during execution." },
{ id:"BV38", question:"Which binding occurs when variable scope is resolved?", options:["Name binding","Storage binding","Type binding","Dynamic binding"], answer:0, explanation:"Name binding associates identifier with entity." },
{ id:"BV39", question:"Which binding is fixed once assigned?", options:["Dynamic","Late","Static","Runtime"], answer:2, explanation:"Static binding is fixed once assigned." },
{ id:"BV40", question:"Which binding allows method replacement?", options:["Static","Compile","Dynamic","Early"], answer:2, explanation:"Dynamic binding allows method overriding." },

{ id:"BV41", question:"Which binding uses compile-time information only?", options:["Dynamic","Runtime","Static","Late"], answer:2, explanation:"Static binding uses compile-time information." },
{ id:"BV42", question:"Which binding enables runtime dispatch?", options:["Static","Early","Dynamic","Compile"], answer:2, explanation:"Dynamic binding enables runtime dispatch." },
{ id:"BV43", question:"Which binding resolves variable addresses?", options:["Type","Value","Storage","Name"], answer:2, explanation:"Storage binding resolves memory address." },
{ id:"BV44", question:"Which binding affects execution efficiency most?", options:["Dynamic","Late","Static","Runtime"], answer:2, explanation:"Static binding is more efficient." },
{ id:"BV45", question:"Which binding is default in Java for methods?", options:["Static","Dynamic","Compile","Early"], answer:1, explanation:"Java methods are dynamically bound by default." },

{ id:"BV46", question:"Which binding restricts flexibility?", options:["Dynamic","Late","Static","Runtime"], answer:2, explanation:"Static binding restricts flexibility." },
{ id:"BV47", question:"Which binding allows runtime substitution?", options:["Static","Compile","Dynamic","Early"], answer:2, explanation:"Dynamic binding allows substitution at runtime." },
{ id:"BV48", question:"Which binding applies to overloaded operators in C++?", options:["Dynamic","Late","Static","Runtime"], answer:2, explanation:"Operator overloading uses static binding." },
{ id:"BV49", question:"Which binding occurs when function call is matched?", options:["Value","Type","Call binding","Name"], answer:2, explanation:"Call binding matches function call to definition." },
{ id:"BV50", question:"Which binding is resolved earliest?", options:["Dynamic","Late","Static","Runtime"], answer:2, explanation:"Static binding is resolved earliest." },

{ id:"BV51", question:"Which binding uses reference variable type?", options:["Dynamic","Static","Late","Runtime"], answer:1, explanation:"Static binding depends on reference type." },
{ id:"BV52", question:"Which binding is resolved latest?", options:["Static","Compile","Dynamic","Early"], answer:2, explanation:"Dynamic binding is resolved latest." },
{ id:"BV53", question:"Which binding allows flexible architectures?", options:["Static","Dynamic","Compile","Early"], answer:1, explanation:"Dynamic binding allows flexible architectures." },
{ id:"BV54", question:"Which binding is unsuitable for real-time systems?", options:["Static","Early","Dynamic","Compile"], answer:2, explanation:"Dynamic binding may cause unpredictable delays." },
{ id:"BV55", question:"Which binding is predictable?", options:["Dynamic","Late","Static","Runtime"], answer:2, explanation:"Static binding is predictable." },

{ id:"BV56", question:"Which binding is used for inline functions?", options:["Dynamic","Late","Static","Runtime"], answer:2, explanation:"Inline functions use static binding." },
{ id:"BV57", question:"Which binding supports abstraction?", options:["Static","Compile","Dynamic","Early"], answer:2, explanation:"Dynamic binding supports abstraction." },
{ id:"BV58", question:"Which binding is essential for runtime polymorphism?", options:["Static","Compile","Dynamic","Early"], answer:2, explanation:"Dynamic binding is essential." },
{ id:"BV59", question:"Which binding is faster at runtime?", options:["Dynamic","Late","Static","Runtime"], answer:2, explanation:"Static binding is faster." },
{ id:"BV60", question:"Which binding is common in object-oriented languages?", options:["Static","Dynamic","Compile","Early"], answer:1, explanation:"OOP languages heavily use dynamic binding." },

{ id:"BV61", question:"Which binding determines variable lifetime?", options:["Name","Type","Storage","Value"], answer:2, explanation:"Storage binding determines lifetime." },
{ id:"BV62", question:"Which binding is resolved using inheritance?", options:["Static","Compile","Dynamic","Early"], answer:2, explanation:"Dynamic binding uses inheritance." },
{ id:"BV63", question:"Which binding is resolved using method signature?", options:["Dynamic","Late","Static","Runtime"], answer:2, explanation:"Static binding uses method signature." },
{ id:"BV64", question:"Which binding uses vtable lookup?", options:["Static","Compile","Dynamic","Early"], answer:2, explanation:"vtable is used for dynamic binding." },
{ id:"BV65", question:"Which binding increases extensibility?", options:["Static","Dynamic","Compile","Early"], answer:1, explanation:"Dynamic binding increases extensibility." },

{ id:"BV66", question:"Which binding can cause runtime errors?", options:["Static","Early","Dynamic","Compile"], answer:2, explanation:"Dynamic binding errors may appear at runtime." },
{ id:"BV67", question:"Which binding is resolved at load time?", options:["Static","Dynamic","Early","Storage"], answer:3, explanation:"Storage binding may occur at load time." },
{ id:"BV68", question:"Which binding ensures method consistency?", options:["Dynamic","Late","Static","Runtime"], answer:2, explanation:"Static binding ensures consistency." },
{ id:"BV69", question:"Which binding uses runtime type information?", options:["Static","Compile","Dynamic","Early"], answer:2, explanation:"Dynamic binding uses RTTI." },
{ id:"BV70", question:"Which binding improves code reuse?", options:["Static","Dynamic","Compile","Early"], answer:1, explanation:"Dynamic binding improves reuse." },

{ id:"BV71", question:"Which binding resolves method call at runtime?", options:["Static","Early","Dynamic","Compile"], answer:2, explanation:"Dynamic binding resolves at runtime." },
{ id:"BV72", question:"Which binding is resolved by compiler?", options:["Dynamic","Runtime","Static","Late"], answer:2, explanation:"Compiler resolves static binding." },
{ id:"BV73", question:"Which binding supports late method selection?", options:["Static","Compile","Dynamic","Early"], answer:2, explanation:"Dynamic binding supports late selection." },
{ id:"BV74", question:"Which binding is associated with efficiency?", options:["Dynamic","Late","Static","Runtime"], answer:2, explanation:"Static binding is efficient." },
{ id:"BV75", question:"Which binding is essential for overriding?", options:["Static","Compile","Dynamic","Early"], answer:2, explanation:"Dynamic binding enables overriding." },

{ id:"BV76", question:"Which binding is resolved without object creation?", options:["Dynamic","Runtime","Static","Late"], answer:2, explanation:"Static binding doesnt require object creation." },
{ id:"BV77", question:"Which binding uses compile-time polymorphism?", options:["Dynamic","Late","Static","Runtime"], answer:2, explanation:"Static binding supports compile-time polymorphism." },
{ id:"BV78", question:"Which binding supports runtime polymorphism?", options:["Static","Compile","Dynamic","Early"], answer:2, explanation:"Dynamic binding supports runtime polymorphism." },
{ id:"BV79", question:"Which binding may delay error detection?", options:["Static","Early","Dynamic","Compile"], answer:2, explanation:"Dynamic binding errors appear at runtime." },
{ id:"BV80", question:"Which binding increases program flexibility?", options:["Static","Dynamic","Compile","Early"], answer:1, explanation:"Dynamic binding increases flexibility." },

{ id:"BV81", question:"Which binding is preferred for performance-critical code?", options:["Dynamic","Late","Static","Runtime"], answer:2, explanation:"Static binding is preferred for performance." },
{ id:"BV82", question:"Which binding is used by abstract methods?", options:["Static","Compile","Dynamic","Early"], answer:2, explanation:"Abstract methods require dynamic binding." },
{ id:"BV83", question:"Which binding resolves method calls using inheritance tree?", options:["Static","Compile","Dynamic","Early"], answer:2, explanation:"Dynamic binding uses inheritance tree." },
{ id:"BV84", question:"Which binding is decided during execution?", options:["Static","Compile","Dynamic","Early"], answer:2, explanation:"Dynamic binding is execution-time." },
{ id:"BV85", question:"Which binding offers better flexibility?", options:["Static","Dynamic","Compile","Early"], answer:1, explanation:"Dynamic binding offers flexibility." },

{ id:"BV86", question:"Which binding associates identifier with type?", options:["Name","Type","Value","Storage"], answer:1, explanation:"Type binding associates identifier with data type." },
{ id:"BV87", question:"Which binding associates identifier with value?", options:["Name","Type","Value","Storage"], answer:2, explanation:"Value binding associates variable with value." },
{ id:"BV88", question:"Which binding associates identifier with memory?", options:["Type","Value","Storage","Name"], answer:2, explanation:"Storage binding associates identifier with memory." },
{ id:"BV89", question:"Which binding is earliest in program lifecycle?", options:["Value","Type","Storage","Dynamic"], answer:1, explanation:"Type binding occurs earliest." },
{ id:"BV90", question:"Which binding is last in program lifecycle?", options:["Type","Name","Value","Dynamic"], answer:2, explanation:"Value binding occurs last." },

{ id:"BV91", question:"Which binding is language dependent?", options:["Type","Storage","Dynamic","All"], answer:3, explanation:"All bindings depend on language rules." },
{ id:"BV92", question:"Which binding supports loose coupling?", options:["Static","Dynamic","Compile","Early"], answer:1, explanation:"Dynamic binding supports loose coupling." },
{ id:"BV93", question:"Which binding is resolved without runtime checks?", options:["Dynamic","Late","Static","Runtime"], answer:2, explanation:"Static binding avoids runtime checks." },
{ id:"BV94", question:"Which binding is commonly tested in exams?", options:["Value","Type","Static vs Dynamic","Storage"], answer:2, explanation:"Static vs Dynamic binding is frequently tested." },
{ id:"BV95", question:"Which binding defines method dispatch?", options:["Type","Value","Call","Dynamic"], answer:3, explanation:"Dynamic binding defines method dispatch." },

{ id:"BV96", question:"Which binding occurs during compilation phase?", options:["Dynamic","Runtime","Static","Late"], answer:2, explanation:"Static binding occurs during compilation." },
{ id:"BV97", question:"Which binding is required for polymorphism?", options:["Static","Compile","Dynamic","Early"], answer:2, explanation:"Dynamic binding is required." },
{ id:"BV98", question:"Which binding allows overriding methods?", options:["Static","Compile","Dynamic","Early"], answer:2, explanation:"Dynamic binding allows overriding." },
{ id:"BV99", question:"Which binding is safer but rigid?", options:["Dynamic","Late","Static","Runtime"], answer:2, explanation:"Static binding is safer but rigid." },
{ id:"BV100", question:"Which binding best describes Java method calls?", options:["Static","Dynamic","Early","Compile"], answer:1, explanation:"Java uses dynamic binding for methods by default." }
],
"Parameter Passing":[
{ id:"PP01", question:"Parameter passing refers to:", options:["Returning values","Sending data to functions","Declaring variables","Memory allocation"], answer:1, explanation:"Parameter passing is the mechanism of sending data to functions." },
{ id:"PP02", question:"Which is the default parameter passing method in C?", options:["Call by value","Call by reference","Call by pointer","Call by name"], answer:0, explanation:"C uses call by value by default." },
{ id:"PP03", question:"Which method passes a copy of actual parameter?", options:["Call by reference","Call by value","Call by pointer","Call by address"], answer:1, explanation:"Call by value passes a copy." },
{ id:"PP04", question:"Which method allows modification of actual parameter?", options:["Call by value","Call by reference","Call by copy","Call by name"], answer:1, explanation:"Call by reference allows modification." },
{ id:"PP05", question:"Java uses which parameter passing method?", options:["Call by value","Call by reference","Call by name","Call by pointer"], answer:0, explanation:"Java always uses call by value." },

{ id:"PP06", question:"In Java, objects are passed:", options:["By reference","By value of reference","By pointer","By name"], answer:1, explanation:"Java passes object references by value." },
{ id:"PP07", question:"Which symbol is used to implement call by reference in C++?", options:["*","&","->","::"], answer:1, explanation:"& is used for reference parameters." },
{ id:"PP08", question:"Which method uses pointers to simulate call by reference?", options:["C","Java","Python","Pascal"], answer:0, explanation:"C uses pointers for reference behavior." },
{ id:"PP09", question:"Which parameter passing is safest?", options:["Call by value","Call by reference","Call by pointer","Call by name"], answer:0, explanation:"Call by value prevents unintended modification." },
{ id:"PP10", question:"Which parameter passing improves performance for large objects?", options:["Call by value","Call by reference","Call by copy","Call by name"], answer:1, explanation:"Call by reference avoids copying large data." },

{ id:"PP11", question:"Which method allows multiple return values?", options:["Call by value","Call by reference","Call by name","Call by copy"], answer:1, explanation:"Call by reference allows output through parameters." },
{ id:"PP12", question:"Which of these languages supports call by reference directly?", options:["C","C++","Java","C#"], answer:1, explanation:"C++ supports call by reference." },
{ id:"PP13", question:"In C, how is call by reference achieved?", options:["Using references","Using pointers","Using arrays","Using macros"], answer:1, explanation:"Pointers simulate call by reference in C." },
{ id:"PP14", question:"Which parameter passing method uses memory address?", options:["Call by value","Call by reference","Call by name","Call by copy"], answer:1, explanation:"Call by reference uses memory address." },
{ id:"PP15", question:"Which method does NOT change actual arguments?", options:["Call by reference","Call by pointer","Call by value","Call by name"], answer:2, explanation:"Call by value does not affect actual arguments." },

{ id:"PP16", question:"Which parameter passing is faster for primitive types?", options:["Call by value","Call by reference","Call by pointer","Call by name"], answer:0, explanation:"Call by value is faster for primitives." },
{ id:"PP17", question:"Which method supports output parameters?", options:["Call by value","Call by reference","Call by copy","Call by name"], answer:1, explanation:"Call by reference supports output parameters." },
{ id:"PP18", question:"Which parameter passing is used in function overloading resolution?", options:["Runtime","Compile time","Call by value","Call by reference"], answer:1, explanation:"Overloading is resolved at compile time." },
{ id:"PP19", question:"Which passing mechanism is used for arrays in C?", options:["Call by value","Call by reference","Call by name","Call by copy"], answer:1, explanation:"Arrays decay to pointers, enabling reference behavior." },
{ id:"PP20", question:"Which parameter passing uses thunk mechanism?", options:["Call by value","Call by reference","Call by name","Call by pointer"], answer:2, explanation:"Call by name uses thunks." },

{ id:"PP21", question:"Which method passes actual parameter address implicitly?", options:["Call by value","Call by reference","Call by copy","Call by name"], answer:1, explanation:"Call by reference passes address implicitly." },
{ id:"PP22", question:"Which passing technique increases security?", options:["Call by reference","Call by value","Call by pointer","Call by name"], answer:1, explanation:"Call by value prevents side effects." },
{ id:"PP23", question:"Which parameter passing is used in recursive functions safely?", options:["Call by reference","Call by value","Call by pointer","Call by name"], answer:1, explanation:"Call by value avoids shared state in recursion." },
{ id:"PP24", question:"Which passing method is used for objects in C++ by default?", options:["Call by value","Call by reference","Call by pointer","Call by name"], answer:0, explanation:"Objects are passed by value by default." },
{ id:"PP25", question:"Which keyword enforces reference passing in C++?", options:["static","final","const","&"], answer:3, explanation:"& enforces reference passing." },

{ id:"PP26", question:"Which passing mechanism allows aliasing?", options:["Call by value","Call by reference","Call by copy","Call by name"], answer:1, explanation:"Call by reference allows aliasing." },
{ id:"PP27", question:"Which method copies only address, not data?", options:["Call by value","Call by reference","Call by copy","Call by name"], answer:1, explanation:"Only address is passed in call by reference." },
{ id:"PP28", question:"Which parameter passing is default in Java for primitives?", options:["Reference","Value","Pointer","Name"], answer:1, explanation:"Java passes primitives by value." },
{ id:"PP29", question:"Which parameter passing is dangerous if misused?", options:["Call by value","Call by reference","Call by copy","Call by name"], answer:1, explanation:"Reference passing can cause unintended side effects." },
{ id:"PP30", question:"Which passing technique supports function output?", options:["Call by value","Call by reference","Call by name","Call by copy"], answer:1, explanation:"Call by reference supports outputs." },

{ id:"PP31", question:"Which parameter passing creates a new stack frame copy?", options:["Call by value","Call by reference","Call by pointer","Call by name"], answer:0, explanation:"Call by value creates a copy in stack frame." },
{ id:"PP32", question:"Which passing avoids copying large structures?", options:["Call by value","Call by reference","Call by copy","Call by name"], answer:1, explanation:"Reference passing avoids copying." },
{ id:"PP33", question:"Which passing mechanism is NOT supported in Java?", options:["Call by value","Call by reference","Pass reference value","None"], answer:1, explanation:"Java does not support true call by reference." },
{ id:"PP34", question:"Which passing method uses pointers explicitly?", options:["Call by value","Call by reference","Call by pointer","Call by name"], answer:2, explanation:"Call by pointer explicitly uses pointers." },
{ id:"PP35", question:"Which parameter passing allows modifying multiple variables?", options:["Call by value","Call by reference","Call by copy","Call by name"], answer:1, explanation:"Multiple variables can be modified via references." },

{ id:"PP36", question:"Which parameter passing is easiest to debug?", options:["Call by reference","Call by value","Call by pointer","Call by name"], answer:1, explanation:"Call by value avoids side effects." },
{ id:"PP37", question:"Which passing method supports swapping values?", options:["Call by value","Call by reference","Call by copy","Call by name"], answer:1, explanation:"Swapping requires reference passing." },
{ id:"PP38", question:"Which method ensures data integrity?", options:["Call by reference","Call by value","Call by pointer","Call by name"], answer:1, explanation:"Call by value ensures integrity." },
{ id:"PP39", question:"Which passing uses same memory location?", options:["Call by value","Call by reference","Call by copy","Call by name"], answer:1, explanation:"Reference uses same memory location." },
{ id:"PP40", question:"Which passing increases memory usage?", options:["Call by value","Call by reference","Call by pointer","Call by name"], answer:0, explanation:"Call by value copies data." },

{ id:"PP41", question:"Which passing is preferred for immutable objects?", options:["Call by value","Call by reference","Call by pointer","Call by name"], answer:0, explanation:"Immutable objects are safe with value passing." },
{ id:"PP42", question:"Which passing allows direct memory access?", options:["Call by value","Call by reference","Call by pointer","Call by name"], answer:2, explanation:"Pointers allow direct memory access." },
{ id:"PP43", question:"Which passing is used for arrays in Java?", options:["Call by value","Call by reference","Call by pointer","Call by name"], answer:0, explanation:"Java passes array references by value." },
{ id:"PP44", question:"Which passing can cause side effects?", options:["Call by value","Call by reference","Call by copy","Call by name"], answer:1, explanation:"Reference passing can cause side effects." },
{ id:"PP45", question:"Which passing is resolved at compile time?", options:["Call by value","Call by reference","Call by name","All"], answer:3, explanation:"Parameter passing mechanism is decided at compile time." },

{ id:"PP46", question:"Which passing avoids aliasing?", options:["Call by reference","Call by value","Call by pointer","Call by name"], answer:1, explanation:"Call by value avoids aliasing." },
{ id:"PP47", question:"Which passing passes actual parameter expression?", options:["Call by value","Call by reference","Call by name","Call by pointer"], answer:2, explanation:"Call by name passes expression, not value." },
{ id:"PP48", question:"Which passing is rarely used today?", options:["Call by value","Call by reference","Call by name","Call by pointer"], answer:2, explanation:"Call by name is rare." },
{ id:"PP49", question:"Which passing allows lazy evaluation?", options:["Call by value","Call by reference","Call by name","Call by pointer"], answer:2, explanation:"Call by name supports lazy evaluation." },
{ id:"PP50", question:"Which passing binds parameter at runtime?", options:["Call by value","Call by reference","Call by name","None"], answer:2, explanation:"Call by name binds at runtime." },

{ id:"PP51", question:"Which passing is safest in multithreading?", options:["Call by reference","Call by value","Call by pointer","Call by name"], answer:1, explanation:"Call by value avoids shared state." },
{ id:"PP52", question:"Which passing allows output through parameters?", options:["Call by value","Call by reference","Call by copy","Call by name"], answer:1, explanation:"Reference passing allows output parameters." },
{ id:"PP53", question:"Which passing is used in swap using pointers?", options:["Call by value","Call by pointer","Call by reference","Call by name"], answer:1, explanation:"Swap in C uses pointers." },
{ id:"PP54", question:"Which passing is best for small data?", options:["Call by value","Call by reference","Call by pointer","Call by name"], answer:0, explanation:"Value passing is best for small data." },
{ id:"PP55", question:"Which passing requires address-of operator?", options:["Call by value","Call by reference","Call by pointer","Call by name"], answer:2, explanation:"Pointer passing requires & operator." },

{ id:"PP56", question:"Which passing mechanism does not copy actual data?", options:["Call by value","Call by reference","Call by copy","Call by name"], answer:1, explanation:"Reference passing avoids data copy." },
{ id:"PP57", question:"Which passing method causes aliasing problems?", options:["Call by value","Call by reference","Call by copy","Call by name"], answer:1, explanation:"Aliasing occurs in reference passing." },
{ id:"PP58", question:"Which passing is preferred in functional programming?", options:["Call by reference","Call by value","Call by pointer","Call by name"], answer:1, explanation:"Functional programming prefers immutability." },
{ id:"PP59", question:"Which passing is predictable?", options:["Call by reference","Call by name","Call by value","Call by pointer"], answer:2, explanation:"Call by value is predictable." },
{ id:"PP60", question:"Which passing allows bidirectional data flow?", options:["Call by value","Call by reference","Call by copy","Call by name"], answer:1, explanation:"Reference allows bidirectional flow." },

{ id:"PP61", question:"Which passing uses same variable for actual and formal?", options:["Call by value","Call by reference","Call by copy","Call by name"], answer:1, explanation:"Reference uses same variable." },
{ id:"PP62", question:"Which passing is slower for large objects?", options:["Call by value","Call by reference","Call by pointer","Call by name"], answer:0, explanation:"Copying large objects is slow." },
{ id:"PP63", question:"Which passing allows direct modification?", options:["Call by value","Call by reference","Call by copy","Call by name"], answer:1, explanation:"Reference allows modification." },
{ id:"PP64", question:"Which passing is commonly tested in exams?", options:["Call by value vs reference","Call by name","Call by copy","Call by macro"], answer:0, explanation:"Value vs reference is frequently tested." },
{ id:"PP65", question:"Which passing requires pointer dereferencing?", options:["Call by value","Call by reference","Call by pointer","Call by name"], answer:2, explanation:"Pointer passing requires dereferencing." },

{ id:"PP66", question:"Which passing creates independent variable copies?", options:["Call by reference","Call by value","Call by pointer","Call by name"], answer:1, explanation:"Value passing creates independent copies." },
{ id:"PP67", question:"Which passing avoids side effects?", options:["Call by reference","Call by value","Call by pointer","Call by name"], answer:1, explanation:"Call by value avoids side effects." },
{ id:"PP68", question:"Which passing is more memory efficient?", options:["Call by value","Call by reference","Call by copy","Call by name"], answer:1, explanation:"Reference avoids copying." },
{ id:"PP69", question:"Which passing is used internally by Java VM?", options:["Call by value","Call by reference","Call by name","Call by pointer"], answer:0, explanation:"Java VM uses call by value." },
{ id:"PP70", question:"Which passing method can modify caller variables?", options:["Call by value","Call by reference","Call by copy","Call by name"], answer:1, explanation:"Reference can modify caller variables." },

{ id:"PP71", question:"Which passing is used with const references in C++?", options:["Call by value","Call by reference","Call by pointer","Call by name"], answer:1, explanation:"Const reference avoids modification." },
{ id:"PP72", question:"Which passing supports multiple outputs?", options:["Call by value","Call by reference","Call by copy","Call by name"], answer:1, explanation:"Reference passing supports multiple outputs." },
{ id:"PP73", question:"Which passing avoids copying but ensures safety?", options:["Call by reference","Call by const reference","Call by pointer","Call by name"], answer:1, explanation:"Const reference avoids copying and modification." },
{ id:"PP74", question:"Which passing is easiest to reason about?", options:["Call by reference","Call by value","Call by pointer","Call by name"], answer:1, explanation:"Call by value is easiest." },
{ id:"PP75", question:"Which passing is rarely used in modern languages?", options:["Call by value","Call by reference","Call by name","Call by pointer"], answer:2, explanation:"Call by name is rare today." },

{ id:"PP76", question:"Which passing uses actual memory address explicitly?", options:["Call by value","Call by reference","Call by pointer","Call by name"], answer:2, explanation:"Pointer passing uses memory addresses." },
{ id:"PP77", question:"Which passing prevents accidental modification?", options:["Call by reference","Call by value","Call by pointer","Call by name"], answer:1, explanation:"Call by value prevents accidental changes." },
{ id:"PP78", question:"Which passing is best for security?", options:["Call by reference","Call by value","Call by pointer","Call by name"], answer:1, explanation:"Call by value is secure." },
{ id:"PP79", question:"Which passing uses same memory for actual and formal?", options:["Call by value","Call by reference","Call by copy","Call by name"], answer:1, explanation:"Reference shares memory." },
{ id:"PP80", question:"Which passing is resolved before execution?", options:["Call by value","Call by reference","Call by name","All"], answer:3, explanation:"Passing mechanism is compile-time decision." },

{ id:"PP81", question:"Which passing is preferred in system programming?", options:["Call by value","Call by reference","Call by pointer","Call by name"], answer:2, explanation:"System programming prefers pointers." },
{ id:"PP82", question:"Which passing improves efficiency for large arrays?", options:["Call by value","Call by reference","Call by copy","Call by name"], answer:1, explanation:"Reference avoids copying arrays." },
{ id:"PP83", question:"Which passing is conceptually simplest?", options:["Call by value","Call by reference","Call by pointer","Call by name"], answer:0, explanation:"Call by value is simplest." },
{ id:"PP84", question:"Which passing may cause unintended bugs?", options:["Call by value","Call by reference","Call by copy","Call by name"], answer:1, explanation:"Reference passing can cause bugs." },
{ id:"PP85", question:"Which passing is used in swap in Java?", options:["Call by value","Call by reference","Impossible","Call by name"], answer:2, explanation:"Java cannot swap primitives via methods." },

{ id:"PP86", question:"Which passing is ideal for immutable data?", options:["Call by reference","Call by value","Call by pointer","Call by name"], answer:1, explanation:"Immutable data suits value passing." },
{ id:"PP87", question:"Which passing allows data modification inside function?", options:["Call by value","Call by reference","Call by copy","Call by name"], answer:1, explanation:"Reference allows modification." },
{ id:"PP88", question:"Which passing is resolved using memory addresses?", options:["Call by value","Call by reference","Call by pointer","Both B and C"], answer:3, explanation:"Both reference and pointer use addresses." },
{ id:"PP89", question:"Which passing uses same variable alias?", options:["Call by value","Call by reference","Call by copy","Call by name"], answer:1, explanation:"Reference creates alias." },
{ id:"PP90", question:"Which passing is most predictable?", options:["Call by reference","Call by pointer","Call by name","Call by value"], answer:3, explanation:"Call by value is most predictable." },

{ id:"PP91", question:"Which passing is best for concurrency?", options:["Call by reference","Call by value","Call by pointer","Call by name"], answer:1, explanation:"Value passing avoids shared state." },
{ id:"PP92", question:"Which passing avoids race conditions?", options:["Call by reference","Call by value","Call by pointer","Call by name"], answer:1, explanation:"Call by value avoids shared memory." },
{ id:"PP93", question:"Which passing mechanism supports lazy evaluation?", options:["Call by value","Call by reference","Call by name","Call by pointer"], answer:2, explanation:"Call by name supports lazy evaluation." },
{ id:"PP94", question:"Which passing is rarely implemented in compilers?", options:["Call by value","Call by reference","Call by name","Call by pointer"], answer:2, explanation:"Call by name is rare." },
{ id:"PP95", question:"Which passing is preferred in object-oriented design?", options:["Call by value","Call by reference","Call by pointer","Call by name"], answer:1, explanation:"Reference passing is common in OOP." },

{ id:"PP96", question:"Which passing allows changing original data?", options:["Call by value","Call by reference","Call by copy","Call by name"], answer:1, explanation:"Reference allows changes." },
{ id:"PP97", question:"Which passing uses stack copying?", options:["Call by value","Call by reference","Call by pointer","Call by name"], answer:0, explanation:"Value passing copies data to stack." },
{ id:"PP98", question:"Which passing reduces memory overhead?", options:["Call by value","Call by reference","Call by copy","Call by name"], answer:1, explanation:"Reference reduces memory overhead." },
{ id:"PP99", question:"Which passing avoids copying but prevents modification?", options:["Call by reference","Call by const reference","Call by pointer","Call by name"], answer:1, explanation:"Const reference avoids copying and modification." },
{ id:"PP100", question:"Which parameter passing concept is most frequently asked in exams?", options:["Call by name","Call by value vs reference","Call by copy","Call by macro"], answer:1, explanation:"Call by value vs reference is most common." }
],
"Functional & Logic Programming":[
{ id:"FL01", question:"Functional programming primarily focuses on:", options:["Objects","Functions","Procedures","Classes"], answer:1, explanation:"Functional programming treats computation as evaluation of functions." },
{ id:"FL02", question:"Which concept is central to functional programming?", options:["Mutable state","Immutability","Inheritance","Encapsulation"], answer:1, explanation:"Immutability is a core principle of functional programming." },
{ id:"FL03", question:"Which of the following is NOT a feature of functional programming?", options:["First-class functions","Recursion","State mutation","Pure functions"], answer:2, explanation:"Functional programming avoids state mutation." },
{ id:"FL04", question:"A pure function:", options:["Uses global variables","Has side effects","Always returns same output for same input","Modifies parameters"], answer:2, explanation:"Pure functions have no side effects and deterministic output." },
{ id:"FL05", question:"Which programming paradigm uses declarative style?", options:["Procedural","Object-oriented","Functional","Assembly"], answer:2, explanation:"Functional programming is declarative." },

{ id:"FL06", question:"Which of these supports functional programming in Java?", options:["Lambda expressions","Pointers","Macros","Multiple inheritance"], answer:0, explanation:"Java supports functional style using lambda expressions." },
{ id:"FL07", question:"Which feature allows functions to be passed as arguments?", options:["Encapsulation","Polymorphism","First-class functions","Overloading"], answer:2, explanation:"First-class functions can be passed as arguments." },
{ id:"FL08", question:"Which is preferred over loops in functional programming?", options:["Inheritance","Recursion","Pointers","Macros"], answer:1, explanation:"Recursion replaces loops in functional programming." },
{ id:"FL09", question:"Which language is purely functional?", options:["Java","C++","Haskell","C"], answer:2, explanation:"Haskell is a purely functional language." },
{ id:"FL10", question:"Which programming discourages variable reassignment?", options:["Procedural","Object-oriented","Functional","Imperative"], answer:2, explanation:"Functional programming discourages reassignment." },

{ id:"FL11", question:"Logic programming is based on:", options:["Algorithms","Rules and facts","Classes","Objects"], answer:1, explanation:"Logic programming is based on rules and facts." },
{ id:"FL12", question:"Which language is associated with logic programming?", options:["Java","C","Prolog","C++"], answer:2, explanation:"Prolog is a logic programming language." },
{ id:"FL13", question:"Logic programming uses which mechanism?", options:["Compilation","Backtracking","Inheritance","Overloading"], answer:1, explanation:"Logic programming uses backtracking to find solutions." },
{ id:"FL14", question:"In logic programming, a fact represents:", options:["A rule","A condition","A true statement","A function"], answer:2, explanation:"Facts represent true statements." },
{ id:"FL15", question:"A rule in Prolog consists of:", options:["Head and body","Loop and condition","Class and object","Function and return"], answer:0, explanation:"Rules have a head and a body." },

{ id:"FL16", question:"Which programming paradigm focuses on what to compute?", options:["Imperative","Procedural","Functional","Assembly"], answer:2, explanation:"Functional programming focuses on what to compute." },
{ id:"FL17", question:"Which concept avoids shared state?", options:["Inheritance","Immutability","Polymorphism","Overloading"], answer:1, explanation:"Immutability avoids shared state." },
{ id:"FL18", question:"Which technique improves reliability in functional programming?", options:["Side effects","Pure functions","Global variables","Pointers"], answer:1, explanation:"Pure functions improve reliability." },
{ id:"FL19", question:"Which concept allows delayed execution?", options:["Lazy evaluation","Eager execution","Compilation","Interpretation"], answer:0, explanation:"Lazy evaluation delays execution." },
{ id:"FL20", question:"Which functional concept treats functions as data?", options:["Encapsulation","First-class functions","Inheritance","Abstraction"], answer:1, explanation:"First-class functions treat functions as data." },

{ id:"FL21", question:"Which programming style avoids loops?", options:["Procedural","Functional","Assembly","Imperative"], answer:1, explanation:"Functional programming avoids loops." },
{ id:"FL22", question:"Which Java feature supports functional interfaces?", options:["Lambda expressions","Constructors","Threads","Exceptions"], answer:0, explanation:"Lambda expressions work with functional interfaces." },
{ id:"FL23", question:"A functional interface in Java has:", options:["Multiple abstract methods","One abstract method","No methods","Only default methods"], answer:1, explanation:"Functional interfaces have one abstract method." },
{ id:"FL24", question:"Which annotation identifies a functional interface?", options:["@Override","@FunctionalInterface","@Interface","@Lambda"], answer:1, explanation:"@FunctionalInterface identifies functional interfaces." },
{ id:"FL25", question:"Which logic programming feature explores multiple solutions?", options:["Recursion","Backtracking","Overloading","Inheritance"], answer:1, explanation:"Backtracking explores multiple solutions." },

{ id:"FL26", question:"Which programming uses pattern matching extensively?", options:["Procedural","Functional","Object-oriented","Assembly"], answer:1, explanation:"Functional programming uses pattern matching." },
{ id:"FL27", question:"Which avoids null-related errors?", options:["Mutable state","Immutability","Side effects","Pointers"], answer:1, explanation:"Immutability reduces null-related errors." },
{ id:"FL28", question:"Which logic programming construct asks queries?", options:["Facts","Rules","Goals","Classes"], answer:2, explanation:"Goals are queries in logic programming." },
{ id:"FL29", question:"Which paradigm is best suited for AI problems?", options:["Procedural","Functional","Logic","Assembly"], answer:2, explanation:"Logic programming suits AI problems." },
{ id:"FL30", question:"Which paradigm relies on mathematical functions?", options:["Procedural","Functional","Object-oriented","Assembly"], answer:1, explanation:"Functional programming relies on math functions." },

{ id:"FL31", question:"Which programming style emphasizes expressions?", options:["Imperative","Functional","Procedural","Assembly"], answer:1, explanation:"Functional programming emphasizes expressions." },
{ id:"FL32", question:"Which concept eliminates side effects?", options:["Mutable state","Pure functions","Inheritance","Overloading"], answer:1, explanation:"Pure functions eliminate side effects." },
{ id:"FL33", question:"Which supports concurrency safely?", options:["Mutable state","Functional programming","Global variables","Pointers"], answer:1, explanation:"Functional programming supports safe concurrency." },
{ id:"FL34", question:"Which logic programming language uses Horn clauses?", options:["Java","C","Prolog","C++"], answer:2, explanation:"Prolog uses Horn clauses." },
{ id:"FL35", question:"Which paradigm focuses on relations?", options:["Procedural","Functional","Logic","Object-oriented"], answer:2, explanation:"Logic programming focuses on relations." },

{ id:"FL36", question:"Which concept treats computation as evaluation?", options:["Procedural","Functional","Imperative","Assembly"], answer:1, explanation:"Functional programming treats computation as evaluation." },
{ id:"FL37", question:"Which discourages assignment statements?", options:["Procedural","Functional","Imperative","Assembly"], answer:1, explanation:"Functional programming discourages assignments." },
{ id:"FL38", question:"Which programming is declarative?", options:["Procedural","Functional","Imperative","Assembly"], answer:1, explanation:"Functional programming is declarative." },
{ id:"FL39", question:"Which logic programming feature uses unification?", options:["Compilation","Unification","Inheritance","Overloading"], answer:1, explanation:"Unification matches terms in logic programming." },
{ id:"FL40", question:"Which programming uses facts, rules, and queries?", options:["Procedural","Functional","Logic","Object-oriented"], answer:2, explanation:"Logic programming uses facts, rules, and queries." },

{ id:"FL41", question:"Which Java version introduced lambda expressions?", options:["Java 5","Java 6","Java 7","Java 8"], answer:3, explanation:"Java 8 introduced lambda expressions." },
{ id:"FL42", question:"Which programming avoids shared mutable data?", options:["Procedural","Functional","Imperative","Assembly"], answer:1, explanation:"Functional programming avoids shared mutable data." },
{ id:"FL43", question:"Which paradigm fits rule-based systems?", options:["Procedural","Functional","Logic","Object-oriented"], answer:2, explanation:"Logic programming fits rule-based systems." },
{ id:"FL44", question:"Which technique replaces iteration?", options:["Inheritance","Recursion","Overloading","Encapsulation"], answer:1, explanation:"Recursion replaces iteration in functional programming." },
{ id:"FL45", question:"Which paradigm emphasizes immutability?", options:["Procedural","Functional","Imperative","Assembly"], answer:1, explanation:"Functional programming emphasizes immutability." },

{ id:"FL46", question:"Which programming allows function composition?", options:["Procedural","Functional","Assembly","Imperative"], answer:1, explanation:"Functional programming allows function composition." },
{ id:"FL47", question:"Which logic programming feature tries alternatives?", options:["Unification","Backtracking","Compilation","Linking"], answer:1, explanation:"Backtracking tries alternatives." },
{ id:"FL48", question:"Which avoids race conditions?", options:["Global variables","Functional programming","Pointers","Mutable state"], answer:1, explanation:"Functional programming avoids race conditions." },
{ id:"FL49", question:"Which paradigm is closest to mathematics?", options:["Procedural","Functional","Assembly","Imperative"], answer:1, explanation:"Functional programming is closest to mathematics." },
{ id:"FL50", question:"Which paradigm uses declarative queries?", options:["Procedural","Functional","Logic","Object-oriented"], answer:2, explanation:"Logic programming uses declarative queries." },

{ id:"FL51", question:"Which feature enables concise functions in Java?", options:["Pointers","Lambda expressions","Macros","Threads"], answer:1, explanation:"Lambda expressions enable concise functions." },
{ id:"FL52", question:"Which programming style minimizes side effects?", options:["Procedural","Functional","Imperative","Assembly"], answer:1, explanation:"Functional programming minimizes side effects." },
{ id:"FL53", question:"Which concept allows treating functions as values?", options:["Inheritance","First-class functions","Encapsulation","Abstraction"], answer:1, explanation:"First-class functions treat functions as values." },
{ id:"FL54", question:"Which logic programming language is non-procedural?", options:["C","Java","Prolog","C++"], answer:2, explanation:"Prolog is non-procedural." },
{ id:"FL55", question:"Which paradigm defines logic, not control flow?", options:["Procedural","Functional","Logic","Imperative"], answer:2, explanation:"Logic programming defines logic, not flow." },

{ id:"FL56", question:"Which programming encourages expression evaluation?", options:["Procedural","Functional","Imperative","Assembly"], answer:1, explanation:"Functional programming encourages expressions." },
{ id:"FL57", question:"Which paradigm is easier to parallelize?", options:["Procedural","Functional","Imperative","Assembly"], answer:1, explanation:"Functional programming is easier to parallelize." },
{ id:"FL58", question:"Which programming uses predicates?", options:["Procedural","Functional","Logic","Object-oriented"], answer:2, explanation:"Logic programming uses predicates." },
{ id:"FL59", question:"Which paradigm avoids global state?", options:["Procedural","Functional","Imperative","Assembly"], answer:1, explanation:"Functional programming avoids global state." },
{ id:"FL60", question:"Which concept supports lazy computation?", options:["Lazy evaluation","Recursion","Compilation","Linking"], answer:0, explanation:"Lazy evaluation supports delayed computation." },

{ id:"FL61", question:"Which paradigm treats functions as mathematical mappings?", options:["Procedural","Functional","Assembly","Imperative"], answer:1, explanation:"Functional programming treats functions as mappings." },
{ id:"FL62", question:"Which paradigm is rule-based?", options:["Procedural","Functional","Logic","Object-oriented"], answer:2, explanation:"Logic programming is rule-based." },
{ id:"FL63", question:"Which programming avoids variable reassignment?", options:["Procedural","Functional","Imperative","Assembly"], answer:1, explanation:"Functional programming avoids reassignment." },
{ id:"FL64", question:"Which logic programming feature matches goals with facts?", options:["Compilation","Unification","Inheritance","Overloading"], answer:1, explanation:"Unification matches goals with facts." },
{ id:"FL65", question:"Which paradigm focuses on relations among data?", options:["Procedural","Functional","Logic","Assembly"], answer:2, explanation:"Logic programming focuses on relations." },

{ id:"FL66", question:"Which programming style is side-effect free?", options:["Procedural","Functional","Imperative","Assembly"], answer:1, explanation:"Functional programming aims to be side-effect free." },
{ id:"FL67", question:"Which paradigm emphasizes what over how?", options:["Procedural","Functional","Logic","Both B and C"], answer:3, explanation:"Functional and logic paradigms focus on what." },
{ id:"FL68", question:"Which programming language uses resolution principle?", options:["C","Java","Prolog","C++"], answer:2, explanation:"Prolog uses resolution principle." },
{ id:"FL69", question:"Which paradigm avoids explicit control flow?", options:["Procedural","Functional","Logic","Both B and C"], answer:3, explanation:"Both functional and logic avoid explicit control." },
{ id:"FL70", question:"Which concept allows reusable behavior via functions?", options:["Inheritance","Function composition","Encapsulation","Polymorphism"], answer:1, explanation:"Function composition enables reuse." },

{ id:"FL71", question:"Which programming paradigm simplifies reasoning?", options:["Procedural","Functional","Imperative","Assembly"], answer:1, explanation:"Functional programming simplifies reasoning." },
{ id:"FL72", question:"Which logic programming term defines a condition?", options:["Fact","Rule","Predicate","Class"], answer:2, explanation:"Predicates define conditions." },
{ id:"FL73", question:"Which paradigm reduces debugging complexity?", options:["Procedural","Functional","Imperative","Assembly"], answer:1, explanation:"Functional programming reduces debugging complexity." },
{ id:"FL74", question:"Which programming avoids hidden state changes?", options:["Procedural","Functional","Imperative","Assembly"], answer:1, explanation:"Functional programming avoids hidden state changes." },
{ id:"FL75", question:"Which paradigm is common in theorem proving?", options:["Procedural","Functional","Logic","Object-oriented"], answer:2, explanation:"Logic programming is used in theorem proving." },

{ id:"FL76", question:"Which programming model suits symbolic computation?", options:["Procedural","Functional","Logic","Assembly"], answer:2, explanation:"Logic programming suits symbolic computation." },
{ id:"FL77", question:"Which paradigm uses recursion heavily?", options:["Procedural","Functional","Assembly","Imperative"], answer:1, explanation:"Functional programming uses recursion heavily." },
{ id:"FL78", question:"Which programming avoids loops?", options:["Procedural","Functional","Imperative","Assembly"], answer:1, explanation:"Functional programming avoids loops." },
{ id:"FL79", question:"Which paradigm is closer to natural language rules?", options:["Procedural","Functional","Logic","Assembly"], answer:2, explanation:"Logic programming resembles natural language rules." },
{ id:"FL80", question:"Which paradigm emphasizes expressions over statements?", options:["Procedural","Functional","Imperative","Assembly"], answer:1, explanation:"Functional programming emphasizes expressions." },

{ id:"FL81", question:"Which paradigm ensures referential transparency?", options:["Procedural","Functional","Imperative","Assembly"], answer:1, explanation:"Functional programming ensures referential transparency." },
{ id:"FL82", question:"Which logic programming feature tries multiple paths?", options:["Compilation","Backtracking","Linking","Execution"], answer:1, explanation:"Backtracking tries multiple paths." },
{ id:"FL83", question:"Which paradigm avoids shared memory?", options:["Procedural","Functional","Imperative","Assembly"], answer:1, explanation:"Functional programming avoids shared memory." },
{ id:"FL84", question:"Which paradigm expresses problems as constraints?", options:["Procedural","Functional","Logic","Assembly"], answer:2, explanation:"Logic programming expresses constraints." },
{ id:"FL85", question:"Which programming paradigm is safest for concurrency?", options:["Procedural","Functional","Imperative","Assembly"], answer:1, explanation:"Functional programming is safest for concurrency." },

{ id:"FL86", question:"Which paradigm uses higher-order functions?", options:["Procedural","Functional","Assembly","Imperative"], answer:1, explanation:"Functional programming uses higher-order functions." },
{ id:"FL87", question:"Which paradigm is commonly used in AI?", options:["Procedural","Functional","Logic","Assembly"], answer:2, explanation:"Logic programming is common in AI." },
{ id:"FL88", question:"Which paradigm avoids state-based bugs?", options:["Procedural","Functional","Imperative","Assembly"], answer:1, explanation:"Functional programming avoids state-based bugs." },
{ id:"FL89", question:"Which paradigm allows declarative problem solving?", options:["Procedural","Functional","Logic","Both B and C"], answer:3, explanation:"Both functional and logic are declarative." },
{ id:"FL90", question:"Which paradigm models computation as relations?", options:["Procedural","Functional","Logic","Assembly"], answer:2, explanation:"Logic programming models relations." },

{ id:"FL91", question:"Which paradigm is best for constraint satisfaction problems?", options:["Procedural","Functional","Logic","Assembly"], answer:2, explanation:"Logic programming suits constraint satisfaction." },
{ id:"FL92", question:"Which programming uses immutable data structures?", options:["Procedural","Functional","Imperative","Assembly"], answer:1, explanation:"Functional programming uses immutable structures." },
{ id:"FL93", question:"Which paradigm supports pattern matching?", options:["Procedural","Functional","Assembly","Imperative"], answer:1, explanation:"Functional programming supports pattern matching." },
{ id:"FL94", question:"Which logic programming feature binds variables dynamically?", options:["Compilation","Unification","Linking","Execution"], answer:1, explanation:"Unification binds variables dynamically." },
{ id:"FL95", question:"Which paradigm reduces side effects?", options:["Procedural","Functional","Imperative","Assembly"], answer:1, explanation:"Functional programming reduces side effects." },

{ id:"FL96", question:"Which paradigm supports mathematical reasoning?", options:["Procedural","Functional","Assembly","Imperative"], answer:1, explanation:"Functional programming supports mathematical reasoning." },
{ id:"FL97", question:"Which paradigm is rule-driven?", options:["Procedural","Functional","Logic","Assembly"], answer:2, explanation:"Logic programming is rule-driven." },
{ id:"FL98", question:"Which paradigm improves code predictability?", options:["Procedural","Functional","Imperative","Assembly"], answer:1, explanation:"Functional programming improves predictability." },
{ id:"FL99", question:"Which paradigm avoids explicit memory management?", options:["Procedural","Functional","Assembly","Imperative"], answer:1, explanation:"Functional programming avoids explicit memory handling." },
{ id:"FL100", question:"Which topic is most tested in functional programming exams?", options:["Lambda & immutability","Pointers","Macros","Inheritance"], answer:0, explanation:"Lambda expressions and immutability are most tested." }
],
"OOP Concepts":[
{ id:"OOP01", question:"OOPS stands for:", options:["Object Oriented Programming System","Object Oriented Programming Structure","Object Oriented Programming Style","Object Oriented Programming"], answer:3, explanation:"OOPS stands for Object Oriented Programming." },
{ id:"OOP02", question:"Which is NOT an OOPS concept?", options:["Encapsulation","Inheritance","Compilation","Polymorphism"], answer:2, explanation:"Compilation is not an OOPS concept." },
{ id:"OOP03", question:"The basic unit of OOPS is:", options:["Function","Class","Object","Method"], answer:2, explanation:"Object is the basic runtime unit in OOPS." },
{ id:"OOP04", question:"A class is:", options:["Instance of object","Blueprint of object","Collection of objects","Function"], answer:1, explanation:"A class is a blueprint or template for objects." },
{ id:"OOP05", question:"An object is:", options:["Blueprint","Logical entity","Instance of class","Data type"], answer:2, explanation:"An object is an instance of a class." },

{ id:"OOP06", question:"Which concept binds data and methods together?", options:["Inheritance","Polymorphism","Encapsulation","Abstraction"], answer:2, explanation:"Encapsulation binds data and methods." },
{ id:"OOP07", question:"Which OOPS concept focuses on hiding implementation details?", options:["Encapsulation","Abstraction","Inheritance","Polymorphism"], answer:1, explanation:"Abstraction hides implementation details." },
{ id:"OOP08", question:"Which feature supports code reusability?", options:["Encapsulation","Inheritance","Abstraction","Polymorphism"], answer:1, explanation:"Inheritance promotes code reuse." },
{ id:"OOP09", question:"Which OOPS concept allows one interface multiple forms?", options:["Encapsulation","Inheritance","Abstraction","Polymorphism"], answer:3, explanation:"Polymorphism allows one interface multiple implementations." },
{ id:"OOP10", question:"Which keyword is used to create object in Java?", options:["new","malloc","alloc","create"], answer:0, explanation:"Java uses the 'new' keyword." },

{ id:"OOP11", question:"Which access specifier provides maximum encapsulation?", options:["public","protected","default","private"], answer:3, explanation:"Private provides maximum encapsulation." },
{ id:"OOP12", question:"Which OOPS feature increases security?", options:["Inheritance","Encapsulation","Polymorphism","Abstraction"], answer:1, explanation:"Encapsulation increases security." },
{ id:"OOP13", question:"Which allows dynamic method dispatch?", options:["Encapsulation","Inheritance","Polymorphism","Abstraction"], answer:2, explanation:"Polymorphism supports dynamic dispatch." },
{ id:"OOP14", question:"Which OOPS concept uses IS-A relationship?", options:["Encapsulation","Inheritance","Abstraction","Polymorphism"], answer:1, explanation:"Inheritance represents IS-A relationship." },
{ id:"OOP15", question:"Which OOPS concept uses HAS-A relationship?", options:["Inheritance","Composition","Abstraction","Polymorphism"], answer:1, explanation:"Composition represents HAS-A relationship." },

{ id:"OOP16", question:"Which language supports OOPS fully?", options:["C","Java","Assembly","BASIC"], answer:1, explanation:"Java fully supports OOPS." },
{ id:"OOP17", question:"Which is runtime polymorphism?", options:["Function overloading","Operator overloading","Method overriding","Constructor overloading"], answer:2, explanation:"Method overriding provides runtime polymorphism." },
{ id:"OOP18", question:"Which is compile-time polymorphism?", options:["Method overriding","Dynamic binding","Method overloading","Virtual function"], answer:2, explanation:"Method overloading is compile-time polymorphism." },
{ id:"OOP19", question:"Which concept supports loose coupling?", options:["Inheritance","Encapsulation","Abstraction","Polymorphism"], answer:2, explanation:"Abstraction promotes loose coupling." },
{ id:"OOP20", question:"Which mechanism hides internal data?", options:["Abstraction","Encapsulation","Inheritance","Polymorphism"], answer:1, explanation:"Encapsulation hides internal data." },

{ id:"OOP21", question:"Which OOPS concept reduces complexity?", options:["Encapsulation","Abstraction","Inheritance","Polymorphism"], answer:1, explanation:"Abstraction reduces complexity." },
{ id:"OOP22", question:"Which concept allows code extensibility?", options:["Encapsulation","Inheritance","Abstraction","Polymorphism"], answer:1, explanation:"Inheritance allows extensibility." },
{ id:"OOP23", question:"Which feature allows same function name with different parameters?", options:["Overriding","Overloading","Encapsulation","Inheritance"], answer:1, explanation:"Function overloading allows same name." },
{ id:"OOP24", question:"Which concept enables late binding?", options:["Encapsulation","Inheritance","Polymorphism","Abstraction"], answer:2, explanation:"Polymorphism enables late binding." },
{ id:"OOP25", question:"Which is NOT true about abstraction?", options:["Hides details","Uses interfaces","Improves complexity","Uses data hiding"], answer:3, explanation:"Data hiding belongs to encapsulation." },

{ id:"OOP26", question:"Which supports runtime flexibility?", options:["Encapsulation","Inheritance","Polymorphism","Abstraction"], answer:2, explanation:"Polymorphism supports flexibility." },
{ id:"OOP27", question:"Which OOPS feature uses base and derived classes?", options:["Encapsulation","Inheritance","Polymorphism","Abstraction"], answer:1, explanation:"Inheritance uses base and derived classes." },
{ id:"OOP28", question:"Which concept improves maintainability?", options:["Encapsulation","Inheritance","Polymorphism","All"], answer:3, explanation:"All OOPS concepts improve maintainability." },
{ id:"OOP29", question:"Which concept helps in real-world modeling?", options:["Encapsulation","Inheritance","Polymorphism","All"], answer:3, explanation:"OOPS models real-world entities." },
{ id:"OOP30", question:"Which feature uses virtual functions in C++?", options:["Encapsulation","Inheritance","Polymorphism","Abstraction"], answer:2, explanation:"Virtual functions enable polymorphism." },

{ id:"OOP31", question:"Which concept prevents direct access to data?", options:["Abstraction","Encapsulation","Inheritance","Polymorphism"], answer:1, explanation:"Encapsulation prevents direct access." },
{ id:"OOP32", question:"Which concept improves code readability?", options:["Encapsulation","Abstraction","Inheritance","Polymorphism"], answer:1, explanation:"Abstraction improves readability." },
{ id:"OOP33", question:"Which is NOT an advantage of OOPS?", options:["Reusability","Security","Speed","Maintainability"], answer:2, explanation:"OOPS may reduce speed." },
{ id:"OOP34", question:"Which concept uses method overriding?", options:["Encapsulation","Inheritance","Abstraction","Compilation"], answer:1, explanation:"Inheritance enables overriding." },
{ id:"OOP35", question:"Which relationship uses objects as members?", options:["IS-A","HAS-A","USES-A","None"], answer:1, explanation:"HAS-A represents object composition." },

{ id:"OOP36", question:"Which concept allows same message different behavior?", options:["Encapsulation","Inheritance","Polymorphism","Abstraction"], answer:2, explanation:"Polymorphism allows same message different behavior." },
{ id:"OOP37", question:"Which concept is mandatory for polymorphism?", options:["Encapsulation","Inheritance","Abstraction","Compilation"], answer:1, explanation:"Inheritance is mandatory for polymorphism." },
{ id:"OOP38", question:"Which OOPS feature improves scalability?", options:["Encapsulation","Inheritance","Polymorphism","All"], answer:3, explanation:"All contribute to scalability." },
{ id:"OOP39", question:"Which concept supports method hiding?", options:["Encapsulation","Inheritance","Abstraction","Polymorphism"], answer:1, explanation:"Inheritance supports method hiding." },
{ id:"OOP40", question:"Which concept focuses on external behavior?", options:["Encapsulation","Inheritance","Abstraction","Polymorphism"], answer:2, explanation:"Abstraction focuses on external behavior." },

{ id:"OOP41", question:"Which concept helps in framework design?", options:["Encapsulation","Inheritance","Polymorphism","All"], answer:3, explanation:"All OOPS concepts help framework design." },
{ id:"OOP42", question:"Which is NOT supported by C?", options:["Encapsulation","Inheritance","Polymorphism","All"], answer:3, explanation:"C does not support OOPS directly." },
{ id:"OOP43", question:"Which concept improves data security?", options:["Inheritance","Encapsulation","Polymorphism","Abstraction"], answer:1, explanation:"Encapsulation improves data security." },
{ id:"OOP44", question:"Which concept provides generalization?", options:["Encapsulation","Inheritance","Polymorphism","Abstraction"], answer:3, explanation:"Abstraction provides generalization." },
{ id:"OOP45", question:"Which supports multiple implementations?", options:["Encapsulation","Inheritance","Polymorphism","Abstraction"], answer:2, explanation:"Polymorphism supports multiple implementations." },

{ id:"OOP46", question:"Which concept is achieved using interfaces?", options:["Encapsulation","Inheritance","Abstraction","Polymorphism"], answer:2, explanation:"Interfaces achieve abstraction." },
{ id:"OOP47", question:"Which concept improves code modularity?", options:["Encapsulation","Inheritance","Polymorphism","Abstraction"], answer:0, explanation:"Encapsulation improves modularity." },
{ id:"OOP48", question:"Which OOPS feature increases flexibility?", options:["Encapsulation","Inheritance","Polymorphism","Abstraction"], answer:2, explanation:"Polymorphism increases flexibility." },
{ id:"OOP49", question:"Which concept groups related data?", options:["Encapsulation","Inheritance","Polymorphism","Abstraction"], answer:0, explanation:"Encapsulation groups data and methods." },
{ id:"OOP50", question:"Which concept enables code sharing?", options:["Encapsulation","Inheritance","Polymorphism","Abstraction"], answer:1, explanation:"Inheritance enables code sharing." },

{ id:"OOP51", question:"Which concept is also called data hiding?", options:["Abstraction","Encapsulation","Inheritance","Polymorphism"], answer:1, explanation:"Encapsulation is data hiding." },
{ id:"OOP52", question:"Which concept reduces redundancy?", options:["Encapsulation","Inheritance","Polymorphism","Abstraction"], answer:1, explanation:"Inheritance reduces redundancy." },
{ id:"OOP53", question:"Which concept allows overriding?", options:["Encapsulation","Inheritance","Abstraction","Compilation"], answer:1, explanation:"Inheritance allows overriding." },
{ id:"OOP54", question:"Which concept focuses on interface not implementation?", options:["Encapsulation","Inheritance","Abstraction","Polymorphism"], answer:2, explanation:"Abstraction focuses on interface." },
{ id:"OOP55", question:"Which OOPS concept is used in design patterns?", options:["Encapsulation","Inheritance","Polymorphism","All"], answer:3, explanation:"All OOPS concepts are used." },

{ id:"OOP56", question:"Which concept avoids tight coupling?", options:["Encapsulation","Inheritance","Abstraction","Polymorphism"], answer:2, explanation:"Abstraction avoids tight coupling." },
{ id:"OOP57", question:"Which concept enables substitutability?", options:["Encapsulation","Inheritance","Polymorphism","Abstraction"], answer:2, explanation:"Polymorphism enables substitutability." },
{ id:"OOP58", question:"Which feature supports overriding at runtime?", options:["Static binding","Dynamic binding","Compilation","Linking"], answer:1, explanation:"Dynamic binding supports runtime overriding." },
{ id:"OOP59", question:"Which concept supports reuse without inheritance?", options:["Composition","Encapsulation","Polymorphism","Abstraction"], answer:0, explanation:"Composition supports reuse without inheritance." },
{ id:"OOP60", question:"Which concept focuses on what an object does?", options:["Encapsulation","Inheritance","Abstraction","Polymorphism"], answer:2, explanation:"Abstraction focuses on behavior." },

{ id:"OOP61", question:"Which concept ensures implementation independence?", options:["Encapsulation","Inheritance","Abstraction","Polymorphism"], answer:2, explanation:"Abstraction ensures independence." },
{ id:"OOP62", question:"Which concept uses method signatures?", options:["Encapsulation","Inheritance","Polymorphism","Abstraction"], answer:2, explanation:"Polymorphism relies on method signatures." },
{ id:"OOP63", question:"Which concept allows general-to-specific design?", options:["Encapsulation","Inheritance","Abstraction","Polymorphism"], answer:1, explanation:"Inheritance allows specialization." },
{ id:"OOP64", question:"Which concept simplifies testing?", options:["Encapsulation","Abstraction","Inheritance","Polymorphism"], answer:1, explanation:"Abstraction simplifies testing." },
{ id:"OOP65", question:"Which is core benefit of OOPS?", options:["Speed","Security","Reusability","All"], answer:3, explanation:"All are benefits of OOPS." },

{ id:"OOP66", question:"Which concept supports interface-based programming?", options:["Encapsulation","Inheritance","Abstraction","Polymorphism"], answer:2, explanation:"Abstraction supports interface-based programming." },
{ id:"OOP67", question:"Which improves code extensibility?", options:["Encapsulation","Inheritance","Polymorphism","All"], answer:3, explanation:"All improve extensibility." },
{ id:"OOP68", question:"Which concept avoids duplicate code?", options:["Encapsulation","Inheritance","Abstraction","Polymorphism"], answer:1, explanation:"Inheritance avoids duplication." },
{ id:"OOP69", question:"Which concept helps replace conditional logic?", options:["Encapsulation","Inheritance","Polymorphism","Abstraction"], answer:2, explanation:"Polymorphism replaces conditionals." },
{ id:"OOP70", question:"Which concept focuses on object behavior?", options:["Encapsulation","Inheritance","Abstraction","Polymorphism"], answer:3, explanation:"Polymorphism focuses on behavior." },

{ id:"OOP71", question:"Which concept uses overriding and overloading?", options:["Encapsulation","Inheritance","Polymorphism","Abstraction"], answer:2, explanation:"Polymorphism uses both." },
{ id:"OOP72", question:"Which concept ensures data integrity?", options:["Encapsulation","Inheritance","Abstraction","Polymorphism"], answer:0, explanation:"Encapsulation ensures integrity." },
{ id:"OOP73", question:"Which improves software maintainability?", options:["Encapsulation","Inheritance","Polymorphism","All"], answer:3, explanation:"All improve maintainability." },
{ id:"OOP74", question:"Which concept supports dynamic behavior?", options:["Encapsulation","Inheritance","Polymorphism","Abstraction"], answer:2, explanation:"Polymorphism supports dynamic behavior." },
{ id:"OOP75", question:"Which concept hides complexity?", options:["Encapsulation","Inheritance","Abstraction","Polymorphism"], answer:2, explanation:"Abstraction hides complexity." },

{ id:"OOP76", question:"Which concept enables runtime decision making?", options:["Encapsulation","Inheritance","Polymorphism","Abstraction"], answer:2, explanation:"Polymorphism enables runtime decisions." },
{ id:"OOP77", question:"Which concept is foundation of OOPS?", options:["Encapsulation","Inheritance","Polymorphism","Object"], answer:3, explanation:"Object is foundation of OOPS." },
{ id:"OOP78", question:"Which concept groups behavior with data?", options:["Encapsulation","Inheritance","Abstraction","Polymorphism"], answer:0, explanation:"Encapsulation groups data and behavior." },
{ id:"OOP79", question:"Which concept models real-world entities?", options:["Encapsulation","Inheritance","Polymorphism","All"], answer:3, explanation:"OOPS models real-world entities." },
{ id:"OOP80", question:"Which concept supports framework extensibility?", options:["Encapsulation","Inheritance","Polymorphism","All"], answer:3, explanation:"All support extensibility." },

{ id:"OOP81", question:"Which concept enables overriding base behavior?", options:["Encapsulation","Inheritance","Abstraction","Compilation"], answer:1, explanation:"Inheritance allows overriding." },
{ id:"OOP82", question:"Which concept helps avoid code duplication?", options:["Encapsulation","Inheritance","Polymorphism","Abstraction"], answer:1, explanation:"Inheritance avoids duplication." },
{ id:"OOP83", question:"Which OOPS concept improves adaptability?", options:["Encapsulation","Inheritance","Polymorphism","Abstraction"], answer:2, explanation:"Polymorphism improves adaptability." },
{ id:"OOP84", question:"Which concept supports loose coupling?", options:["Encapsulation","Inheritance","Abstraction","Polymorphism"], answer:2, explanation:"Abstraction supports loose coupling." },
{ id:"OOP85", question:"Which concept provides base for SOLID principles?", options:["Encapsulation","Inheritance","Polymorphism","All"], answer:3, explanation:"All are used in SOLID." },

{ id:"OOP86", question:"Which concept supports interchangeable objects?", options:["Encapsulation","Inheritance","Polymorphism","Abstraction"], answer:2, explanation:"Polymorphism supports interchangeability." },
{ id:"OOP87", question:"Which concept allows code generalization?", options:["Encapsulation","Inheritance","Abstraction","Polymorphism"], answer:2, explanation:"Abstraction generalizes code." },
{ id:"OOP88", question:"Which OOPS concept is compile-time independent?", options:["Encapsulation","Inheritance","Abstraction","Polymorphism"], answer:3, explanation:"Polymorphism allows runtime binding." },
{ id:"OOP89", question:"Which concept reduces dependency?", options:["Encapsulation","Inheritance","Abstraction","Polymorphism"], answer:2, explanation:"Abstraction reduces dependency." },
{ id:"OOP90", question:"Which concept enables method substitution?", options:["Encapsulation","Inheritance","Polymorphism","Abstraction"], answer:2, explanation:"Polymorphism enables substitution." },

{ id:"OOP91", question:"Which OOPS concept ensures scalability?", options:["Encapsulation","Inheritance","Polymorphism","All"], answer:3, explanation:"All contribute to scalability." },
{ id:"OOP92", question:"Which concept supports code evolution?", options:["Encapsulation","Inheritance","Polymorphism","All"], answer:3, explanation:"All support evolution." },
{ id:"OOP93", question:"Which concept helps build extensible APIs?", options:["Encapsulation","Inheritance","Abstraction","Polymorphism"], answer:2, explanation:"Abstraction helps build APIs." },
{ id:"OOP94", question:"Which concept supports behavior variation?", options:["Encapsulation","Inheritance","Polymorphism","Abstraction"], answer:2, explanation:"Polymorphism supports behavior variation." },
{ id:"OOP95", question:"Which concept is key to dynamic systems?", options:["Encapsulation","Inheritance","Polymorphism","Abstraction"], answer:2, explanation:"Polymorphism is key to dynamics." },

{ id:"OOP96", question:"Which OOPS feature increases robustness?", options:["Encapsulation","Inheritance","Polymorphism","All"], answer:3, explanation:"All features increase robustness." },
{ id:"OOP97", question:"Which concept ensures separation of concerns?", options:["Encapsulation","Inheritance","Abstraction","Polymorphism"], answer:2, explanation:"Abstraction ensures separation." },
{ id:"OOP98", question:"Which concept allows method replacement?", options:["Encapsulation","Inheritance","Polymorphism","Abstraction"], answer:2, explanation:"Polymorphism allows replacement." },
{ id:"OOP99", question:"Which concept enables hierarchical classification?", options:["Encapsulation","Inheritance","Abstraction","Polymorphism"], answer:1, explanation:"Inheritance enables hierarchy." },
{ id:"OOP100", question:"Which OOPS concept is most tested in exams?", options:["Encapsulation","Inheritance","Polymorphism","All"], answer:3, explanation:"All core OOPS concepts are heavily tested." }
],
"Inheritance":[
{ id:"IN01", question:"Inheritance represents which relationship?", options:["has-a","uses-a","is-a","part-of"], answer:2, explanation:"Inheritance represents an IS-A relationship." },
{ id:"IN02", question:"Which keyword is used for inheritance in Java?", options:["extends","implements","inherits","super"], answer:0, explanation:"Java uses 'extends' for class inheritance." },
{ id:"IN03", question:"Which symbol is used for inheritance in C++?", options:[":", "::", "->", "."], answer:0, explanation:"C++ uses ':' for inheritance." },
{ id:"IN04", question:"Which inheritance is NOT supported directly in Java classes?", options:["Single","Multilevel","Multiple","Hierarchical"], answer:2, explanation:"Java does not support multiple inheritance with classes." },
{ id:"IN05", question:"Multiple inheritance in Java is achieved using:", options:["Abstract classes","Interfaces","Packages","Objects"], answer:1, explanation:"Interfaces allow multiple inheritance in Java." },

{ id:"IN06", question:"Which access specifier members are NOT inherited?", options:["public","protected","private","default"], answer:2, explanation:"Private members are not inherited." },
{ id:"IN07", question:"Which inheritance allows one class to inherit from another derived class?", options:["Single","Multiple","Multilevel","Hierarchical"], answer:2, explanation:"Multilevel inheritance forms a chain." },
{ id:"IN08", question:"Which inheritance causes the diamond problem?", options:["Single","Multiple","Multilevel","Hierarchical"], answer:1, explanation:"Multiple inheritance causes diamond problem." },
{ id:"IN09", question:"Diamond problem is solved in C++ using:", options:["virtual functions","virtual inheritance","abstract classes","interfaces"], answer:1, explanation:"Virtual inheritance resolves ambiguity." },
{ id:"IN10", question:"Which inheritance allows multiple subclasses from a single base class?", options:["Single","Multiple","Hierarchical","Hybrid"], answer:2, explanation:"Hierarchical inheritance has one base, many derived." },

{ id:"IN11", question:"Which keyword refers to parent class object in Java?", options:["this","parent","super","base"], answer:2, explanation:"super refers to parent class." },
{ id:"IN12", question:"Which function cannot be overridden?", options:["virtual","static","abstract","protected"], answer:1, explanation:"Static methods cannot be overridden." },
{ id:"IN13", question:"Which method binding occurs at runtime?", options:["Static","Early","Dynamic","Compile-time"], answer:2, explanation:"Dynamic binding occurs at runtime." },
{ id:"IN14", question:"Which inheritance increases code reusability?", options:["Encapsulation","Polymorphism","Inheritance","Abstraction"], answer:2, explanation:"Inheritance promotes code reuse." },
{ id:"IN15", question:"Which constructor is called first in inheritance?", options:["Derived","Base","Last","Random"], answer:1, explanation:"Base class constructor executes first." },

{ id:"IN16", question:"Which keyword is used to prevent inheritance in Java?", options:["static","final","const","private"], answer:1, explanation:"final prevents inheritance." },
{ id:"IN17", question:"Can constructors be inherited?", options:["Yes","No","Sometimes","Only in C++"], answer:1, explanation:"Constructors are not inherited." },
{ id:"IN18", question:"Which inheritance combines two or more types?", options:["Single","Hybrid","Multiple","Hierarchical"], answer:1, explanation:"Hybrid inheritance combines types." },
{ id:"IN19", question:"Which inheritance improves maintainability?", options:["Multiple","Hierarchical","Single","All"], answer:3, explanation:"All inheritance types improve maintainability." },
{ id:"IN20", question:"Which concept allows method redefinition in child class?", options:["Overloading","Overriding","Hiding","Encapsulation"], answer:1, explanation:"Overriding redefines parent methods." },

{ id:"IN21", question:"Which C++ keyword enables runtime polymorphism?", options:["static","virtual","inline","const"], answer:1, explanation:"virtual enables runtime polymorphism." },
{ id:"IN22", question:"Which inheritance type is most restrictive?", options:["Single","Multiple","Hierarchical","Hybrid"], answer:0, explanation:"Single inheritance is simplest and most restrictive." },
{ id:"IN23", question:"Which inheritance allows code sharing across classes?", options:["Abstraction","Encapsulation","Inheritance","Polymorphism"], answer:2, explanation:"Inheritance allows sharing." },
{ id:"IN24", question:"Which inheritance leads to ambiguity without virtual base class?", options:["Single","Multiple","Multilevel","Hierarchical"], answer:1, explanation:"Multiple inheritance causes ambiguity." },
{ id:"IN25", question:"Which member can be accessed in derived class?", options:["private","protected","none","constructor"], answer:1, explanation:"Protected members are accessible." },

{ id:"IN26", question:"Which inheritance promotes extensibility?", options:["Encapsulation","Inheritance","Polymorphism","Abstraction"], answer:1, explanation:"Inheritance promotes extensibility." },
{ id:"IN27", question:"Which Java keyword invokes parent constructor?", options:["this()","super()","parent()","base()"], answer:1, explanation:"super() calls parent constructor." },
{ id:"IN28", question:"Which inheritance is also called linear inheritance?", options:["Single","Multiple","Multilevel","Hybrid"], answer:2, explanation:"Multilevel inheritance is linear." },
{ id:"IN29", question:"Which inheritance allows multiple base classes?", options:["Single","Multilevel","Multiple","Hierarchical"], answer:2, explanation:"Multiple inheritance has multiple base classes." },
{ id:"IN30", question:"Which class cannot be inherited?", options:["abstract","final","public","protected"], answer:1, explanation:"Final classes cannot be inherited." },

{ id:"IN31", question:"Which function call is resolved at compile time?", options:["Virtual","Overridden","Static","Dynamic"], answer:2, explanation:"Static binding occurs at compile time." },
{ id:"IN32", question:"Which inheritance is safest?", options:["Multiple","Hybrid","Single","Hierarchical"], answer:2, explanation:"Single inheritance is safest." },
{ id:"IN33", question:"Which inheritance increases coupling?", options:["Single","Multiple","Hierarchical","None"], answer:1, explanation:"Multiple inheritance increases coupling." },
{ id:"IN34", question:"Which keyword allows overriding in Java?", options:["override","@Override","virtual","extends"], answer:1, explanation:"@Override annotation indicates overriding." },
{ id:"IN35", question:"Which inheritance is default in Java?", options:["Single","Multiple","Hybrid","None"], answer:0, explanation:"Java uses single inheritance for classes." },

{ id:"IN36", question:"Which member is inherited but not accessible?", options:["public","protected","private","default"], answer:2, explanation:"Private members are inherited but inaccessible." },
{ id:"IN37", question:"Which inheritance improves polymorphism?", options:["Single","Inheritance","Multiple","All"], answer:3, explanation:"All inheritance types support polymorphism." },
{ id:"IN38", question:"Which inheritance creates complex class hierarchy?", options:["Single","Hierarchical","Multiple","Hybrid"], answer:3, explanation:"Hybrid inheritance is complex." },
{ id:"IN39", question:"Which inheritance violates simplicity?", options:["Single","Multiple","Multilevel","Hierarchical"], answer:1, explanation:"Multiple inheritance violates simplicity." },
{ id:"IN40", question:"Which class members are inherited in Java?", options:["Methods","Variables","Both","None"], answer:2, explanation:"Both variables and methods are inherited." },

{ id:"IN41", question:"Which inheritance enables specialization?", options:["Encapsulation","Inheritance","Polymorphism","Abstraction"], answer:1, explanation:"Inheritance enables specialization." },
{ id:"IN42", question:"Which inheritance creates parent-child hierarchy?", options:["Inheritance","Encapsulation","Composition","Aggregation"], answer:0, explanation:"Inheritance creates hierarchy." },
{ id:"IN43", question:"Which inheritance allows code modification without affecting parent?", options:["Overloading","Overriding","Hiding","Binding"], answer:1, explanation:"Overriding modifies behavior." },
{ id:"IN44", question:"Which inheritance is preferred over composition?", options:["Never","Sometimes","Always","Rarely"], answer:1, explanation:"Inheritance is sometimes preferred." },
{ id:"IN45", question:"Which inheritance violates encapsulation?", options:["Single","Multiple","Improper inheritance","None"], answer:2, explanation:"Improper inheritance violates encapsulation." },

{ id:"IN46", question:"Which inheritance allows method reuse?", options:["Encapsulation","Inheritance","Abstraction","Polymorphism"], answer:1, explanation:"Inheritance allows reuse." },
{ id:"IN47", question:"Which inheritance causes tight coupling?", options:["Single","Multiple","Hierarchical","None"], answer:1, explanation:"Multiple inheritance increases coupling." },
{ id:"IN48", question:"Which inheritance is easiest to implement?", options:["Single","Multiple","Hybrid","Multilevel"], answer:0, explanation:"Single inheritance is easiest." },
{ id:"IN49", question:"Which inheritance supports overriding?", options:["Single","Multiple","Multilevel","All"], answer:3, explanation:"All support overriding." },
{ id:"IN50", question:"Which inheritance is best for extensibility?", options:["Single","Multiple","Hierarchical","Hybrid"], answer:2, explanation:"Hierarchical inheritance supports extensibility." },

{ id:"IN51", question:"Which concept is tightly linked with inheritance?", options:["Encapsulation","Polymorphism","Abstraction","All"], answer:3, explanation:"Inheritance links with all OOP concepts." },
{ id:"IN52", question:"Which inheritance uses base and derived classes?", options:["Inheritance","Composition","Aggregation","Association"], answer:0, explanation:"Inheritance uses base and derived classes." },
{ id:"IN53", question:"Which inheritance supports method overriding best?", options:["Single","Multiple","Multilevel","All"], answer:3, explanation:"All support overriding." },
{ id:"IN54", question:"Which inheritance is discouraged in Java?", options:["Single","Multiple","Multilevel","Hierarchical"], answer:1, explanation:"Multiple inheritance with classes is discouraged." },
{ id:"IN55", question:"Which inheritance promotes hierarchical classification?", options:["Single","Hierarchical","Multiple","Hybrid"], answer:1, explanation:"Hierarchical inheritance promotes classification." },

{ id:"IN56", question:"Which inheritance is used in real-world modeling?", options:["Single","Hierarchical","Multiple","All"], answer:3, explanation:"All are used in modeling." },
{ id:"IN57", question:"Which inheritance creates dependency?", options:["Inheritance","Encapsulation","Abstraction","None"], answer:0, explanation:"Inheritance creates dependency." },
{ id:"IN58", question:"Which inheritance allows code extension?", options:["Inheritance","Composition","Aggregation","Association"], answer:0, explanation:"Inheritance allows extension." },
{ id:"IN59", question:"Which inheritance type is simplest?", options:["Single","Multiple","Hybrid","Hierarchical"], answer:0, explanation:"Single inheritance is simplest." },
{ id:"IN60", question:"Which inheritance can lead to fragile base class problem?", options:["Single","Multiple","All","None"], answer:2, explanation:"All inheritance can lead to fragile base class problem." },

{ id:"IN61", question:"Which inheritance allows polymorphic behavior?", options:["Inheritance","Encapsulation","Aggregation","Association"], answer:0, explanation:"Inheritance enables polymorphism." },
{ id:"IN62", question:"Which inheritance helps reduce code duplication?", options:["Inheritance","Encapsulation","Abstraction","All"], answer:0, explanation:"Inheritance reduces duplication." },
{ id:"IN63", question:"Which inheritance should be avoided for flexibility?", options:["Single","Multiple","Hierarchical","Hybrid"], answer:1, explanation:"Multiple inheritance reduces flexibility." },
{ id:"IN64", question:"Which inheritance supports reuse and extensibility?", options:["Inheritance","Composition","Aggregation","Association"], answer:0, explanation:"Inheritance supports both." },
{ id:"IN65", question:"Which inheritance type is most complex?", options:["Single","Multiple","Hybrid","Hierarchical"], answer:2, explanation:"Hybrid inheritance is most complex." },

{ id:"IN66", question:"Which inheritance is default in C++?", options:["Single","Multiple","Multilevel","Hierarchical"], answer:1, explanation:"C++ supports multiple inheritance by default." },
{ id:"IN67", question:"Which inheritance uses virtual base classes?", options:["Single","Multiple","Multilevel","Hierarchical"], answer:1, explanation:"Virtual base classes are used in multiple inheritance." },
{ id:"IN68", question:"Which inheritance enables specialization and generalization?", options:["Inheritance","Polymorphism","Encapsulation","Abstraction"], answer:0, explanation:"Inheritance enables both." },
{ id:"IN69", question:"Which inheritance increases complexity?", options:["Single","Multiple","Hierarchical","None"], answer:1, explanation:"Multiple inheritance increases complexity." },
{ id:"IN70", question:"Which inheritance supports overriding but not overloading?", options:["Single","Multiple","All","None"], answer:2, explanation:"All inheritance types support overriding." },

{ id:"IN71", question:"Which inheritance supports code scalability?", options:["Inheritance","Encapsulation","Composition","Association"], answer:0, explanation:"Inheritance supports scalability." },
{ id:"IN72", question:"Which inheritance encourages tight coupling?", options:["Single","Multiple","Hierarchical","None"], answer:1, explanation:"Multiple inheritance encourages tight coupling." },
{ id:"IN73", question:"Which inheritance provides parent-child behavior?", options:["Inheritance","Composition","Aggregation","Association"], answer:0, explanation:"Inheritance provides parent-child behavior." },
{ id:"IN74", question:"Which inheritance is preferred in Java design?", options:["Single","Multiple","Hybrid","Hierarchical"], answer:0, explanation:"Single inheritance is preferred." },
{ id:"IN75", question:"Which inheritance type allows method reuse without duplication?", options:["Inheritance","Encapsulation","Abstraction","Polymorphism"], answer:0, explanation:"Inheritance allows reuse." },

{ id:"IN76", question:"Which inheritance is best for code maintainability?", options:["Single","Multiple","Hierarchical","Hybrid"], answer:2, explanation:"Hierarchical inheritance improves maintainability." },
{ id:"IN77", question:"Which inheritance may cause ambiguity?", options:["Single","Multiple","Hierarchical","None"], answer:1, explanation:"Multiple inheritance causes ambiguity." },
{ id:"IN78", question:"Which inheritance supports substitutability principle?", options:["Inheritance","Encapsulation","Abstraction","Aggregation"], answer:0, explanation:"Inheritance supports LSP." },
{ id:"IN79", question:"Which inheritance supports runtime method dispatch?", options:["Inheritance","Polymorphism","Encapsulation","None"], answer:1, explanation:"Polymorphism enables runtime dispatch." },
{ id:"IN80", question:"Which inheritance supports specialization?", options:["Inheritance","Encapsulation","Abstraction","Composition"], answer:0, explanation:"Inheritance supports specialization." },

{ id:"IN81", question:"Which inheritance improves hierarchical design?", options:["Single","Hierarchical","Multiple","Hybrid"], answer:1, explanation:"Hierarchical improves design." },
{ id:"IN82", question:"Which inheritance can lead to base class dependency?", options:["Inheritance","Composition","Aggregation","None"], answer:0, explanation:"Inheritance causes dependency." },
{ id:"IN83", question:"Which inheritance type is most flexible?", options:["Single","Multiple","Composition","Hierarchical"], answer:2, explanation:"Composition is more flexible than inheritance." },
{ id:"IN84", question:"Which inheritance supports code evolution?", options:["Inheritance","Encapsulation","Aggregation","Association"], answer:0, explanation:"Inheritance supports evolution." },
{ id:"IN85", question:"Which inheritance is tightly coupled?", options:["Inheritance","Composition","Aggregation","Association"], answer:0, explanation:"Inheritance is tightly coupled." },

{ id:"IN86", question:"Which inheritance is less reusable?", options:["Single","Multiple","Inheritance","None"], answer:2, explanation:"Inheritance is less reusable than composition." },
{ id:"IN87", question:"Which inheritance supports parent method reuse?", options:["Inheritance","Encapsulation","Abstraction","Aggregation"], answer:0, explanation:"Inheritance reuses parent methods." },
{ id:"IN88", question:"Which inheritance can cause maintenance issues?", options:["Single","Multiple","Hierarchical","None"], answer:1, explanation:"Multiple inheritance causes maintenance issues." },
{ id:"IN89", question:"Which inheritance supports runtime polymorphism?", options:["Inheritance","Encapsulation","Abstraction","Association"], answer:0, explanation:"Inheritance enables runtime polymorphism." },
{ id:"IN90", question:"Which inheritance best represents real-world hierarchy?", options:["Single","Hierarchical","Multiple","Hybrid"], answer:1, explanation:"Hierarchical inheritance fits real-world models." },

{ id:"IN91", question:"Which inheritance supports overriding methods?", options:["Inheritance","Encapsulation","Aggregation","None"], answer:0, explanation:"Inheritance supports overriding." },
{ id:"IN92", question:"Which inheritance allows specialization of behavior?", options:["Inheritance","Polymorphism","Abstraction","All"], answer:3, explanation:"All support specialization." },
{ id:"IN93", question:"Which inheritance allows extending functionality?", options:["Inheritance","Encapsulation","Aggregation","Association"], answer:0, explanation:"Inheritance extends functionality." },
{ id:"IN94", question:"Which inheritance leads to code hierarchy?", options:["Inheritance","Composition","Aggregation","Association"], answer:0, explanation:"Inheritance leads to hierarchy." },
{ id:"IN95", question:"Which inheritance supports base class reuse?", options:["Inheritance","Encapsulation","Abstraction","None"], answer:0, explanation:"Inheritance reuses base class." },

{ id:"IN96", question:"Which inheritance is simplest to debug?", options:["Single","Multiple","Hybrid","Hierarchical"], answer:0, explanation:"Single inheritance is simplest." },
{ id:"IN97", question:"Which inheritance increases design complexity?", options:["Single","Multiple","Hierarchical","None"], answer:1, explanation:"Multiple inheritance increases complexity." },
{ id:"IN98", question:"Which inheritance should be used carefully?", options:["Single","Multiple","Hierarchical","None"], answer:1, explanation:"Multiple inheritance should be used carefully." },
{ id:"IN99", question:"Which inheritance promotes hierarchical abstraction?", options:["Single","Hierarchical","Multiple","Hybrid"], answer:1, explanation:"Hierarchical promotes abstraction." },
{ id:"IN100", question:"Which inheritance forms the backbone of OOP?", options:["Inheritance","Encapsulation","Polymorphism","Abstraction"], answer:0, explanation:"Inheritance is fundamental to OOP." }
],
"Class & Object":[
{ id:"CO01", question:"A class is best described as:", options:["An instance","A blueprint","A variable","A function"], answer:1, explanation:"A class is a blueprint for creating objects." },
{ id:"CO02", question:"An object is:", options:["A data type","An instance of a class","A function","A package"], answer:1, explanation:"An object is an instance of a class." },
{ id:"CO03", question:"Which keyword is used to create an object in Java?", options:["alloc","create","new","malloc"], answer:2, explanation:"The 'new' keyword creates objects in Java." },
{ id:"CO04", question:"Which operator creates objects in C++?", options:["new","malloc","alloc","create"], answer:0, explanation:"C++ uses the new operator." },
{ id:"CO05", question:"Which component of a class stores data?", options:["Methods","Objects","Variables","Constructors"], answer:2, explanation:"Variables store data." },

{ id:"CO06", question:"Which component defines behavior of a class?", options:["Variables","Objects","Methods","Packages"], answer:2, explanation:"Methods define behavior." },
{ id:"CO07", question:"Which access specifier allows access within the same package?", options:["private","protected","public","default"], answer:3, explanation:"Default access allows same package access." },
{ id:"CO08", question:"How many objects can be created from one class?", options:["One","Two","Limited","Unlimited"], answer:3, explanation:"Unlimited objects can be created." },
{ id:"CO09", question:"Which of these is NOT a member of a class?", options:["Variable","Method","Constructor","Loop"], answer:3, explanation:"Loop is not a class member." },
{ id:"CO10", question:"Which memory area stores objects?", options:["Stack","Register","Heap","Cache"], answer:2, explanation:"Objects are stored in heap memory." },

{ id:"CO11", question:"Which keyword refers to current object in Java?", options:["this","self","current","object"], answer:0, explanation:"this refers to the current object." },
{ id:"CO12", question:"Which keyword refers to current object in C++?", options:["this","self","super","base"], answer:0, explanation:"this pointer refers to current object." },
{ id:"CO13", question:"Which member belongs to class rather than object?", options:["Instance variable","Local variable","Static variable","Parameter"], answer:2, explanation:"Static members belong to class." },
{ id:"CO14", question:"Which class member is shared by all objects?", options:["Instance variable","Static variable","Local variable","Parameter"], answer:1, explanation:"Static variables are shared." },
{ id:"CO15", question:"Which method can be called without creating object?", options:["Instance method","Abstract method","Static method","Final method"], answer:2, explanation:"Static methods can be called without objects." },

{ id:"CO16", question:"Which of these best defines encapsulation?", options:["Inheritance","Binding","Wrapping data and methods","Polymorphism"], answer:2, explanation:"Encapsulation wraps data and methods together." },
{ id:"CO17", question:"Which access specifier provides maximum restriction?", options:["public","protected","default","private"], answer:3, explanation:"private provides maximum restriction." },
{ id:"CO18", question:"Which class cannot have objects?", options:["Concrete","Abstract","Public","Final"], answer:1, explanation:"Abstract classes cannot be instantiated." },
{ id:"CO19", question:"Which class must be inherited?", options:["Abstract","Final","Static","Private"], answer:0, explanation:"Abstract classes are meant to be inherited." },
{ id:"CO20", question:"Which keyword prevents object creation through inheritance?", options:["static","private","final","abstract"], answer:2, explanation:"final prevents inheritance." },

{ id:"CO21", question:"Which of these allows multiple objects with same data?", options:["Class","Object","Reference","Method"], answer:1, explanation:"Objects can have same state." },
{ id:"CO22", question:"Which is mandatory in a class?", options:["Variables","Methods","Constructor","None"], answer:3, explanation:"None are mandatory explicitly." },
{ id:"CO23", question:"Which keyword is used to access class members?", options:[".","::","->","all"], answer:3, explanation:"Java uses ., C++ uses :: or ->." },
{ id:"CO24", question:"Which operator accesses object members in Java?", options:[".","::","->","=>"], answer:0, explanation:"Dot operator is used in Java." },
{ id:"CO25", question:"Which operator accesses object members via pointer in C++?", options:[".","::","->","*"], answer:2, explanation:"-> accesses members via pointer." },

{ id:"CO26", question:"Which class member initializes objects?", options:["Method","Variable","Constructor","Destructor"], answer:2, explanation:"Constructor initializes objects." },
{ id:"CO27", question:"Which method has same name as class?", options:["Destructor","Constructor","Static","Final"], answer:1, explanation:"Constructor has same name as class." },
{ id:"CO28", question:"Which is called when object is destroyed in C++?", options:["Constructor","Finalizer","Destructor","Delete"], answer:2, explanation:"Destructor is called on destruction." },
{ id:"CO29", question:"Which language uses garbage collection?", options:["C","C++","Java","Assembly"], answer:2, explanation:"Java uses garbage collection." },
{ id:"CO30", question:"Which function frees object memory in C++?", options:["delete","free","remove","clear"], answer:0, explanation:"delete frees object memory." },

{ id:"CO31", question:"Which class member cannot be static?", options:["Variable","Method","Constructor","Block"], answer:2, explanation:"Constructors cannot be static." },
{ id:"CO32", question:"Which class member is executed only once?", options:["Constructor","Instance block","Static block","Method"], answer:2, explanation:"Static block runs once." },
{ id:"CO33", question:"Which block initializes static variables?", options:["Constructor","Static block","Instance block","Method"], answer:1, explanation:"Static block initializes static variables." },
{ id:"CO34", question:"Which block runs before constructor in Java?", options:["Method","Static block","Instance block","Main"], answer:2, explanation:"Instance block runs before constructor." },
{ id:"CO35", question:"Which class can contain main() method?", options:["Any","Abstract","Final","Public"], answer:0, explanation:"Any class can contain main()." },

{ id:"CO36", question:"Which object state refers to data members?", options:["Behavior","Identity","State","Method"], answer:2, explanation:"State refers to data members." },
{ id:"CO37", question:"Which object behavior refers to methods?", options:["State","Identity","Behavior","Structure"], answer:2, explanation:"Behavior is defined by methods." },
{ id:"CO38", question:"Which object property uniquely identifies it?", options:["State","Behavior","Identity","Class"], answer:2, explanation:"Identity uniquely identifies object." },
{ id:"CO39", question:"Which object lifecycle starts with creation?", options:["Initialization","Instantiation","Execution","Termination"], answer:1, explanation:"Instantiation creates object." },
{ id:"CO40", question:"Which reference holds object address?", options:["Variable","Method","Pointer","Reference"], answer:3, explanation:"Reference holds object address." },

{ id:"CO41", question:"Which class member is hidden using encapsulation?", options:["Method","Variable","Object","Class"], answer:1, explanation:"Variables are hidden." },
{ id:"CO42", question:"Which class member is accessed using getter?", options:["Method","Variable","Constructor","Block"], answer:1, explanation:"Getters access variables." },
{ id:"CO43", question:"Which keyword allows calling another constructor?", options:["this","super","base","parent"], answer:0, explanation:"this() calls another constructor." },
{ id:"CO44", question:"Which keyword calls parent class constructor?", options:["this","super","parent","base"], answer:1, explanation:"super() calls parent constructor." },
{ id:"CO45", question:"Which class member can be overloaded?", options:["Constructor","Method","Both","None"], answer:2, explanation:"Both can be overloaded." },

{ id:"CO46", question:"Which class member can be overridden?", options:["Constructor","Static method","Instance method","Variable"], answer:2, explanation:"Instance methods can be overridden." },
{ id:"CO47", question:"Which class member cannot be overridden?", options:["Static method","Instance method","Abstract method","Virtual method"], answer:0, explanation:"Static methods cannot be overridden." },
{ id:"CO48", question:"Which class member is optional?", options:["Constructor","Variable","Method","All"], answer:3, explanation:"All are optional explicitly." },
{ id:"CO49", question:"Which class type allows incomplete implementation?", options:["Concrete","Final","Abstract","Static"], answer:2, explanation:"Abstract class allows incomplete implementation." },
{ id:"CO50", question:"Which class can have abstract methods?", options:["Concrete","Final","Abstract","Static"], answer:2, explanation:"Abstract class can have abstract methods." },

{ id:"CO51", question:"Which class cannot be inherited?", options:["Abstract","Final","Public","Static"], answer:1, explanation:"Final class cannot be inherited." },
{ id:"CO52", question:"Which class can be instantiated?", options:["Abstract","Interface","Concrete","None"], answer:2, explanation:"Concrete classes can be instantiated." },
{ id:"CO53", question:"Which object feature enables message passing?", options:["Method calls","Variables","Constructors","Blocks"], answer:0, explanation:"Method calls enable message passing." },
{ id:"CO54", question:"Which class member belongs to object?", options:["Static","Class variable","Instance variable","Static block"], answer:2, explanation:"Instance variables belong to objects." },
{ id:"CO55", question:"Which member is common across all objects?", options:["Instance variable","Static variable","Local variable","Parameter"], answer:1, explanation:"Static variables are shared." },

{ id:"CO56", question:"Which class member cannot access instance variables directly?", options:["Instance method","Static method","Constructor","Block"], answer:1, explanation:"Static methods cannot access instance variables directly." },
{ id:"CO57", question:"Which class member executes on object creation?", options:["Method","Static block","Constructor","Main"], answer:2, explanation:"Constructor executes on creation." },
{ id:"CO58", question:"Which class member improves code organization?", options:["Object","Class","Method","All"], answer:3, explanation:"All improve organization." },
{ id:"CO59", question:"Which object feature supports polymorphism?", options:["State","Behavior","Identity","Reference"], answer:1, explanation:"Behavior supports polymorphism." },
{ id:"CO60", question:"Which class member supports abstraction?", options:["Abstract method","Static method","Constructor","Variable"], answer:0, explanation:"Abstract methods support abstraction." },

{ id:"CO61", question:"Which object is created using default constructor?", options:["Initialized","Parameterized","Uninitialized","Anonymous"], answer:0, explanation:"Default constructor initializes object." },
{ id:"CO62", question:"Which class member defines object behavior?", options:["Variable","Method","Constructor","Block"], answer:1, explanation:"Methods define behavior." },
{ id:"CO63", question:"Which class member defines object structure?", options:["Method","Variable","Constructor","Block"], answer:1, explanation:"Variables define structure." },
{ id:"CO64", question:"Which class member cannot return a value?", options:["Method","Constructor","Function","Operator"], answer:1, explanation:"Constructors do not return values." },
{ id:"CO65", question:"Which object feature allows dynamic behavior?", options:["Inheritance","Encapsulation","Polymorphism","Abstraction"], answer:2, explanation:"Polymorphism allows dynamic behavior." },

{ id:"CO66", question:"Which class member initializes static data?", options:["Constructor","Static block","Method","Main"], answer:1, explanation:"Static block initializes static data." },
{ id:"CO67", question:"Which class member is called automatically?", options:["Method","Constructor","Operator","Block"], answer:1, explanation:"Constructor is called automatically." },
{ id:"CO68", question:"Which object feature improves security?", options:["Inheritance","Encapsulation","Polymorphism","Abstraction"], answer:1, explanation:"Encapsulation improves security." },
{ id:"CO69", question:"Which class member is optional but recommended?", options:["Constructor","Getter/Setter","Variable","Method"], answer:1, explanation:"Getter/Setter improves encapsulation." },
{ id:"CO70", question:"Which class member defines object interface?", options:["Variable","Method","Constructor","Block"], answer:1, explanation:"Methods define interface." },

{ id:"CO71", question:"Which class member is executed first in Java?", options:["Main","Static block","Constructor","Instance block"], answer:1, explanation:"Static block executes first." },
{ id:"CO72", question:"Which object feature supports real-world modeling?", options:["Class","Object","Inheritance","All"], answer:3, explanation:"All support modeling." },
{ id:"CO73", question:"Which class can contain only abstract methods?", options:["Interface","Abstract class","Final class","Static class"], answer:0, explanation:"Interface contains only abstract methods (Java <8)." },
{ id:"CO74", question:"Which class member cannot be accessed using object?", options:["Instance variable","Static variable","Method","Constructor"], answer:1, explanation:"Static variables belong to class." },
{ id:"CO75", question:"Which class member improves maintainability?", options:["Encapsulation","Constructor","Object","Method"], answer:0, explanation:"Encapsulation improves maintainability." },

{ id:"CO76", question:"Which object feature enables reuse?", options:["Encapsulation","Inheritance","Polymorphism","Abstraction"], answer:1, explanation:"Inheritance enables reuse." },
{ id:"CO77", question:"Which class member is used for cleanup in C++?", options:["Constructor","Destructor","Method","Block"], answer:1, explanation:"Destructor cleans up resources." },
{ id:"CO78", question:"Which class member is hidden from outside access?", options:["Public","Protected","Private","Default"], answer:2, explanation:"Private members are hidden." },
{ id:"CO79", question:"Which object property is stored in memory?", options:["Behavior","State","Identity","Reference"], answer:1, explanation:"State is stored in memory." },
{ id:"CO80", question:"Which class member defines object creation rules?", options:["Method","Constructor","Block","Variable"], answer:1, explanation:"Constructor defines creation rules." },

{ id:"CO81", question:"Which class can be used as data type?", options:["Primitive","Class","Interface","Enum"], answer:1, explanation:"Class acts as user-defined data type." },
{ id:"CO82", question:"Which object feature supports late binding?", options:["Encapsulation","Inheritance","Polymorphism","Abstraction"], answer:2, explanation:"Polymorphism supports late binding." },
{ id:"CO83", question:"Which class member is optional but common?", options:["Constructor","Method","Variable","All"], answer:3, explanation:"All are common but optional." },
{ id:"CO84", question:"Which object feature hides implementation details?", options:["Inheritance","Encapsulation","Polymorphism","Abstraction"], answer:3, explanation:"Abstraction hides implementation." },
{ id:"CO85", question:"Which class member is inherited?", options:["Constructor","Private variable","Public method","Static block"], answer:2, explanation:"Public methods are inherited." },

{ id:"CO86", question:"Which class member improves readability?", options:["Encapsulation","Method naming","Constructor","Object"], answer:1, explanation:"Proper method naming improves readability." },
{ id:"CO87", question:"Which object feature ensures uniqueness?", options:["State","Behavior","Identity","Class"], answer:2, explanation:"Identity ensures uniqueness." },
{ id:"CO88", question:"Which class member cannot be final?", options:["Method","Variable","Constructor","Class"], answer:2, explanation:"Constructors cannot be final." },
{ id:"CO89", question:"Which object feature allows interaction?", options:["Message passing","State","Identity","Structure"], answer:0, explanation:"Objects interact via message passing." },
{ id:"CO90", question:"Which class member supports data hiding?", options:["Private variable","Public method","Static block","Constructor"], answer:0, explanation:"Private variables support data hiding." },

{ id:"CO91", question:"Which class member improves flexibility?", options:["Encapsulation","Inheritance","Polymorphism","Abstraction"], answer:2, explanation:"Polymorphism improves flexibility." },
{ id:"CO92", question:"Which object feature allows runtime behavior change?", options:["Inheritance","Polymorphism","Encapsulation","Abstraction"], answer:1, explanation:"Polymorphism allows runtime change." },
{ id:"CO93", question:"Which class member must be declared inside class?", options:["Variable","Method","Constructor","All"], answer:3, explanation:"All must be inside class." },
{ id:"CO94", question:"Which object feature improves modularity?", options:["Encapsulation","Inheritance","Polymorphism","Abstraction"], answer:0, explanation:"Encapsulation improves modularity." },
{ id:"CO95", question:"Which class member is responsible for object identity?", options:["Variable","Method","Reference","Constructor"], answer:2, explanation:"Reference identifies object." },

{ id:"CO96", question:"Which class member supports code reuse?", options:["Inheritance","Method","Constructor","Block"], answer:0, explanation:"Inheritance supports reuse." },
{ id:"CO97", question:"Which object feature allows abstraction?", options:["Class","Object","Interface","All"], answer:3, explanation:"All support abstraction." },
{ id:"CO98", question:"Which class member must not have return type?", options:["Method","Constructor","Function","Operator"], answer:1, explanation:"Constructors have no return type." },
{ id:"CO99", question:"Which object feature allows interaction between objects?", options:["Encapsulation","Message passing","Inheritance","Abstraction"], answer:1, explanation:"Message passing allows interaction." },
{ id:"CO100", question:"Which concept forms the foundation of OOP?", options:["Class and Object","Inheritance","Polymorphism","Encapsulation"], answer:0, explanation:"Class and Object are the foundation of OOP." }
],
"Constructors":[
{ id:"CT01", question:"A constructor is used to:", options:["Destroy object","Initialize object","Allocate memory","Call methods"], answer:1, explanation:"Constructors initialize objects." },
{ id:"CT02", question:"Constructor name must be:", options:["Different from class","Same as class","Any name","Uppercase"], answer:1, explanation:"Constructor name must match class name." },
{ id:"CT03", question:"Which of these is NOT a property of constructors?", options:["Same name as class","No return type","Can be static","Called automatically"], answer:2, explanation:"Constructors cannot be static." },
{ id:"CT04", question:"Which constructor has no parameters?", options:["Default","Copy","Parameterized","Static"], answer:0, explanation:"Default constructor has no parameters." },
{ id:"CT05", question:"Which constructor accepts arguments?", options:["Default","Copy","Parameterized","Implicit"], answer:2, explanation:"Parameterized constructors accept arguments." },

{ id:"CT06", question:"If no constructor is defined, Java provides:", options:["No constructor","Parameterized constructor","Default constructor","Copy constructor"], answer:2, explanation:"Java provides default constructor implicitly." },
{ id:"CT07", question:"Which language supports copy constructor explicitly?", options:["Java","C","C++","Python"], answer:2, explanation:"C++ supports copy constructor." },
{ id:"CT08", question:"Copy constructor is used to:", options:["Destroy object","Copy object","Initialize static data","Allocate memory"], answer:1, explanation:"Copy constructor copies one object to another." },
{ id:"CT09", question:"Which constructor is called when object is passed by value in C++?", options:["Default","Copy","Parameterized","Static"], answer:1, explanation:"Copy constructor is invoked." },
{ id:"CT10", question:"Java provides copy constructor by default?", options:["Yes","No","Sometimes","Only for final"], answer:1, explanation:"Java does not provide copy constructor by default." },

{ id:"CT11", question:"Which keyword is used to call another constructor in Java?", options:["super","this","base","parent"], answer:1, explanation:"this() calls another constructor." },
{ id:"CT12", question:"Which keyword calls parent class constructor in Java?", options:["this","super","parent","base"], answer:1, explanation:"super() calls parent constructor." },
{ id:"CT13", question:"Constructor chaining means:", options:["Calling multiple methods","Calling constructor from another","Inheritance","Overloading"], answer:1, explanation:"Constructor chaining is calling one constructor from another." },
{ id:"CT14", question:"Which constructor is called first in inheritance?", options:["Derived","Base","Last","Random"], answer:1, explanation:"Base class constructor is called first." },
{ id:"CT15", question:"Can constructors be overloaded?", options:["Yes","No","Only in Java","Only in C++"], answer:0, explanation:"Constructors can be overloaded." },

{ id:"CT16", question:"Can constructors be overridden?", options:["Yes","No","Sometimes","Only virtual"], answer:1, explanation:"Constructors cannot be overridden." },
{ id:"CT17", question:"Which constructor executes only once per class?", options:["Default","Parameterized","Static","Copy"], answer:2, explanation:"Static constructor executes once." },
{ id:"CT18", question:"Static constructor exists in:", options:["Java","C++","Both","None"], answer:1, explanation:"C++ supports static constructors via static members." },
{ id:"CT19", question:"Java supports static constructors?", options:["Yes","No","Sometimes","Only abstract"], answer:1, explanation:"Java does not support static constructors." },
{ id:"CT20", question:"Which block initializes static variables in Java?", options:["Constructor","Static block","Instance block","Method"], answer:1, explanation:"Static block initializes static variables." },

{ id:"CT21", question:"Which constructor has highest priority during object creation?", options:["Parameterized","Default","Copy","Base"], answer:0, explanation:"Matching parameterized constructor has priority." },
{ id:"CT22", question:"Which constructor is provided by compiler implicitly?", options:["Copy","Parameterized","Default","Static"], answer:2, explanation:"Default constructor is compiler-provided." },
{ id:"CT23", question:"Can constructor be private?", options:["Yes","No","Only in C++","Only in Java"], answer:0, explanation:"Private constructors are allowed." },
{ id:"CT24", question:"Private constructors are mainly used in:", options:["Inheritance","Singleton pattern","Polymorphism","Overloading"], answer:1, explanation:"Singleton pattern uses private constructors." },
{ id:"CT25", question:"Which constructor prevents object creation from outside class?", options:["Default","Private","Protected","Static"], answer:1, explanation:"Private constructor restricts object creation." },

{ id:"CT26", question:"Which constructor allows inheritance but restricts external access?", options:["Private","Protected","Public","Static"], answer:1, explanation:"Protected constructor allows inheritance." },
{ id:"CT27", question:"Constructor execution order in Java is:", options:["Child to parent","Parent to child","Random","Parallel"], answer:1, explanation:"Parent constructor executes before child." },
{ id:"CT28", question:"Which constructor is NOT inherited?", options:["Default","Parameterized","Copy","All"], answer:3, explanation:"Constructors are not inherited." },
{ id:"CT29", question:"Which language allows constructor with return type?", options:["Java","C++","None","C"], answer:2, explanation:"Constructors cannot have return type." },
{ id:"CT30", question:"Which constructor initializes instance variables?", options:["Static","Default","Parameterized","All"], answer:3, explanation:"All constructors can initialize instance variables." },

{ id:"CT31", question:"Can constructor throw exceptions?", options:["Yes","No","Only runtime","Only checked"], answer:0, explanation:"Constructors can throw exceptions." },
{ id:"CT32", question:"Which constructor is best for mandatory initialization?", options:["Default","Parameterized","Copy","Static"], answer:1, explanation:"Parameterized constructors ensure mandatory initialization." },
{ id:"CT33", question:"Which constructor is called when no arguments passed?", options:["Parameterized","Copy","Default","Static"], answer:2, explanation:"Default constructor is called." },
{ id:"CT34", question:"Which constructor improves object consistency?", options:["Default","Parameterized","Copy","None"], answer:1, explanation:"Parameterized constructors ensure consistency." },
{ id:"CT35", question:"Which constructor cannot access instance variables directly?", options:["Default","Parameterized","Static","Copy"], answer:2, explanation:"Static context cannot access instance variables." },

{ id:"CT36", question:"Which constructor is safest?", options:["Default","Parameterized","Private","Static"], answer:2, explanation:"Private constructors provide controlled creation." },
{ id:"CT37", question:"Which constructor supports immutability?", options:["Default","Parameterized","Copy","Private"], answer:1, explanation:"Parameterized constructors help create immutable objects." },
{ id:"CT38", question:"Which constructor is used in object cloning?", options:["Default","Copy","Parameterized","Static"], answer:1, explanation:"Copy constructor is used in cloning." },
{ id:"CT39", question:"Which constructor cannot be abstract?", options:["Default","Parameterized","All","Copy"], answer:2, explanation:"Constructors cannot be abstract." },
{ id:"CT40", question:"Which constructor is executed automatically?", options:["Method","Constructor","Static block","Destructor"], answer:1, explanation:"Constructor executes automatically." },

{ id:"CT41", question:"Which constructor can call only one constructor at a time?", options:["this()","super()","Both","None"], answer:2, explanation:"Only one constructor call is allowed." },
{ id:"CT42", question:"Constructor call must be:", options:["Anywhere","Last statement","First statement","Optional"], answer:2, explanation:"Constructor call must be first statement." },
{ id:"CT43", question:"Which constructor supports polymorphism?", options:["Default","Parameterized","None","All"], answer:2, explanation:"Constructors do not support polymorphism." },
{ id:"CT44", question:"Which constructor is used for dependency injection?", options:["Default","Parameterized","Copy","Static"], answer:1, explanation:"Parameterized constructors support DI." },
{ id:"CT45", question:"Which constructor is hidden from subclasses?", options:["Private","Protected","Public","Default"], answer:0, explanation:"Private constructors are hidden." },

{ id:"CT46", question:"Which constructor supports inheritance?", options:["Private","Protected","Public","Both B and C"], answer:3, explanation:"Protected and public support inheritance." },
{ id:"CT47", question:"Which constructor is best for testability?", options:["Default","Parameterized","Static","Private"], answer:1, explanation:"Parameterized constructors improve testability." },
{ id:"CT48", question:"Which constructor ensures object is never partially initialized?", options:["Default","Parameterized","Copy","None"], answer:1, explanation:"Parameterized constructor ensures full initialization." },
{ id:"CT49", question:"Which constructor is required for deserialization in Java?", options:["Parameterized","Default","Copy","Private"], answer:1, explanation:"Default constructor is required." },
{ id:"CT50", question:"Which constructor is mandatory in Java class?", options:["Default","Parameterized","Copy","None"], answer:3, explanation:"No constructor is mandatory." },

{ id:"CT51", question:"Which constructor allows method reuse?", options:["Default","Parameterized","Copy","None"], answer:3, explanation:"Constructors do not allow reuse." },
{ id:"CT52", question:"Which constructor initializes base class part?", options:["Derived","Base","Copy","Static"], answer:1, explanation:"Base constructor initializes base part." },
{ id:"CT53", question:"Which constructor improves encapsulation?", options:["Private","Default","Static","Copy"], answer:0, explanation:"Private constructors improve encapsulation." },
{ id:"CT54", question:"Which constructor is not visible to JVM directly?", options:["Default","Parameterized","Private","All"], answer:2, explanation:"Private constructors are not directly accessible." },
{ id:"CT55", question:"Which constructor helps implement factory pattern?", options:["Public","Private","Default","Copy"], answer:1, explanation:"Private constructors support factory pattern." },

{ id:"CT56", question:"Which constructor can be synchronized?", options:["Yes","No","Only static","Only private"], answer:1, explanation:"Constructors cannot be synchronized." },
{ id:"CT57", question:"Which constructor helps enforce constraints?", options:["Default","Parameterized","Copy","Static"], answer:1, explanation:"Parameterized constructors enforce constraints." },
{ id:"CT58", question:"Which constructor supports object pooling?", options:["Private","Default","Static","Copy"], answer:0, explanation:"Private constructors support pooling." },
{ id:"CT59", question:"Which constructor is executed during object cloning in Java?", options:["Default","Copy","None","Parameterized"], answer:2, explanation:"Constructors are not called during cloning." },
{ id:"CT60", question:"Which constructor improves security?", options:["Public","Default","Private","Copy"], answer:2, explanation:"Private constructors improve security." },

{ id:"CT61", question:"Which constructor allows lazy initialization?", options:["Default","Parameterized","Static","Private"], answer:3, explanation:"Private constructors enable lazy init via factory." },
{ id:"CT62", question:"Which constructor cannot be final?", options:["All","Default","Parameterized","Copy"], answer:0, explanation:"Constructors cannot be final." },
{ id:"CT63", question:"Which constructor is used in inheritance chain?", options:["Base","Derived","Copy","All"], answer:3, explanation:"All constructors in chain are called." },
{ id:"CT64", question:"Which constructor is responsible for memory initialization?", options:["Constructor","Destructor","Method","Block"], answer:0, explanation:"Constructor initializes memory." },
{ id:"CT65", question:"Which constructor supports immutability best?", options:["Default","Parameterized","Copy","Static"], answer:1, explanation:"Parameterized constructors support immutability." },

{ id:"CT66", question:"Which constructor cannot be recursive?", options:["All","Default","Parameterized","Copy"], answer:0, explanation:"Constructors cannot be recursive." },
{ id:"CT67", question:"Which constructor is preferred in modern design?", options:["Default","Parameterized","Copy","Static"], answer:1, explanation:"Parameterized constructors are preferred." },
{ id:"CT68", question:"Which constructor executes before instance blocks?", options:["Constructor","Static block","Instance block","None"], answer:2, explanation:"Instance block executes before constructor." },
{ id:"CT69", question:"Which constructor executes after static blocks?", options:["Constructor","Instance block","Method","Main"], answer:1, explanation:"Instance block executes after static block." },
{ id:"CT70", question:"Which constructor is best for dependency enforcement?", options:["Default","Parameterized","Copy","Static"], answer:1, explanation:"Parameterized constructor enforces dependencies." },

{ id:"CT71", question:"Which constructor can restrict subclass instantiation?", options:["Protected","Private","Public","Default"], answer:0, explanation:"Protected restricts external but allows subclass." },
{ id:"CT72", question:"Which constructor supports object consistency across inheritance?", options:["Default","Parameterized","Base","All"], answer:3, explanation:"All constructors participate in consistency." },
{ id:"CT73", question:"Which constructor is invisible outside package?", options:["Private","Protected","Default","Public"], answer:2, explanation:"Default access is package-private." },
{ id:"CT74", question:"Which constructor helps implement singleton?", options:["Private","Default","Static","Copy"], answer:0, explanation:"Singleton uses private constructor." },
{ id:"CT75", question:"Which constructor is best for immutable classes?", options:["Default","Parameterized","Copy","Static"], answer:1, explanation:"Parameterized constructor is best." },

{ id:"CT76", question:"Which constructor is executed once per class load?", options:["Default","Parameterized","Static","Copy"], answer:2, explanation:"Static initialization executes once." },
{ id:"CT77", question:"Which constructor cannot access non-static members?", options:["Static","Default","Parameterized","Copy"], answer:0, explanation:"Static context cannot access instance members." },
{ id:"CT78", question:"Which constructor supports encapsulation?", options:["Private","Default","Public","Static"], answer:0, explanation:"Private constructors support encapsulation." },
{ id:"CT79", question:"Which constructor improves reliability?", options:["Default","Parameterized","Copy","Static"], answer:1, explanation:"Parameterized ensures valid state." },
{ id:"CT80", question:"Which constructor is automatically generated in C++?", options:["Default","Copy","Both","None"], answer:2, explanation:"C++ generates default and copy constructors." },

{ id:"CT81", question:"Which constructor initializes base class members?", options:["Derived","Base","Copy","Static"], answer:1, explanation:"Base constructor initializes base members." },
{ id:"CT82", question:"Which constructor supports constructor overloading?", options:["All","Default","Parameterized","Copy"], answer:0, explanation:"All constructors can be overloaded." },
{ id:"CT83", question:"Which constructor is best for object validity?", options:["Default","Parameterized","Copy","None"], answer:1, explanation:"Parameterized constructor ensures validity." },
{ id:"CT84", question:"Which constructor supports chaining?", options:["Default","Parameterized","Both","None"], answer:2, explanation:"Both support chaining." },
{ id:"CT85", question:"Which constructor cannot be inherited?", options:["All","Default","Parameterized","Copy"], answer:0, explanation:"Constructors are not inherited." },

{ id:"CT86", question:"Which constructor is executed last in inheritance?", options:["Base","Derived","Copy","Static"], answer:1, explanation:"Derived constructor executes last." },
{ id:"CT87", question:"Which constructor ensures mandatory fields initialization?", options:["Default","Parameterized","Copy","Static"], answer:1, explanation:"Parameterized constructor ensures mandatory fields." },
{ id:"CT88", question:"Which constructor is hidden from object creation?", options:["Private","Protected","Public","Default"], answer:0, explanation:"Private constructor hides creation." },
{ id:"CT89", question:"Which constructor helps reduce bugs?", options:["Default","Parameterized","Copy","Static"], answer:1, explanation:"Parameterized constructors reduce bugs." },
{ id:"CT90", question:"Which constructor supports object creation logic?", options:["Constructor","Method","Block","Destructor"], answer:0, explanation:"Constructor defines creation logic." },

{ id:"CT91", question:"Which constructor allows controlled instantiation?", options:["Private","Default","Public","Copy"], answer:0, explanation:"Private constructor allows control." },
{ id:"CT92", question:"Which constructor cannot call itself directly?", options:["All","Default","Parameterized","Copy"], answer:0, explanation:"Constructors cannot call themselves." },
{ id:"CT93", question:"Which constructor improves maintainability?", options:["Default","Parameterized","Copy","Static"], answer:1, explanation:"Parameterized constructor improves maintainability." },
{ id:"CT94", question:"Which constructor allows flexible initialization?", options:["Default","Parameterized","Copy","Static"], answer:1, explanation:"Parameterized constructor allows flexibility." },
{ id:"CT95", question:"Which constructor is preferred in enterprise applications?", options:["Default","Parameterized","Copy","Static"], answer:1, explanation:"Parameterized constructors are preferred." },

{ id:"CT96", question:"Which constructor participates in dependency injection?", options:["Default","Parameterized","Copy","Static"], answer:1, explanation:"Parameterized constructor supports DI." },
{ id:"CT97", question:"Which constructor supports object invariants?", options:["Default","Parameterized","Copy","Static"], answer:1, explanation:"Parameterized constructors enforce invariants." },
{ id:"CT98", question:"Which constructor can restrict subclass creation?", options:["Private","Protected","Public","Default"], answer:1, explanation:"Protected constructor restricts creation." },
{ id:"CT99", question:"Which constructor ensures object is fully initialized?", options:["Default","Parameterized","Copy","None"], answer:1, explanation:"Parameterized constructor ensures full initialization." },
{ id:"CT100", question:"Which statement about constructors is TRUE?", options:["They return values","They are inherited","They initialize objects","They can be virtual in Java"], answer:2, explanation:"Constructors initialize objects." }
],
"Functions":[
{ id:"FN01", question:"A function is a block of code that:", options:["Executes once","Performs a specific task","Stores data","Defines class"], answer:1, explanation:"Functions perform specific tasks." },
{ id:"FN02", question:"Function declaration tells:", options:["Function body","Return type and parameters","Execution order","Memory size"], answer:1, explanation:"Declaration specifies signature." },
{ id:"FN03", question:"Function definition contains:", options:["Only name","Only prototype","Actual implementation","Only return type"], answer:2, explanation:"Definition contains implementation." },
{ id:"FN04", question:"Function call transfers control to:", options:["Main","Caller","Called function","Compiler"], answer:2, explanation:"Control transfers to called function." },
{ id:"FN05", question:"Which is mandatory in a function?", options:["Return value","Return type","Parameters","Body"], answer:3, explanation:"Function body is mandatory." },

{ id:"FN06", question:"Which language does NOT support function overloading?", options:["Java","C++","C","Python"], answer:2, explanation:"C does not support overloading." },
{ id:"FN07", question:"Function prototype is mainly used for:", options:["Execution","Memory allocation","Type checking","Inlining"], answer:2, explanation:"Prototype helps type checking." },
{ id:"FN08", question:"Which function does not return a value?", options:["int","float","void","double"], answer:2, explanation:"void returns no value." },
{ id:"FN09", question:"Return statement does what?", options:["Stops program","Ends loop","Returns control and value","Declares variable"], answer:2, explanation:"Return sends value and control back." },
{ id:"FN10", question:"Which function is executed first in C/C++/Java?", options:["start()","init()","main()","run()"], answer:2, explanation:"main() is entry point." },

{ id:"FN11", question:"Which function can call itself?", options:["Inline","Recursive","Static","Virtual"], answer:1, explanation:"Recursive functions call themselves." },
{ id:"FN12", question:"Recursion must have:", options:["Loop","Base condition","Global variable","Static memory"], answer:1, explanation:"Base condition stops recursion." },
{ id:"FN13", question:"Recursive function uses:", options:["Heap","Registers","Stack","ROM"], answer:2, explanation:"Recursion uses call stack." },
{ id:"FN14", question:"Which is faster generally?", options:["Recursion","Iteration","Both same","Depends"], answer:1, explanation:"Iteration avoids overhead." },
{ id:"FN15", question:"Infinite recursion leads to:", options:["Compilation error","Runtime error","Stack overflow","Deadlock"], answer:2, explanation:"Stack overflow occurs." },

{ id:"FN16", question:"Function parameters are also called:", options:["Arguments","Formal parameters","Actual parameters","Variables"], answer:1, explanation:"Formal parameters are in definition." },
{ id:"FN17", question:"Arguments passed during call are:", options:["Formal","Actual","Static","Local"], answer:1, explanation:"Actual parameters are passed." },
{ id:"FN18", question:"Call by value means:", options:["Address passed","Copy passed","Reference passed","Pointer passed"], answer:1, explanation:"Copy of value is passed." },
{ id:"FN19", question:"Call by reference means:", options:["Copy passed","Value ignored","Address passed","Return passed"], answer:2, explanation:"Address/reference is passed." },
{ id:"FN20", question:"Java supports call by:", options:["Value","Reference","Value only","Reference only"], answer:2, explanation:"Java is strictly call by value." },

{ id:"FN21", question:"Which function cannot be recursive?", options:["Inline","Main","Static","All"], answer:1, explanation:"main() recursion is undefined." },
{ id:"FN22", question:"Which function improves readability?", options:["Large function","Small modular function","Inline","Recursive"], answer:1, explanation:"Modular functions improve readability." },
{ id:"FN23", question:"Function overloading depends on:", options:["Return type","Name only","Parameter list","Access specifier"], answer:2, explanation:"Overloading depends on parameters." },
{ id:"FN24", question:"Two functions with same name and params differ only by return type is:", options:["Allowed","Not allowed","Compiler dependent","Runtime dependent"], answer:1, explanation:"Return type alone is insufficient." },
{ id:"FN25", question:"Which function executes faster in C++?", options:["Normal","Recursive","Inline","Virtual"], answer:2, explanation:"Inline reduces call overhead." },

{ id:"FN26", question:"Inline functions are expanded:", options:["At runtime","At compile time","At link time","Never"], answer:1, explanation:"Inline expansion happens at compile time." },
{ id:"FN27", question:"Which function uses dynamic binding?", options:["Static","Inline","Virtual","Friend"], answer:2, explanation:"Virtual functions use dynamic binding." },
{ id:"FN28", question:"Function declared but not defined causes:", options:["Runtime error","Linker error","Compile error","Warning"], answer:1, explanation:"Linker error occurs." },
{ id:"FN29", question:"Which function allows polymorphism?", options:["Inline","Static","Virtual","Friend"], answer:2, explanation:"Virtual functions support polymorphism." },
{ id:"FN30", question:"Which function belongs to class in Java?", options:["Procedure","Method","Routine","Block"], answer:1, explanation:"Functions in Java are methods." },

{ id:"FN31", question:"Which function cannot access instance variables directly?", options:["Static","Virtual","Inline","Recursive"], answer:0, explanation:"Static functions lack instance context." },
{ id:"FN32", question:"Function scope variable is:", options:["Global","Local","Static","External"], answer:1, explanation:"Local variables have function scope." },
{ id:"FN33", question:"Static local variable in function retains value between:", options:["Calls","Loops","Classes","Objects"], answer:0, explanation:"Static local retains value across calls." },
{ id:"FN34", question:"Which function supports default arguments?", options:["C","Java","C++","Assembly"], answer:2, explanation:"C++ supports default arguments." },
{ id:"FN35", question:"Default arguments are assigned:", options:["At runtime","At compile time","At link time","At execution"], answer:1, explanation:"Resolved at compile time." },

{ id:"FN36", question:"Which function cannot have default arguments?", options:["Inline","Virtual","Overloaded","Friend"], answer:1, explanation:"Virtual functions avoid default args." },
{ id:"FN37", question:"Which function type returns multiple values?", options:["Normal","Recursive","Using pointers/references","Void"], answer:2, explanation:"Pointers/references simulate multiple returns." },
{ id:"FN38", question:"Which function feature improves reuse?", options:["Recursion","Modularity","Inlining","Overloading"], answer:1, explanation:"Modularity improves reuse." },
{ id:"FN39", question:"Which function is stored once in memory?", options:["Inline","Recursive","Normal","Static"], answer:3, explanation:"Static functions exist once." },
{ id:"FN40", question:"Which function can access private members of class?", options:["Normal","Friend","Static","Inline"], answer:1, explanation:"Friend functions access private members." },

{ id:"FN41", question:"Friend function violates which OOP principle?", options:["Inheritance","Polymorphism","Encapsulation","Abstraction"], answer:2, explanation:"Friend breaks encapsulation." },
{ id:"FN42", question:"Which function improves performance by avoiding calls?", options:["Recursive","Inline","Virtual","Static"], answer:1, explanation:"Inline avoids call overhead." },
{ id:"FN43", question:"Which function is bound at runtime?", options:["Static","Inline","Virtual","Friend"], answer:2, explanation:"Virtual functions bind at runtime." },
{ id:"FN44", question:"Which function is resolved at compile time?", options:["Virtual","Inline","Dynamic","Recursive"], answer:1, explanation:"Inline resolved at compile time." },
{ id:"FN45", question:"Which function can be overridden?", options:["Static","Inline","Virtual","Friend"], answer:2, explanation:"Virtual functions can be overridden." },

{ id:"FN46", question:"Which function cannot be overridden?", options:["Virtual","Normal","Static","Inline"], answer:2, explanation:"Static functions cannot be overridden." },
{ id:"FN47", question:"Which function executes faster generally?", options:["Virtual","Normal","Inline","Recursive"], answer:2, explanation:"Inline functions execute faster." },
{ id:"FN48", question:"Which function uses function pointer?", options:["Virtual","Normal","Static","Callback"], answer:3, explanation:"Callbacks use function pointers." },
{ id:"FN49", question:"Function pointer stores:", options:["Value","Object","Address of function","Return type"], answer:2, explanation:"Stores function address." },
{ id:"FN50", question:"Which language supports function pointers?", options:["Java","C","C++","Both B and C"], answer:3, explanation:"C and C++ support function pointers." },

{ id:"FN51", question:"Lambda expression represents:", options:["Class","Object","Anonymous function","Loop"], answer:2, explanation:"Lambda is anonymous function." },
{ id:"FN52", question:"Lambda is supported in Java from:", options:["Java 5","Java 6","Java 7","Java 8"], answer:3, explanation:"Introduced in Java 8." },
{ id:"FN53", question:"Lambda improves:", options:["Memory","Performance","Readability","Compilation"], answer:2, explanation:"Improves readability." },
{ id:"FN54", question:"Which function is anonymous?", options:["Inline","Lambda","Virtual","Static"], answer:1, explanation:"Lambda functions are anonymous." },
{ id:"FN55", question:"Which function supports higher-order behavior?", options:["Normal","Recursive","Lambda","Static"], answer:2, explanation:"Lambda supports higher-order functions." },

{ id:"FN56", question:"Higher-order function means:", options:["Fast","Recursive","Takes/returns functions","Inline"], answer:2, explanation:"Operates on functions." },
{ id:"FN57", question:"Which function improves abstraction?", options:["Inline","Modular","Recursive","Static"], answer:1, explanation:"Modular functions improve abstraction." },
{ id:"FN58", question:"Which function has its own activation record?", options:["All","Recursive","Inline","Static"], answer:1, explanation:"Recursive calls create multiple records." },
{ id:"FN59", question:"Tail recursion optimization reduces:", options:["Time","Memory","Code","Errors"], answer:1, explanation:"Reduces stack usage." },
{ id:"FN60", question:"Which language guarantees tail call optimization?", options:["C","C++","Java","None"], answer:3, explanation:"Not guaranteed in these." },

{ id:"FN61", question:"Which function promotes loose coupling?", options:["Large","Modular","Recursive","Inline"], answer:1, explanation:"Modular design promotes loose coupling." },
{ id:"FN62", question:"Which function reduces code duplication?", options:["Recursive","Reusable","Inline","Static"], answer:1, explanation:"Reusable functions reduce duplication." },
{ id:"FN63", question:"Which function increases stack usage?", options:["Inline","Recursive","Static","Virtual"], answer:1, explanation:"Recursion increases stack usage." },
{ id:"FN64", question:"Which function returns control to caller?", options:["break","continue","return","exit"], answer:2, explanation:"Return passes control back." },
{ id:"FN65", question:"Which function improves testability?", options:["Monolithic","Parameterized","Recursive","Inline"], answer:1, explanation:"Parameterized functions improve testing." },

{ id:"FN66", question:"Which function is executed by JVM thread?", options:["main","run","start","call"], answer:0, explanation:"main is entry point." },
{ id:"FN67", question:"Which function can throw exceptions?", options:["Only main","Only recursive","All","None"], answer:2, explanation:"Any function can throw exceptions." },
{ id:"FN68", question:"Which function supports reusability most?", options:["Large","Recursive","Modular","Inline"], answer:2, explanation:"Modular functions are reusable." },
{ id:"FN69", question:"Which function has local scope variables?", options:["All","Inline","Recursive","Static"], answer:0, explanation:"All functions have local scope variables." },
{ id:"FN70", question:"Which function is best practice in OOP?", options:["Large","Global","Small cohesive","Inline"], answer:2, explanation:"Small cohesive functions are best." },

{ id:"FN71", question:"Which function cannot be overloaded in Java?", options:["main","print","add","compute"], answer:0, explanation:"main overloading is restricted." },
{ id:"FN72", question:"Which function signature is unique?", options:["Name only","Return type","Name + parameters","Access specifier"], answer:2, explanation:"Signature includes name and parameters." },
{ id:"FN73", question:"Which function helps divide problem?", options:["Recursive","Modular","Inline","Static"], answer:1, explanation:"Modular functions divide problem." },
{ id:"FN74", question:"Which function is best for repeated tasks?", options:["Inline","Reusable","Recursive","Static"], answer:1, explanation:"Reusable functions handle repetition." },
{ id:"FN75", question:"Which function supports dynamic dispatch?", options:["Inline","Virtual","Static","Friend"], answer:1, explanation:"Virtual functions support dynamic dispatch." },

{ id:"FN76", question:"Which function is resolved using vtable?", options:["Inline","Static","Virtual","Friend"], answer:2, explanation:"Virtual functions use vtable." },
{ id:"FN77", question:"Which function can improve performance if small?", options:["Recursive","Virtual","Inline","Friend"], answer:2, explanation:"Inline improves small function performance." },
{ id:"FN78", question:"Which function reduces program complexity?", options:["Large","Modular","Recursive","Inline"], answer:1, explanation:"Modular functions reduce complexity." },
{ id:"FN79", question:"Which function is associated with object behavior?", options:["Procedure","Method","Macro","Block"], answer:1, explanation:"Methods define object behavior." },
{ id:"FN80", question:"Which function is not allowed inside another function in C?", options:["Nested","Recursive","Inline","Static"], answer:0, explanation:"C does not support nested functions." },

{ id:"FN81", question:"Which language supports nested functions?", options:["C","C++","Java","Python"], answer:3, explanation:"Python supports nested functions." },
{ id:"FN82", question:"Which function improves maintainability?", options:["Large","Modular","Recursive","Inline"], answer:1, explanation:"Modular functions improve maintainability." },
{ id:"FN83", question:"Which function increases readability?", options:["Complex","Small clear","Recursive","Inline"], answer:1, explanation:"Small clear functions improve readability." },
{ id:"FN84", question:"Which function supports abstraction?", options:["Inline","Modular","Static","Recursive"], answer:1, explanation:"Modular functions support abstraction." },
{ id:"FN85", question:"Which function is best for API design?", options:["Large","Modular","Recursive","Inline"], answer:1, explanation:"Modular functions suit APIs." },

{ id:"FN86", question:"Which function uses heap memory directly?", options:["Recursive","Normal","Dynamic allocation inside","Inline"], answer:2, explanation:"Heap used via dynamic allocation." },
{ id:"FN87", question:"Which function is called automatically on object?", options:["Method","Constructor","Destructor","Inline"], answer:1, explanation:"Constructor is auto-called." },
{ id:"FN88", question:"Which function reduces coupling?", options:["Global","Modular","Recursive","Inline"], answer:1, explanation:"Modular functions reduce coupling." },
{ id:"FN89", question:"Which function is easiest to debug?", options:["Large","Recursive","Small modular","Inline"], answer:2, explanation:"Small modular functions are easier." },
{ id:"FN90", question:"Which function can be unit tested easily?", options:["Monolithic","Parameterized","Recursive","Inline"], answer:1, explanation:"Parameterized functions suit unit tests." },

{ id:"FN91", question:"Which function promotes code reuse?", options:["Recursive","Reusable","Inline","Static"], answer:1, explanation:"Reusable functions promote reuse." },
{ id:"FN92", question:"Which function is best practice for clean code?", options:["Long","Complex","Short focused","Recursive"], answer:2, explanation:"Short focused functions are best." },
{ id:"FN93", question:"Which function can be passed as argument?", options:["Normal","Lambda","Static","Inline"], answer:1, explanation:"Lambda functions can be passed." },
{ id:"FN94", question:"Which function style avoids side effects?", options:["Procedural","Functional","Recursive","Inline"], answer:1, explanation:"Functional style avoids side effects." },
{ id:"FN95", question:"Which function supports immutability?", options:["Procedural","Functional","Recursive","Inline"], answer:1, explanation:"Functional functions support immutability." },

{ id:"FN96", question:"Which function concept comes from mathematics?", options:["Procedural","Functional","Object","Inline"], answer:1, explanation:"Functional programming comes from math." },
{ id:"FN97", question:"Which function returns another function?", options:["Recursive","Higher-order","Inline","Static"], answer:1, explanation:"Higher-order functions return functions." },
{ id:"FN98", question:"Which function cannot change external state?", options:["Procedural","Pure function","Recursive","Inline"], answer:1, explanation:"Pure functions avoid side effects." },
{ id:"FN99", question:"Which function improves predictability?", options:["Recursive","Pure","Inline","Static"], answer:1, explanation:"Pure functions are predictable." },
{ id:"FN100", question:"Which statement about functions is TRUE?", options:["They reduce modularity","They increase duplication","They improve structure","They replace OOP"], answer:2, explanation:"Functions improve program structure." }
],
"Exception Handling":[
{ id:"EX01", question:"Exception handling is used to:", options:["Improve speed","Handle runtime errors","Reduce memory","Avoid compilation"], answer:1, explanation:"Exception handling manages runtime errors." },
{ id:"EX02", question:"An exception is:", options:["Syntax error","Logical error","Runtime abnormal condition","Compile-time error"], answer:2, explanation:"Exceptions occur during runtime." },
{ id:"EX03", question:"Which keyword is used to handle exceptions in Java?", options:["handle","catch","error","fix"], answer:1, explanation:"catch handles exceptions." },
{ id:"EX04", question:"Which block contains risky code?", options:["catch","throw","try","finally"], answer:2, explanation:"try block contains risky code." },
{ id:"EX05", question:"Which block always executes?", options:["try","catch","throw","finally"], answer:3, explanation:"finally always executes." },

{ id:"EX06", question:"Which keyword explicitly throws an exception?", options:["throws","throw","catch","final"], answer:1, explanation:"throw explicitly throws exception." },
{ id:"EX07", question:"Which keyword declares exceptions?", options:["throw","throws","try","catch"], answer:1, explanation:"throws declares exceptions." },
{ id:"EX08", question:"Checked exceptions are checked:", options:["At runtime","At compile time","At load time","Never"], answer:1, explanation:"Checked exceptions are compile-time checked." },
{ id:"EX09", question:"Unchecked exceptions are subclasses of:", options:["Exception","IOException","RuntimeException","Throwable"], answer:2, explanation:"Unchecked exceptions extend RuntimeException." },
{ id:"EX10", question:"Which is NOT a checked exception?", options:["IOException","SQLException","NullPointerException","FileNotFoundException"], answer:2, explanation:"NullPointerException is unchecked." },

{ id:"EX11", question:"Which is the parent class of all exceptions in Java?", options:["Object","Error","Exception","Throwable"], answer:3, explanation:"Throwable is the root." },
{ id:"EX12", question:"Which block executes if exception occurs?", options:["try","catch","finally","throw"], answer:1, explanation:"catch executes on exception." },
{ id:"EX13", question:"Multiple catch blocks are allowed:", options:["Before try","After try","After finally","Inside finally"], answer:1, explanation:"Multiple catch blocks follow try." },
{ id:"EX14", question:"Order of catch blocks should be:", options:["Random","Child before parent","Parent before child","Alphabetical"], answer:1, explanation:"Child exceptions must be caught first." },
{ id:"EX15", question:"If no catch handles exception, program:", options:["Continues","Ignores","Terminates","Retries"], answer:2, explanation:"Unhandled exception terminates program." },

{ id:"EX16", question:"Which block is optional?", options:["try","catch","finally","All"], answer:2, explanation:"finally is optional." },
{ id:"EX17", question:"At least one catch or finally must follow:", options:["throw","throws","try","main"], answer:2, explanation:"try must be followed by catch/finally." },
{ id:"EX18", question:"Exception propagation means:", options:["Handling exception","Passing exception up stack","Ignoring exception","Throwing new exception"], answer:1, explanation:"Exception moves up call stack." },
{ id:"EX19", question:"Stack unwinding occurs in:", options:["Compile time","Link time","Runtime","Load time"], answer:2, explanation:"Stack unwinding happens at runtime." },
{ id:"EX20", question:"Which exception occurs when dividing by zero?", options:["NullPointerException","ArithmeticException","IOException","NumberFormatException"], answer:1, explanation:"Division by zero causes ArithmeticException." },

{ id:"EX21", question:"Which exception occurs when accessing null object?", options:["ArrayIndexOutOfBounds","NullPointerException","IOException","ClassCastException"], answer:1, explanation:"Null object access throws NullPointerException." },
{ id:"EX22", question:"Which exception occurs for invalid array index?", options:["IOException","NullPointerException","ArrayIndexOutOfBoundsException","ClassNotFoundException"], answer:2, explanation:"Invalid index causes ArrayIndexOutOfBoundsException." },
{ id:"EX23", question:"Which exception occurs when class not found?", options:["IOException","ClassNotFoundException","SQLException","RuntimeException"], answer:1, explanation:"ClassNotFoundException is thrown." },
{ id:"EX24", question:"Which exception is thrown by JVM?", options:["User-defined","Checked","Unchecked","All"], answer:3, explanation:"JVM can throw checked and unchecked." },
{ id:"EX25", question:"Which exception is recoverable?", options:["Error","Exception","OutOfMemoryError","StackOverflowError"], answer:1, explanation:"Exceptions are recoverable." },

{ id:"EX26", question:"Errors are:", options:["Recoverable","Unchecked","Recoverable and checked","Non-recoverable"], answer:3, explanation:"Errors are non-recoverable." },
{ id:"EX27", question:"Which is NOT an Error?", options:["IOError","StackOverflowError","OutOfMemoryError","IOException"], answer:3, explanation:"IOException is an Exception." },
{ id:"EX28", question:"Custom exception is created by extending:", options:["Object","Throwable","Exception","Runtime"], answer:2, explanation:"Custom exceptions extend Exception." },
{ id:"EX29", question:"User-defined exceptions are:", options:["Runtime","Compile-time","Checked or unchecked","Errors"], answer:2, explanation:"Can be checked or unchecked." },
{ id:"EX30", question:"Which keyword prevents exception propagation?", options:["throw","throws","catch","finally"], answer:2, explanation:"catch prevents propagation." },

{ id:"EX31", question:"Which block is used for cleanup code?", options:["try","catch","finally","throw"], answer:2, explanation:"finally is for cleanup." },
{ id:"EX32", question:"finally block executes even when:", options:["Exception occurs","Return statement","System.exit()","All except System.exit"], answer:3, explanation:"finally doesnt execute after System.exit()." },
{ id:"EX33", question:"Which exception is thrown when parsing invalid number?", options:["IOException","NumberFormatException","ArithmeticException","ClassCastException"], answer:1, explanation:"Invalid parsing throws NumberFormatException." },
{ id:"EX34", question:"Which exception occurs during type casting?", options:["ClassCastException","IOException","NullPointerException","ArithmeticException"], answer:0, explanation:"Invalid cast causes ClassCastException." },
{ id:"EX35", question:"Which exception occurs during file operations?", options:["ArithmeticException","IOException","RuntimeException","Error"], answer:1, explanation:"File I/O causes IOException." },

{ id:"EX36", question:"C language supports exception handling?", options:["Yes","No","Partially","Using try-catch"], answer:1, explanation:"C has no built-in exception handling." },
{ id:"EX37", question:"C++ exception handling uses:", options:["try-catch","throw","catch","All"], answer:3, explanation:"C++ uses try, catch, throw." },
{ id:"EX38", question:"Which block throws exception in C++?", options:["raise","throw","error","signal"], answer:1, explanation:"throw is used." },
{ id:"EX39", question:"Which keyword catches exception in C++?", options:["catch","handle","fix","error"], answer:0, explanation:"catch handles exceptions." },
{ id:"EX40", question:"Which is default catch in C++?", options:["catch(...)","catch(Exception)","catch(Error)","catch(Object)"], answer:0, explanation:"catch(...) catches all." },

{ id:"EX41", question:"Which Java statement allows multiple resources?", options:["try","catch","try-with-resources","finally"], answer:2, explanation:"try-with-resources handles resources." },
{ id:"EX42", question:"try-with-resources introduced in:", options:["Java 5","Java 6","Java 7","Java 8"], answer:2, explanation:"Introduced in Java 7." },
{ id:"EX43", question:"Which resource is auto-closed?", options:["Heap","File","Thread","Method"], answer:1, explanation:"File streams auto-close." },
{ id:"EX44", question:"Which exception occurs when file not found?", options:["IOException","FileNotFoundException","RuntimeException","Error"], answer:1, explanation:"FileNotFoundException occurs." },
{ id:"EX45", question:"Which block should not contain business logic?", options:["try","catch","finally","All"], answer:2, explanation:"finally should only contain cleanup." },

{ id:"EX46", question:"Which exception is thrown manually?", options:["System","User-defined","JVM","Error"], answer:1, explanation:"User-defined exceptions are manual." },
{ id:"EX47", question:"Which statement rethrows exception?", options:["throw","throws","catch","finally"], answer:0, explanation:"throw rethrows exception." },
{ id:"EX48", question:"Which block handles multiple exception types in Java 7+?", options:["multi-catch","nested","final","static"], answer:0, explanation:"Multi-catch handles multiple exceptions." },
{ id:"EX49", question:"Multi-catch uses which operator?", options:["&","|","||","&&"], answer:1, explanation:"| separates exception types." },
{ id:"EX50", question:"Which exception cannot be caught?", options:["Error","IOException","RuntimeException","Custom"], answer:0, explanation:"Errors generally not caught." },

{ id:"EX51", question:"Which exception occurs when thread interrupted?", options:["InterruptedException","IOException","RuntimeException","Error"], answer:0, explanation:"InterruptedException occurs." },
{ id:"EX52", question:"Which exception is checked?", options:["NullPointerException","ArithmeticException","IOException","ArrayIndexOutOfBounds"], answer:2, explanation:"IOException is checked." },
{ id:"EX53", question:"Which exception is unchecked?", options:["IOException","SQLException","RuntimeException","FileNotFoundException"], answer:2, explanation:"RuntimeException is unchecked." },
{ id:"EX54", question:"Which exception occurs during database access?", options:["IOException","SQLException","ClassCastException","Error"], answer:1, explanation:"SQLException occurs." },
{ id:"EX55", question:"Which block can be nested?", options:["try","catch","finally","All"], answer:3, explanation:"All can be nested." },

{ id:"EX56", question:"Nested try means:", options:["Multiple try","try inside try","try after catch","try without catch"], answer:1, explanation:"try inside another try." },
{ id:"EX57", question:"Which exception occurs when memory exhausted?", options:["StackOverflowError","OutOfMemoryError","IOException","RuntimeException"], answer:1, explanation:"OutOfMemoryError occurs." },
{ id:"EX58", question:"Which exception occurs due to deep recursion?", options:["OutOfMemoryError","StackOverflowError","RuntimeException","Error"], answer:1, explanation:"Deep recursion causes StackOverflowError." },
{ id:"EX59", question:"Which exception indicates serious system problem?", options:["Exception","Error","RuntimeException","IOException"], answer:1, explanation:"Errors indicate serious problems." },
{ id:"EX60", question:"Which exception hierarchy root is Throwable?", options:["True","False","Only in Java","Only in C++"], answer:0, explanation:"Throwable is root." },

{ id:"EX61", question:"Which method prints exception details?", options:["print()","println()","printStackTrace()","toString()"], answer:2, explanation:"printStackTrace prints details." },
{ id:"EX62", question:"Which method returns exception message?", options:["getMessage()","print()","show()","display()"], answer:0, explanation:"getMessage returns message." },
{ id:"EX63", question:"Which exception occurs when casting object incorrectly?", options:["ClassCastException","NullPointerException","ArithmeticException","IOException"], answer:0, explanation:"Invalid cast causes ClassCastException." },
{ id:"EX64", question:"Which exception is thrown when accessing closed resource?", options:["IOException","RuntimeException","Error","IllegalStateException"], answer:3, explanation:"IllegalStateException occurs." },
{ id:"EX65", question:"Which exception is best handled explicitly?", options:["Error","Unchecked","Checked","Fatal"], answer:2, explanation:"Checked exceptions should be handled." },

{ id:"EX66", question:"Which practice improves exception handling?", options:["Ignoring","Catching all","Specific catch","Empty catch"], answer:2, explanation:"Specific catch is best." },
{ id:"EX67", question:"Empty catch block is:", options:["Best practice","Allowed","Bad practice","Mandatory"], answer:2, explanation:"Empty catch is bad practice." },
{ id:"EX68", question:"Which exception is thrown when accessing invalid enum?", options:["IllegalArgumentException","RuntimeException","IOException","Error"], answer:0, explanation:"IllegalArgumentException occurs." },
{ id:"EX69", question:"Which exception indicates programming bug?", options:["Checked","Unchecked","IOException","SQLException"], answer:1, explanation:"Unchecked indicates bug." },
{ id:"EX70", question:"Which exception handling feature improves reliability?", options:["try-catch","throw","finally","All"], answer:3, explanation:"All improve reliability." },

{ id:"EX71", question:"Which language enforces checked exceptions?", options:["C","C++","Java","Python"], answer:2, explanation:"Java enforces checked exceptions." },
{ id:"EX72", question:"Which exception occurs during wrong format conversion?", options:["NumberFormatException","ClassCastException","IOException","Error"], answer:0, explanation:"Wrong format causes NumberFormatException." },
{ id:"EX73", question:"Which exception indicates null reference?", options:["NullPointerException","RuntimeException","IOException","Error"], answer:0, explanation:"Null reference causes NullPointerException." },
{ id:"EX74", question:"Which exception is most common?", options:["IOException","NullPointerException","SQLException","Error"], answer:1, explanation:"NullPointerException is common." },
{ id:"EX75", question:"Which block should release database connections?", options:["try","catch","finally","throw"], answer:2, explanation:"finally releases resources." },

{ id:"EX76", question:"Which exception handling mechanism avoids abrupt termination?", options:["Loop","Condition","try-catch","Goto"], answer:2, explanation:"try-catch avoids abrupt termination." },
{ id:"EX77", question:"Which exception is thrown for invalid method arguments?", options:["IllegalArgumentException","IOException","Error","NullPointerException"], answer:0, explanation:"IllegalArgumentException is thrown." },
{ id:"EX78", question:"Which exception indicates illegal state of object?", options:["IllegalStateException","RuntimeException","IOException","Error"], answer:0, explanation:"IllegalStateException indicates illegal state." },
{ id:"EX79", question:"Which exception occurs when dividing integer by zero?", options:["ArithmeticException","IOException","Error","RuntimeException"], answer:0, explanation:"ArithmeticException occurs." },
{ id:"EX80", question:"Which exception handling improves debugging?", options:["Ignoring","Logging","Empty catch","Suppressing"], answer:1, explanation:"Logging improves debugging." },

{ id:"EX81", question:"Which exception should be logged?", options:["All","None","Only checked","Only unchecked"], answer:0, explanation:"All exceptions should be logged." },
{ id:"EX82", question:"Which exception handling principle is correct?", options:["Catch generic","Catch specific","Ignore errors","Suppress"], answer:1, explanation:"Specific catching is correct." },
{ id:"EX83", question:"Which exception should not be swallowed?", options:["Checked","Unchecked","All","None"], answer:2, explanation:"Exceptions should not be swallowed." },
{ id:"EX84", question:"Which exception handling feature improves robustness?", options:["Throwing","Handling","Ignoring","Suppressing"], answer:1, explanation:"Handling improves robustness." },
{ id:"EX85", question:"Which exception indicates JVM failure?", options:["Exception","Error","RuntimeException","IOException"], answer:1, explanation:"Error indicates JVM failure." },

{ id:"EX86", question:"Which exception handling is compile-time enforced?", options:["Checked","Unchecked","Runtime","Error"], answer:0, explanation:"Checked exceptions are enforced." },
{ id:"EX87", question:"Which exception handling style is recommended?", options:["Centralized","Scattered","Ignored","Suppressed"], answer:0, explanation:"Centralized handling is recommended." },
{ id:"EX88", question:"Which exception handling block can throw another exception?", options:["try","catch","finally","All"], answer:3, explanation:"All blocks can throw." },
{ id:"EX89", question:"Which exception indicates invalid array size?", options:["NegativeArraySizeException","ArrayIndexOutOfBounds","NullPointerException","Error"], answer:0, explanation:"Negative size causes exception." },
{ id:"EX90", question:"Which exception occurs when class cast fails?", options:["ClassCastException","RuntimeException","IOException","Error"], answer:0, explanation:"ClassCastException occurs." },

{ id:"EX91", question:"Which exception handling concept ensures graceful failure?", options:["Termination","Crash","Recovery","Ignore"], answer:2, explanation:"Recovery ensures graceful failure." },
{ id:"EX92", question:"Which exception is best rethrown?", options:["All","None","Contextual","Fatal"], answer:2, explanation:"Contextual exceptions are rethrown." },
{ id:"EX93", question:"Which exception handling avoids resource leaks?", options:["throw","catch","finally","ignore"], answer:2, explanation:"finally avoids leaks." },
{ id:"EX94", question:"Which exception indicates invalid thread operation?", options:["IllegalThreadStateException","RuntimeException","IOException","Error"], answer:0, explanation:"IllegalThreadStateException occurs." },
{ id:"EX95", question:"Which exception handling practice improves maintainability?", options:["Empty catch","Specific catch","Ignore","Suppress"], answer:1, explanation:"Specific catch improves maintainability." },

{ id:"EX96", question:"Which exception is thrown when accessing closed stream?", options:["IOException","IllegalStateException","RuntimeException","Error"], answer:1, explanation:"IllegalStateException occurs." },
{ id:"EX97", question:"Which exception handling mechanism is safer?", options:["Unchecked","Checked","Error","Ignore"], answer:1, explanation:"Checked handling is safer." },
{ id:"EX98", question:"Which exception occurs during wrong object serialization?", options:["IOException","ClassNotFoundException","RuntimeException","Error"], answer:0, explanation:"Serialization throws IOException." },
{ id:"EX99", question:"Which exception handling feature helps fault tolerance?", options:["Retry","Ignore","Log","Handle"], answer:3, explanation:"Handling ensures fault tolerance." },
{ id:"EX100", question:"Which statement about exception handling is TRUE?", options:["It slows program always","It avoids runtime errors","It improves robustness","It replaces testing"], answer:2, explanation:"Exception handling improves robustness." }
],

"General Programming Concepts":[
{ id:"TG01", question:"int i=5; printf(\"%d\", i++);", options:["4","5","6","Compilation error"], answer:1, explanation:"Post-increment prints old value, then increments." },
{ id:"TG02", question:"int i=5; printf(\"%d\", ++i);", options:["4","5","6","Undefined"], answer:2, explanation:"Pre-increment increments first, then prints." },
{ id:"TG03", question:"int i=5; i = i++; printf(\"%d\", i);", options:["5","6","Undefined","Compilation error"], answer:0, explanation:"Old value assigned back; increment lost." },
{ id:"TG04", question:"int i=5; i = ++i; printf(\"%d\", i);", options:["5","6","Undefined","Error"], answer:1, explanation:"Increment then assignment." },
{ id:"TG05", question:"int i=1; i = i++ + ++i; printf(\"%d\", i);", options:["3","4","Undefined","5"], answer:2, explanation:"Multiple modification without sequence point  undefined (C/C++)." },


{ id:"TG06", question:"int i=1; int x = i++ + ++i; System.out.print(x);", options:["3","4","5","Error"], answer:1, explanation:"Java evaluates left to right  1 + 3 = 4." },
{ id:"TG07", question:"int i=0; System.out.print(i++ + i++);", options:["0","1","2","Undefined"], answer:1, explanation:"0 + 1 = 1 in Java." },
{ id:"TG08", question:"int i=1; System.out.print(++i + ++i);", options:["4","5","6","Error"], answer:1, explanation:"i=2 then i=3  2+3=5." },


{ id:"TG09", question:"int a,b,c; a=b=c=5; printf(\"%d\", a+b+c);", options:["5","10","15","Error"], answer:2, explanation:"Assignment associates right to left." },
{ id:"TG10", question:"int a=5; a+=a-=a*=2; printf(\"%d\", a);", options:["0","5","-5","Undefined"], answer:3, explanation:"Multiple side effects  undefined in C/C++." },


{ id:"TG11", question:"int a=0; if(a && ++a){} printf(\"%d\", a);", options:["0","1","Undefined","Error"], answer:0, explanation:"Short-circuit stops evaluation." },
{ id:"TG12", question:"int a=0; if(a || ++a){} printf(\"%d\", a);", options:["0","1","Undefined","Error"], answer:1, explanation:"Second operand evaluated." },


{ id:"TG13", question:"for(int i=0;i<5;i++); printf(\"Hello\");", options:["Prints 5 times","Prints once","Infinite loop","Error"], answer:1, explanation:"Semicolon ends loop; printf runs once." },
{ id:"TG14", question:"int i=0; while(i<3) printf(\"%d\", i++);", options:["012","123","0123","Infinite"], answer:0, explanation:"Post-increment prints then increments." },


{ id:"TG15", question:"int a=5,b=10; int c = a>b?a:b; printf(\"%d\", c);", options:["5","10","Undefined","Error"], answer:1, explanation:"Ternary selects larger value." },
{ id:"TG16", question:"int x=5; int y = x++ > 5 ? x : ++x; printf(\"%d\", y);", options:["5","6","7","Undefined"], answer:1, explanation:"5>5 false  ++x  6." },


{ id:"TG17", question:"int a=2,b=3; printf(\"%d\", a&b);", options:["0","1","2","3"], answer:0, explanation:"2(10) & 3(11) = 10 = 2? No  10 & 11 = 10 = 2? Actually bitwise AND = 2." },
{ id:"TG18", question:"int a=2,b=3; printf(\"%d\", a&&b);", options:["0","1","2","3"], answer:1, explanation:"Logical AND returns 1 (true)." },


{ id:"TG19", question:"printf(\"%d\", 5+3*2);", options:["16","11","13","10"], answer:1, explanation:"Multiplication has higher precedence." },
{ id:"TG20", question:"printf(\"%d\", (5+3)*2);", options:["16","11","13","10"], answer:0, explanation:"Parentheses override precedence." },


{ id:"TG21", question:"int f(int x){ return x++; } printf(\"%d\", f(5));", options:["5","6","Undefined","Error"], answer:0, explanation:"Return old value; increment discarded." },
{ id:"TG22", question:"int f(int x){ return ++x; } printf(\"%d\", f(5));", options:["5","6","Undefined","Error"], answer:1, explanation:"Pre-increment returns 6." },


{ id:"TG23", question:"int a[]={1,2,3}; printf(\"%d\", ++*a);", options:["1","2","3","Error"], answer:1, explanation:"*a = 1  increment  2." },
{ id:"TG24", question:"int a[]={1,2,3}; printf(\"%d\", *a++);", options:["1","2","3","Error"], answer:0, explanation:"Dereference then increment pointer." },


{ id:"TG25", question:"int i=1; printf(\"%d %d\", i, i++);", options:["1 1","1 2","Undefined","Error"], answer:2, explanation:"Multiple modification without sequence point." },


{ id:"TG26", question:"Which language guarantees left-to-right evaluation?", options:["C","C++","Java","Assembly"], answer:2, explanation:"Java guarantees evaluation order." },
{ id:"TG27", question:"Which allows undefined behavior?", options:["Java","Python","C/C++","All"], answer:2, explanation:"C/C++ allow undefined behavior." },


{ id:"TG28", question:"int i=10; i = i-- - --i; printf(\"%d\", i);", options:["0","1","Undefined","Error"], answer:2, explanation:"Multiple side effects  undefined." },
{ id:"TG29", question:"int i=3; printf(\"%d\", i+++i);", options:["6","7","Error","Undefined"], answer:2, explanation:"Parsed as (i++) + i  syntax error in C." },
{ id:"TG30", question:"int i=3; printf(\"%d\", ++i + i++);", options:["7","8","Undefined","Error"], answer:2, explanation:"Multiple modification  undefined." },


{ id:"TG31", question:"printf(\"%d\", !5);", options:["0","1","5","Error"], answer:0, explanation:"Non-zero becomes false  !false = 0." },
{ id:"TG32", question:"printf(\"%d\", !!5);", options:["0","1","5","Error"], answer:1, explanation:"Double negation gives true." },


{ id:"TG33", question:"Which operator has highest precedence?", options:["++","*","=","&&"], answer:0, explanation:"Increment has very high precedence." },
{ id:"TG34", question:"Associativity of assignment operator?", options:["Left to right","Right to left","None","Compiler dependent"], answer:1, explanation:"Assignment associates right to left." },


{ id:"TG35", question:"int x=0; if(x=1) printf(\"Yes\");", options:["Yes","No","Error","Undefined"], answer:0, explanation:"Assignment returns 1  true." },


{ id:"TG36", question:"printf(\"%d\", sizeof('A'));", options:["1","2","4","Depends"], answer:2, explanation:"Character constant is int in C." },
{ id:"TG37", question:"int x=5; printf(\"%d\", x+++x);", options:["10","11","Compilation error","Undefined"], answer:2, explanation:"Tokenization fails; parsed as x++ + x but invalid syntax." },

{ id:"TG38", question:"int i=0; printf(\"%d %d\", i++, ++i);", options:["0 2","0 1","1 2","Undefined"], answer:3, explanation:"Multiple modifications without sequence point  undefined (C/C++)." },

{ id:"TG39", question:"int i=1; while(i<=5) printf(\"%d\", i++);", options:["12345","01234","123456","Infinite"], answer:0, explanation:"Post-increment prints then increments." },

{ id:"TG40", question:"for(int i=0;i<5;++i) printf(\"%d\", i);", options:["01234","12345","012345","Error"], answer:0, explanation:"Standard for-loop behavior." },

{ id:"TG41", question:"int a=3; printf(\"%d\", a-- - --a);", options:["1","0","Undefined","-1"], answer:2, explanation:"Multiple side effects without sequence point." },

{ id:"TG42", question:"int x=2; printf(\"%d\", x<<1);", options:["2","3","4","1"], answer:2, explanation:"Left shift multiplies by 2." },

{ id:"TG43", question:"int x=8; printf(\"%d\", x>>1);", options:["2","3","4","1"], answer:2, explanation:"Right shift divides by 2." },

{ id:"TG44", question:"int x=5; printf(\"%d\", x&1);", options:["0","1","5","Error"], answer:1, explanation:"Checks if number is odd." },

{ id:"TG45", question:"printf(\"%d\", 10==10==1);", options:["0","1","Compilation error","Undefined"], answer:1, explanation:"10==10  1, then 1==1  true." },

{ id:"TG46", question:"printf(\"%d\", 5>3>1);", options:["0","1","Compilation error","Undefined"], answer:0, explanation:"5>3  1, then 1>1  false." },

{ id:"TG47", question:"int x=0; x = x++ + ++x; printf(\"%d\", x);", options:["1","2","Undefined","3"], answer:2, explanation:"Undefined due to multiple side effects." },

{ id:"TG48", question:"int x=1; printf(\"%d\", x+++1);", options:["2","Compilation error","Undefined","1"], answer:1, explanation:"Invalid token sequence." },

{ id:"TG49", question:"int i=1; do{printf(\"%d\",i);}while(i++<1);", options:["1","11","Infinite","0"], answer:1, explanation:"Loop executes once, condition checked after." },

{ id:"TG50", question:"printf(\"%d\", sizeof(5.5));", options:["4","8","2","Depends"], answer:1, explanation:"Double typically occupies 8 bytes." },

{ id:"TG51", question:"int x=5; int y = ++x * x++; printf(\"%d\", y);", options:["30","36","Undefined","25"], answer:2, explanation:"Multiple modifications  undefined." },

{ id:"TG52", question:"int i=0; if(i++ && ++i){} printf(\"%d\", i);", options:["1","2","0","Undefined"], answer:1, explanation:"First operand false, but i++ executed  i=1; ++i not executed? Actually i++ returns 0 but increments  i=1." },

{ id:"TG53", question:"int i=0; if(++i || ++i){} printf(\"%d\", i);", options:["1","2","0","Undefined"], answer:0, explanation:"First ++i makes i=1; OR short-circuits." },

{ id:"TG54", question:"printf(\"%d\", 5 & 3 | 1);", options:["1","3","5","7"], answer:1, explanation:"& evaluated before |  (5&3)=1, then 1|1=1? Actually 1|1=1." },

{ id:"TG55", question:"int x=1; printf(\"%d\", x = x++);", options:["1","2","Undefined","0"], answer:0, explanation:"Old value assigned back." },

{ id:"TG56", question:"int x=5; printf(\"%d\", x = ++x);", options:["5","6","Undefined","Error"], answer:1, explanation:"Pre-increment then assignment." },

{ id:"TG57", question:"int x=10; printf(\"%d\", x+=x-=x*=2);", options:["0","-10","Undefined","10"], answer:2, explanation:"Undefined in C/C++ due to multiple side effects." },

{ id:"TG58", question:"int i=3; printf(\"%d\", i-- - i--);", options:["0","1","Undefined","-1"], answer:2, explanation:"Undefined behavior." },

{ id:"TG59", question:"printf(\"%d\", 1 || 0 && 0);", options:["0","1","Error","Undefined"], answer:1, explanation:"&& has higher precedence." },

{ id:"TG60", question:"printf(\"%d\", (1 || 0) && 0);", options:["0","1","Error","Undefined"], answer:0, explanation:"Parentheses change order." },

{ id:"TG61", question:"int x=0; printf(\"%d\", x && ++x);", options:["0","1","Undefined","Error"], answer:0, explanation:"Short-circuit AND." },

{ id:"TG62", question:"int x=0; printf(\"%d\", x || ++x);", options:["0","1","Undefined","Error"], answer:1, explanation:"Second operand evaluated." },

{ id:"TG63", question:"int a=5; printf(\"%d\", a+++ ++a);", options:["11","Compilation error","Undefined","10"], answer:1, explanation:"Invalid expression." },

{ id:"TG64", question:"printf(\"%d\", sizeof('a'));", options:["1","2","4","Depends"], answer:2, explanation:"Character literal is int in C." },

{ id:"TG65", question:"printf(\"%d\", sizeof(\"a\"));", options:["1","2","4","Depends"], answer:1, explanation:"String literal includes null terminator." },

{ id:"TG66", question:"int i=5; printf(\"%d\", i++ + i++);", options:["11","12","Undefined","10"], answer:2, explanation:"Undefined in C/C++." },

{ id:"TG67", question:"int x=3; printf(\"%d\", x>2 ? x++ : ++x);", options:["3","4","5","Undefined"], answer:0, explanation:"Condition true, returns x++  3." },

{ id:"TG68", question:"int x=0; while(x++<3) printf(\"%d\",x);", options:["123","012","234","Infinite"], answer:0, explanation:"Increment happens after comparison." },

{ id:"TG69", question:"for(;;) break; printf(\"Done\");", options:["Done","Infinite","Error","Nothing"], answer:0, explanation:"Infinite loop broken immediately." },

{ id:"TG70", question:"int x=1; printf(\"%d\", x<<x);", options:["1","2","4","Error"], answer:1, explanation:"1 << 1 = 2." },
{ id:"TG71", question:"int x=5; printf(\"%d\", x = x + (x=10));", options:["10","15","Undefined","Compilation error"], answer:1, explanation:"Right side x=10 first, then 5+10 = 15." },

{ id:"TG72", question:"int i=1; printf(\"%d\", i += i++);", options:["2","3","Undefined","1"], answer:2, explanation:"Multiple modification without sequence point  undefined." },

{ id:"TG73", question:"printf(\"%d\", 3 + 4 * 5 == 23);", options:["0","1","Compilation error","Undefined"], answer:1, explanation:"4*5=20, 3+20=23  true." },

{ id:"TG74", question:"int i=0; for(;i<3;i++); printf(\"%d\", i);", options:["0","2","3","Infinite"], answer:2, explanation:"Loop ends with i=3; semicolon ends loop body." },

{ id:"TG75", question:"int x=5; printf(\"%d\", x>3 && x<10);", options:["0","1","5","Undefined"], answer:1, explanation:"Logical AND evaluates to true." },

{ id:"TG76", question:"int x=5; printf(\"%d\", x>3 & x<10);", options:["0","1","Undefined","Error"], answer:1, explanation:"Bitwise AND on boolean results (1 & 1)." },

{ id:"TG77", question:"int i=0; printf(\"%d\", i==0 ? i++ : ++i);", options:["0","1","2","Undefined"], answer:0, explanation:"Condition true; returns i++  0." },

{ id:"TG78", question:"int i=1; switch(i){case 1: printf(\"A\"); case 2: printf(\"B\");}", options:["A","AB","B","Error"], answer:1, explanation:"Fall-through without break." },

{ id:"TG79", question:"int i=0; while(i<3){printf(\"%d\",i); i+=2;}", options:["01","02","013","Infinite"], answer:0, explanation:"i jumps by 2." },

{ id:"TG80", question:"printf(\"%d\", sizeof(int*) == sizeof(char*));", options:["0","1","Depends","Error"], answer:1, explanation:"All pointers same size on a platform." },

{ id:"TG81", question:"int x=5; int *p=&x; printf(\"%d\", ++*p);", options:["5","6","Undefined","Error"], answer:1, explanation:"Pointer dereferenced then incremented." },

{ id:"TG82", question:"int a=10; printf(\"%d\", a>>2);", options:["2","5","8","Undefined"], answer:0, explanation:"10>>2 = 2." },

{ id:"TG83", question:"int x=3; printf(\"%d\", x^1);", options:["2","3","4","1"], answer:0, explanation:"Bitwise XOR toggles last bit." },

{ id:"TG84", question:"printf(\"%d\", 5 | 2 & 1);", options:["5","7","3","1"], answer:0, explanation:"& before |  2&1=0  5|0=5." },

{ id:"TG85", question:"int x=0; if(x=5) printf(\"Yes\");", options:["Yes","No","Error","Undefined"], answer:0, explanation:"Assignment returns 5 (true)." },

{ id:"TG86", question:"int x=1; printf(\"%d\", ++x + x++);", options:["4","5","Undefined","3"], answer:2, explanation:"Multiple modifications  undefined." },

{ id:"TG87", question:"printf(\"%d\", !0);", options:["0","1","Undefined","Error"], answer:1, explanation:"Logical NOT of false is true." },

{ id:"TG88", question:"int i=5; printf(\"%d\", i-- > 3 && ++i);", options:["0","1","Undefined","Error"], answer:1, explanation:"First true; ++i executed." },

{ id:"TG89", question:"int i=5; printf(\"%d\", i-- > 6 && ++i);", options:["0","1","Undefined","Error"], answer:0, explanation:"First false; short-circuit AND." },

{ id:"TG90", question:"int x=1; printf(\"%d\", x<<2 + 1);", options:["8","4","Undefined","16"], answer:0, explanation:"+ before <<  x<<(3) = 8." },

{ id:"TG91", question:"int x=10; printf(\"%d\", x/3);", options:["3","3.33","4","Undefined"], answer:0, explanation:"Integer division truncates." },

{ id:"TG92", question:"int x=10; printf(\"%f\", x/3.0);", options:["3.0","3.33","3","Error"], answer:1, explanation:"Floating-point division." },

{ id:"TG93", question:"printf(\"%d\", 1 & 2 && 3);", options:["0","1","2","3"], answer:0, explanation:"& evaluated before &&  1&2=0." },

{ id:"TG94", question:"int x=5; printf(\"%d\", x = x * -1);", options:["-5","5","Undefined","Error"], answer:0, explanation:"Unary minus applied." },

{ id:"TG95", question:"int x=5; printf(\"%d\", -x * -x);", options:["25","-25","Undefined","Error"], answer:0, explanation:"Negative times negative." },

{ id:"TG96", question:"int i=0; do{printf(\"%d\",i);}while(i++<0);", options:["0","01","Infinite","Nothing"], answer:0, explanation:"Do-while executes once." },

{ id:"TG97", question:"printf(\"%d\", sizeof(5/2));", options:["2","4","Depends","Undefined"], answer:1, explanation:"Integer expression  int." },

{ id:"TG98", question:"int x=1; printf(\"%d\", x+++ ++x);", options:["3","Compilation error","Undefined","4"], answer:1, explanation:"Invalid tokenization." },

{ id:"TG99", question:"int x=5; printf(\"%d\", x>2 ? x<10 ? 1:0 : 0);", options:["0","1","Error","Undefined"], answer:1, explanation:"Nested ternary evaluation." },

{ id:"TG100", question:"int x=0; printf(\"%d\", x = !x);", options:["0","1","Undefined","Error"], answer:1, explanation:"Logical NOT toggles value." },

{ id:"TG101", question:"int i=1; for(;i<=3;printf(\"%d\",i++));", options:["123","012","Infinite","Error"], answer:0, explanation:"Printf in iteration expression." },

{ id:"TG102", question:"int x=2; printf(\"%d\", x<<x<<1);", options:["8","16","Undefined","4"], answer:1, explanation:"Left associative: (2<<2)<<1 = 16." },

{ id:"TG103", question:"int x=5; printf(\"%d\", x &= 3);", options:["1","3","5","Undefined"], answer:0, explanation:"x = x & 3  1." },

{ id:"TG104", question:"int x=5; printf(\"%d\", x |= 2);", options:["5","6","7","Undefined"], answer:0, explanation:"5|2 = 7? Actually 101|010=111 = 7." },

{ id:"TG105", question:"int x=5; printf(\"%d\", x ^= 1);", options:["4","5","6","Undefined"], answer:0, explanation:"XOR toggles bit." },

{ id:"TG106", question:"int x=1; printf(\"%d\", x==1 && x++);", options:["0","1","Undefined","2"], answer:1, explanation:"x++ returns 1 then increments." },

{ id:"TG107", question:"int x=0; printf(\"%d\", x++ || ++x);", options:["0","1","2","Undefined"], answer:1, explanation:"First false; second evaluated." },

{ id:"TG108", question:"int x=3; printf(\"%d\", x-- > x);", options:["0","1","Undefined","Error"], answer:1, explanation:"3>2  true." },

{ id:"TG109", question:"printf(\"%d\", sizeof(1.0f));", options:["4","8","Depends","Undefined"], answer:0, explanation:"Float size is 4 bytes." },

{ id:"TG110", question:"int x=5; printf(\"%d\", x%2);", options:["0","1","2","Undefined"], answer:1, explanation:"Modulo gives remainder." },

{ id:"TG111", question:"int i=0; for(i=0;i<3;i++); printf(\"%d\", i);", options:["0","2","3","Infinite"], answer:2, explanation:"Loop ends with i=3." },

{ id:"TG112", question:"printf(\"%d\", 0 || 0 && 1);", options:["0","1","Undefined","Error"], answer:0, explanation:"&& before ||." },

{ id:"TG113", question:"int x=5; printf(\"%d\", ++x > 6 ? x : x+1);", options:["6","7","Undefined","5"], answer:1, explanation:"++x=6; condition false  x+1 = 7." },

{ id:"TG114", question:"int x=1; printf(\"%d\", x += ++x);", options:["2","3","Undefined","1"], answer:2, explanation:"Multiple modification  undefined." },

{ id:"TG115", question:"printf(\"%d\", sizeof(char));", options:["1","2","4","Depends"], answer:0, explanation:"char is 1 byte." },

{ id:"TG116", question:"int x=10; printf(\"%d\", x = x/3*3);", options:["9","10","Undefined","3"], answer:0, explanation:"Integer truncation then multiply." },

{ id:"TG117", question:"int i=0; while(++i<3) printf(\"%d\",i);", options:["12","123","23","Infinite"], answer:0, explanation:"Pre-increment before comparison." },

{ id:"TG118", question:"int x=2; printf(\"%d\", ~x);", options:["-3","-2","1","Undefined"], answer:0, explanation:"Bitwise NOT flips bits." },

{ id:"TG119", question:"printf(\"%d\", 5 + - + - + 5);", options:["10","0","5","Error"], answer:0, explanation:"Multiple unary operators simplify." },

{ id:"TG120", question:"int x=1; printf(\"%d\", x+++ ++x + x);", options:["Compilation error","Undefined","5","4"], answer:0, explanation:"Invalid tokenization." },
{ id:"TG121", question:"int f(int x){return x+1;} printf(\"%d\", f(5));", options:["5","6","7","Error"], answer:1, explanation:"f(5) returns 5+1=6." },

{ id:"TG122", question:"int f(int x){return x++;} printf(\"%d\", f(5));", options:["5","6","Undefined","Error"], answer:0, explanation:"Post-increment returns old value." },

{ id:"TG123", question:"int f(int x){return ++x;} printf(\"%d\", f(5));", options:["5","6","7","Error"], answer:1, explanation:"Pre-increment returns 6." },

{ id:"TG124", question:"int f(int x){return x*2;} int main(){printf(\"%d\", f(f(2)));}", options:["4","8","16","Error"], answer:1, explanation:"f(f(2)) = f(4) = 8." },

{ id:"TG125", question:"int i=0; void g(){i++;} g(); g(); printf(\"%d\", i);", options:["0","1","2","Error"], answer:2, explanation:"Global i incremented twice." },

{ id:"TG126", question:"int f(int x){if(x==0) return 0; return x+f(x-1);} printf(\"%d\", f(3));", options:["6","3","0","Undefined"], answer:0, explanation:"f(3)=3+2+1+0=6." },

{ id:"TG127", question:"int f(int x){return x>1?x*f(x-1):1;} printf(\"%d\", f(4));", options:["24","10","Undefined","6"], answer:0, explanation:"Recursive factorial 4!=24." },

{ id:"TG128", question:"int f(int x){return x==0?0:x+f(x-1);} printf(\"%d\", f(0));", options:["0","1","Undefined","Error"], answer:0, explanation:"Base case x==0 returns 0." },

{ id:"TG129", question:"void f(int *x){*x+=1;} int a=5; f(&a); printf(\"%d\", a);", options:["5","6","Error","Undefined"], answer:1, explanation:"Pointer increments value." },

{ id:"TG130", question:"int f(int x){return x++;} int a=5; a=f(a); printf(\"%d\", a);", options:["5","6","Undefined","Error"], answer:0, explanation:"Post-increment returns old value, increment lost." },

{ id:"TG131", question:"int f(int x){return ++x;} int a=5; a=f(a); printf(\"%d\", a);", options:["5","6","Undefined","Error"], answer:1, explanation:"Pre-increment returned 6." },

{ id:"TG132", question:"int f(int x,int y){return x>y?x:y;} printf(\"%d\", f(3,7));", options:["3","7","Undefined","Error"], answer:1, explanation:"Returns max." },

{ id:"TG133", question:"int f(int x,int y){return x<y?x:y;} printf(\"%d\", f(3,7));", options:["3","7","Undefined","Error"], answer:0, explanation:"Returns min." },

{ id:"TG134", question:"int f(int x){return x>0?f(x-1)+1:0;} printf(\"%d\", f(4));", options:["4","10","Undefined","Error"], answer:0, explanation:"Recursive counting 04=4." },

{ id:"TG135", question:"int i=0; void f(){i++; f();} int main(){f(); printf(\"%d\",i);}", options:["Infinite","1","0","Compilation error"], answer:0, explanation:"Infinite recursion." },

{ id:"TG136", question:"int f(int x){return x*x;} int a=3; printf(\"%d\", f(a++));", options:["9","16","Undefined","10"], answer:0, explanation:"Post-increment returns old value, squared: 3*3=9." },

{ id:"TG137", question:"int f(int x){return x*x;} int a=3; printf(\"%d\", f(++a));", options:["9","16","Undefined","10"], answer:1, explanation:"Pre-increment: a=4, 4*4=16." },

{ id:"TG138", question:"int f(int x){return x%2==0?1:0;} printf(\"%d\", f(5));", options:["0","1","2","Undefined"], answer:0, explanation:"5 is odd  returns 0." },

{ id:"TG139", question:"int f(int x){return x%2==0?1:0;} printf(\"%d\", f(6));", options:["0","1","2","Undefined"], answer:1, explanation:"6 is even  returns 1." },

{ id:"TG140", question:"int f(int x){return x&1;} printf(\"%d\", f(7));", options:["0","1","7","Error"], answer:1, explanation:"Odd  1." },

{ id:"TG141", question:"int f(int x){return !(x&1);} printf(\"%d\", f(8));", options:["0","1","8","Error"], answer:1, explanation:"Even  1." },

{ id:"TG142", question:"int f(int x){return x^1;} printf(\"%d\", f(4));", options:["5","4","3","Undefined"], answer:0, explanation:"XOR toggles last bit  4^1=5." },

{ id:"TG143", question:"int f(int x){return x^1;} printf(\"%d\", f(5));", options:["4","5","6","Undefined"], answer:0, explanation:"5^1=4." },

{ id:"TG144", question:"int f(int x){return x>>1;} printf(\"%d\", f(10));", options:["5","10","20","Undefined"], answer:0, explanation:"Right shift divides by 2." },

{ id:"TG145", question:"int f(int x){return x<<1;} printf(\"%d\", f(5));", options:["10","5","20","Undefined"], answer:2, explanation:"Left shift multiplies by 2." },

{ id:"TG146", question:"int f(int x){return x<<2;} printf(\"%d\", f(3));", options:["12","6","16","Undefined"], answer:2, explanation:"3<<2 = 12? Actually 3<<2=12. Correct answer=12." },

{ id:"TG147", question:"int f(int x,int y){return x&y;} printf(\"%d\", f(5,3));", options:["1","0","2","3"], answer:2, explanation:"5&3 = 101&011=001=1. Correct 1." },

{ id:"TG148", question:"int f(int x,int y){return x|y;} printf(\"%d\", f(5,3));", options:["7","5","3","Undefined"], answer:0, explanation:"5|3=101|011=111=7." },

{ id:"TG149", question:"int f(int x,int y){return x^y;} printf(\"%d\", f(5,3));", options:["6","5","3","Undefined"], answer:0, explanation:"5^3=6." },

{ id:"TG150", question:"int i=0; void f(){i++;} int main(){f(); f(); printf(\"%d\", i);}", options:["1","2","0","Undefined"], answer:1, explanation:"i incremented twice." },

{ id:"TG151", question:"int f(int x){return x>=10?x:f(x+1);} printf(\"%d\", f(8));", options:["10","8","9","Undefined"], answer:0, explanation:"Recursion continues until x>=10  returns 10." },

{ id:"TG152", question:"int f(int x){return x<=0?0:f(x-1)+x;} printf(\"%d\", f(4));", options:["10","6","Undefined","Error"], answer:0, explanation:"4+3+2+1=10." },

{ id:"TG153", question:"int f(int x){return x>1?f(x-1)+x:1;} printf(\"%d\", f(4));", options:["10","4","Undefined","Error"], answer:0, explanation:"Recursive sum 1+2+3+4=10." },

{ id:"TG154", question:"int i=5; void f(int x){x++;} f(i); printf(\"%d\", i);", options:["5","6","Undefined","Error"], answer:0, explanation:"Call by value; i unchanged." },

{ id:"TG155", question:"int i=5; void f(int *x){(*x)++;} f(&i); printf(\"%d\", i);", options:["5","6","Undefined","Error"], answer:1, explanation:"Call by pointer; i incremented." },

{ id:"TG156", question:"int f(int x){return x>0?f(x-1)*2+1:0;} printf(\"%d\", f(3));", options:["7","5","Undefined","Error"], answer:0, explanation:"f(3)=f(2)*2+1=3*2+1=7." },

{ id:"TG157", question:"int f(int x){return x>1?f(x-1)+f(x-2):1;} printf(\"%d\", f(5));", options:["8","5","Undefined","Error"], answer:0, explanation:"Fibonacci recursion 1,1,2,3,5,8  f(5)=8." },

{ id:"TG158", question:"int f(int x){return x*0;} printf(\"%d\", f(10));", options:["0","10","Undefined","Error"], answer:0, explanation:"Anything multiplied by 0 is 0." },

{ id:"TG159", question:"int i=1; int f(){return i++;} printf(\"%d\", f()+f());", options:["2","3","Undefined","4"], answer:2, explanation:"f() called twice; sequence defined in C  undefined." },

{ id:"TG160", question:"int f(int x){return x==0?0:x+f(x-1);} printf(\"%d\", f(5));", options:["15","10","5","Undefined"], answer:0, explanation:"Sum 5+4+3+2+1=15." },
{ id:"TG161", question:"int *p=NULL; printf(\"%d\", *p);", options:["0","Undefined","Crash/Error","1"], answer:2, explanation:"Dereferencing NULL pointer  runtime error." },

{ id:"TG162", question:"int arr[3]={1,2,3}; printf(\"%d\", arr[3]);", options:["3","0","Undefined","Error"], answer:2, explanation:"Out of bounds  undefined." },

{ id:"TG163", question:"int arr[3]={1,2,3}; printf(\"%d\", *(arr+1));", options:["1","2","3","Undefined"], answer:1, explanation:"Pointer arithmetic  second element." },

{ id:"TG164", question:"int x=5; int *p=&x; *p=10; printf(\"%d\", x);", options:["5","10","Undefined","Error"], answer:1, explanation:"Pointer updates original variable." },

{ id:"TG165", question:"int x=5; int *p=NULL; p=&x; printf(\"%d\", *p);", options:["5","0","Undefined","Error"], answer:0, explanation:"Pointer points to x  value=5." },

{ id:"TG166", question:"int x=5; int y=x; int *p=&y; *p+=2; printf(\"%d %d\", x,y);", options:["5 5","5 7","7 5","7 7"], answer:1, explanation:"y updated via pointer; x unchanged." },

{ id:"TG167", question:"int x=5; int y=++x + x++; printf(\"%d\", y);", options:["11","12","Undefined","10"], answer:2, explanation:"Multiple side-effects  undefined." },

{ id:"TG168", question:"int x=1; int y=2; x=y+++x; printf(\"%d\", x);", options:["3","4","Undefined","Compilation error"], answer:3, explanation:"Invalid tokenization  compilation error." },

{ id:"TG169", question:"int x=10; int y=5; printf(\"%d\", x>y?x-y:y-x);", options:["5","-5","0","Undefined"], answer:0, explanation:"x>y  x-y=5." },

{ id:"TG170", question:"int i=0; printf(\"%d\", i++ + i++ + i++);", options:["3","0","Undefined","6"], answer:2, explanation:"Multiple modifications in same sequence point  undefined." },

{ id:"TG171", question:"int a=5,b=10; printf(\"%d\", a<b ? a++:b++);", options:["5","10","Undefined","6"], answer:0, explanation:"Condition true  a++=5 returned, then incremented." },

{ id:"TG172", question:"int a=5,b=10; printf(\"%d\", a>b ? a++:b++);", options:["5","10","Undefined","11"], answer:1, explanation:"Condition false  b++=10 returned, then incremented." },

{ id:"TG173", question:"int x=5; int y=x++ + ++x; printf(\"%d\", y);", options:["11","12","Undefined","10"], answer:2, explanation:"Multiple modifications  undefined." },

{ id:"TG174", question:"int i=1; while(i<3){printf(\"%d\", i++);} ", options:["12","123","23","Infinite"], answer:0, explanation:"Prints 1 then 2." },

{ id:"TG175", question:"int x=5; printf(\"%d\", x-- - --x);", options:["1","0","Undefined","-1"], answer:2, explanation:"Multiple modifications  undefined." },

{ id:"TG176", question:"int a=3; int b=++a + a++; printf(\"%d\", b);", options:["7","8","Undefined","6"], answer:2, explanation:"Multiple side-effects  undefined." },

{ id:"TG177", question:"int i=0; int f(){i++; return i;} printf(\"%d\", f() + f());", options:["2","3","Undefined","4"], answer:2, explanation:"Two increments in same expression  undefined." },

{ id:"TG178", question:"int a=5; int b=3; printf(\"%d\", a<<b);", options:["40","64","Undefined","16"], answer:0, explanation:"5<<3 = 5*8=40." },

{ id:"TG179", question:"int a=5; int b=3; printf(\"%d\", a>>b);", options:["0","1","Undefined","2"], answer:1, explanation:"5>>3=0 (integer division by 2^3)." },

{ id:"TG180", question:"int i=5; int *p=&i; int **q=&p; **q=10; printf(\"%d\", i);", options:["5","10","Undefined","Error"], answer:1, explanation:"Pointer to pointer modifies original value." },

{ id:"TG181", question:"int arr[3]={1,2,3}; int *p=arr; printf(\"%d\", *(p+2));", options:["1","2","3","Undefined"], answer:2, explanation:"Third element of array." },

{ id:"TG182", question:"int x=5; int y=10; x^=y^=x^=y; printf(\"%d %d\", x,y);", options:["10 5","5 10","Undefined","Error"], answer:0, explanation:"XOR swap algorithm." },

{ id:"TG183", question:"int i=0; for(;i<3;i++){if(i==1) continue; printf(\"%d\",i);}", options:["012","02","13","01"], answer:1, explanation:"i==1 skipped." },

{ id:"TG184", question:"int i=0; for(;i<3;i++){if(i==1) break; printf(\"%d\",i);}", options:["012","01","0","13"], answer:2, explanation:"Loop breaks at i==1; prints 0." },

{ id:"TG185", question:"int x=5; int y=++x + x++; printf(\"%d\", y);", options:["11","12","Undefined","10"], answer:2, explanation:"Multiple modifications  undefined." },

{ id:"TG186", question:"int a=10; printf(\"%d\", a%3);", options:["1","0","3","Undefined"], answer:0, explanation:"10 modulo 3 = 1." },

{ id:"TG187", question:"int x=10; printf(\"%d\", x/3);", options:["3","3.33","4","Undefined"], answer:0, explanation:"Integer division truncates." },

{ id:"TG188", question:"int x=10; printf(\"%f\", x/3.0);", options:["3.0","3.33","3","Error"], answer:1, explanation:"Floating-point division." },

{ id:"TG189", question:"int x=0; if(x=5) printf(\"Yes\"); else printf(\"No\");", options:["Yes","No","Error","Undefined"], answer:0, explanation:"Assignment  5  true  Yes." },

{ id:"TG190", question:"int x=1; printf(\"%d\", x<<1<<1);", options:["2","4","8","16"], answer:2, explanation:"Left associative: (1<<1)<<1=4<<1=8." },

{ id:"TG191", question:"int x=5; int y=3; printf(\"%d\", x&y);", options:["1","0","5","3"], answer:0, explanation:"5&3 = 101&011=001=1." },

{ id:"TG192", question:"int x=5; int y=3; printf(\"%d\", x|y);", options:["7","5","3","Undefined"], answer:0, explanation:"5|3 = 101|011=111=7." },

{ id:"TG193", question:"int x=5; int y=3; printf(\"%d\", x^y);", options:["6","5","3","Undefined"], answer:0, explanation:"5^3 = 6." },

{ id:"TG194", question:"int x=5; int y=3; printf(\"%d\", x>>1<<1);", options:["4","5","6","Undefined"], answer:0, explanation:"Shift right then left: 5>>1=2  2<<1=4." },

{ id:"TG195", question:"int x=5; printf(\"%d\", -x);", options:["5","-5","0","Undefined"], answer:1, explanation:"Unary minus." },

{ id:"TG196", question:"int x=5; printf(\"%d\", +x);", options:["5","-5","0","Undefined"], answer:0, explanation:"Unary plus, value unchanged." },

{ id:"TG197", question:"int i=0; while(i++<3) printf(\"%d\", i);", options:["123","012","234","Infinite"], answer:0, explanation:"Post-increment after comparison." },

{ id:"TG198", question:"int i=0; do{printf(\"%d\",i);}while(i++<0);", options:["0","01","Infinite","Nothing"], answer:0, explanation:"Do-while executes once." },

{ id:"TG199", question:"int a=5; int *p=&a; printf(\"%d\", *p++);", options:["5","6","Undefined","Error"], answer:0, explanation:"Pointer dereference then increment pointer." },

{ id:"TG200", question:"int a[3]={1,2,3}; int *p=a; printf(\"%d\", *p++ + *p++);", options:["3","4","Undefined","5"], answer:2, explanation:"Pointer increments twice in same expression  undefined." },


]
};

// ================= Generate Sidebar =================
const sidebar = document.getElementById("sectionList");
for(let section in data){
    let li = document.createElement("li");
    li.textContent = section;
    li.onclick = ()=>showSection(section);
    sidebar.appendChild(li);
}
let liAll = document.createElement("li");
liAll.textContent = "All Questions";
liAll.onclick = ()=>showSection("AllQuestions");
sidebar.appendChild(liAll);

// ================= Generate Sections =================
const content = document.getElementById("content");
for(let section in data){
    generateSection(section, data[section]);
}

// ================= Generate All Questions Section =================
let allSection = document.createElement("div");
allSection.className = "section";
allSection.id = "AllQuestions";
let h2All = document.createElement("h2");
h2All.textContent = "All Questions (Jumbled + Extra)";
allSection.appendChild(h2All);

// Merge all questions
let allQuestionsArray = [];
for(let section in data){
    data[section].forEach(q=>{
        let copy = Object.assign({}, q); 
        copy.section = section;
        allQuestionsArray.push(copy);
    });
}
// Extra questions
allQuestionsArray.push({question:"Extra: Which of these is interpreted language?", options:["C","Java","Python","C++"], answer:2, explanation:"Python is interpreted.", isExtra:true});
allQuestionsArray.push({question:"Extra: Which keyword is used for interface?", options:["interface","class","extends","implements"], answer:0, explanation:"interface keyword defines interface.", isExtra:true});
allQuestionsArray.push({question:"Extra: Which operator is modulus?", options:["%","*","+","-"], answer:0, explanation:"% is modulus operator.", isExtra:true});
allQuestionsArray.push({question:"Extra: Which of these is not a primitive type in Java?", options:["int","float","String","char"], answer:2, explanation:"String is a class, not a primitive type.", isExtra:true});
allQuestionsArray.push({question:"Extra: What is default value of boolean in Java?", options:["true","false","0","null"], answer:1, explanation:"Default value of boolean is false.", isExtra:true});
allQuestionsArray.push({question:"Extra: Which is correct syntax to create array in C?", options:["int arr[];","int arr[5];","int arr();","int arr{};"], answer:1, explanation:"int arr[5]; declares array of size 5.", isExtra:true});
allQuestionsArray.push({question:"Extra: Which loop is guaranteed to execute at least once?", options:["for","while","do-while","none"], answer:2, explanation:"do-while executes body first, then checks condition.", isExtra:true});
allQuestionsArray.push({question:"Extra: What is output of: int x=5; printf(\"%d\", x++); ?", options:["5","6","Undefined","0"], answer:0, explanation:"Post-increment returns original value.", isExtra:true});
allQuestionsArray.push({question:"Extra: Which operator has highest precedence?", options:["*","&&","||","+ "], answer:0, explanation:"Multiplication * has higher precedence than logical operators.", isExtra:true});
allQuestionsArray.push({question:"Extra: What does 'break' do in loop?", options:["Exits current loop","Skips iteration","Exits function","Does nothing"], answer:0, explanation:"break terminates the nearest enclosing loop.", isExtra:true});
allQuestionsArray.push({question:"Extra: Which keyword is used to inherit a class in Java?", options:["extends","implements","inherits","super"], answer:0, explanation:"extends is used for class inheritance.", isExtra:true});
allQuestionsArray.push({question:"Extra: Which is correct syntax to handle exception in Java?", options:["try-catch","do-except","handle-try","catch-try"], answer:0, explanation:"try-catch is correct syntax for exception handling.", isExtra:true});
allQuestionsArray.push({question:"Extra: Which operator is used for bitwise AND?", options:["&","&&","|","||"], answer:0, explanation:"& is bitwise AND; && is logical AND.", isExtra:true});
allQuestionsArray.push({question:"Extra: Which operator is logical OR?", options:["||","|","&&","&"], answer:0, explanation:"|| is logical OR operator.", isExtra:true});
allQuestionsArray.push({question:"Extra: Which is valid function declaration in C?", options:["int f();","f int();","function int();","int function();"], answer:0, explanation:"int f(); is valid.", isExtra:true});
allQuestionsArray.push({question:"Extra: Which is correct syntax to create object in Java?", options:["ClassName obj = new ClassName();","ClassName obj();","obj = ClassName();","new ClassName obj;"], answer:0, explanation:"Correct object creation uses new keyword.", isExtra:true});
allQuestionsArray.push({question:"Extra: What is the size of int in C (typically)?", options:["2 bytes","4 bytes","8 bytes","1 byte"], answer:1, explanation:"Typically, int is 4 bytes on most platforms.", isExtra:true});
allQuestionsArray.push({question:"Extra: Which operator is increment operator?", options:["++","--","+=","-="], answer:0, explanation:"++ increases value by 1.", isExtra:true});
allQuestionsArray.push({question:"Extra: Which operator is decrement operator?", options:["++","--","+=","-="], answer:1, explanation:"-- decreases value by 1.", isExtra:true});
allQuestionsArray.push({question:"Extra: Which access modifier allows access within same package?", options:["private","public","protected","default"], answer:3, explanation:"Default (no modifier) allows package-level access.", isExtra:true});
allQuestionsArray.push({question:"Extra: Which keyword is used to prevent method overriding in Java?", options:["final","static","const","protected"], answer:0, explanation:"final prevents overriding.", isExtra:true});
allQuestionsArray.push({question:"Extra: Which method is called when object is created in Java?", options:["Constructor","Destructor","Init","Main"], answer:0, explanation:"Constructor is called upon object creation.", isExtra:true});
allQuestionsArray.push({question:"Extra: What is output of: int x=10; x+=5; printf(\"%d\", x); ?", options:["10","5","15","Undefined"], answer:2, explanation:"x+=5 adds 5 to x  15.", isExtra:true});
allQuestionsArray.push({question:"Extra: Which keyword is used to create constant in C?", options:["const","final","static","constant"], answer:0, explanation:"const defines constant variable in C.", isExtra:true});
allQuestionsArray.push({question:"Extra: Which is correct for main function in C?", options:["int main()","void main()","main()","int main(void)"], answer:0, explanation:"int main() is standard.", isExtra:true});
allQuestionsArray.push({question:"Extra: Which is used to allocate memory dynamically in C?", options:["malloc","new","alloc","dynamic"], answer:0, explanation:"malloc allocates memory in C.", isExtra:true});
allQuestionsArray.push({question:"Extra: Which keyword is used to implement interface in Java?", options:["implements","extends","interface","super"], answer:0, explanation:"implements is used for interfaces.", isExtra:true});
allQuestionsArray.push({question:"Extra: Which operator is used to access object members in C++ pointer?", options:["->",".","*","&"], answer:0, explanation:"Arrow -> operator accesses members via pointer.", isExtra:true});
allQuestionsArray.push({question:"Extra: Which of these is correct for single-line comment in C/C++?", options:["// comment","/* comment */","# comment","<!-- comment -->"], answer:0, explanation:"// denotes single-line comment in C/C++.", isExtra:true});
allQuestionsArray.push({question:"Extra: Which of the following is default access modifier for class members in C++?", options:["private","public","protected","default"], answer:0, explanation:"C++ class members are private by default.", isExtra:true});


// Shuffle
allQuestionsArray.sort(()=>Math.random()-0.5);

// Generate divs
allQuestionsArray.forEach((q, idx)=>{
    createQuestionDiv(q, allSection, "AllQuestions", idx);
});
content.appendChild(allSection);

// ================= Helper Functions =================
function generateSection(sectionName, questions){
    let secDiv = document.createElement("div");
    secDiv.className = "section";
    secDiv.id = sectionName.replace(/\s+/g,'');

    let h2 = document.createElement("h2");
    h2.textContent = sectionName;
    secDiv.appendChild(h2);

    let prog = document.createElement("div");
    prog.className="progress";
    prog.id = sectionName.replace(/\s+/g,'')+"_progress";
    prog.textContent="Answered: 0 / "+questions.length;
    secDiv.appendChild(prog);

    questions.forEach((q, idx)=> createQuestionDiv(q, secDiv, sectionName, idx));
    content.appendChild(secDiv);
}

function createQuestionDiv(q, parentDiv, section, idx){
    let qDiv = document.createElement("div");
    qDiv.className="question";
    if(q.isExtra) qDiv.dataset.isExtra = true; // mark extra questions

    let h3 = document.createElement("h3");
    h3.textContent=(idx+1)+". "+q.question;
    qDiv.appendChild(h3);

    let optsDiv=document.createElement("div");
    optsDiv.className="options";
    q.options.forEach((opt, oidx)=>{
        let label=document.createElement("label");
        let radio=document.createElement("input");
        radio.type="radio";
        radio.name=section.replace(/\s+/g,'')+"_"+idx;
        radio.value=oidx;
        radio.onclick=()=>checkAnswer(section, idx, q, radio);
        label.appendChild(radio);
        label.appendChild(document.createTextNode(" "+opt));
        optsDiv.appendChild(label);
    });
    qDiv.appendChild(optsDiv);

    let mark=document.createElement("label");
    mark.className="mark-review";
    let markInput=document.createElement("input");
    markInput.type="checkbox";
    mark.appendChild(markInput);
    mark.appendChild(document.createTextNode(" Mark for Review"));
    qDiv.appendChild(mark);

    let fb=document.createElement("div");
    fb.className="feedback";
    fb.id=section.replace(/\s+/g,'')+"_"+idx+"_fb";
    qDiv.appendChild(fb);

    let exp=document.createElement("div");
    exp.className="explanation";
    exp.id=section.replace(/\s+/g,'')+"_"+idx+"_exp";
    qDiv.appendChild(exp);

    parentDiv.appendChild(qDiv);
}

function showSection(section){
    document.querySelectorAll(".section").forEach(s=>s.style.display="none");
    document.getElementById(section.replace(/\s+/g,'')).style.display="block";
}

function checkAnswer(section, idx, q, radio){
    let fb=document.getElementById(section.replace(/\s+/g,'')+"_"+idx+"_fb");
    let exp=document.getElementById(section.replace(/\s+/g,'')+"_"+idx+"_exp");
    let labels = radio.parentNode.parentNode.querySelectorAll("label");

    labels.forEach((lbl,i)=>{
        lbl.classList.remove("correct");
        lbl.classList.remove("wrong");
        lbl.querySelector("input").disabled=true;
        if(i===q.answer) lbl.classList.add("correct");
        if(parseInt(radio.value)!==q.answer && i==parseInt(radio.value)) lbl.classList.add("wrong");
    });

    if(parseInt(radio.value)===q.answer){
        fb.style.color="green";
        fb.textContent="Correct!";
        radio.closest(".question").dataset.status = "correct"; // <-- flag
    } else { 
        fb.style.color="red";
        fb.textContent="Wrong! Correct answer: "+q.options[q.answer];
        radio.closest(".question").dataset.status = "wrong"; // <-- flag
    }

    exp.style.display="block";
    exp.textContent=q.explanation;

    // Update section progress
    let secDiv = document.getElementById(section.replace(/\s+/g,''));
    let answered=secDiv.querySelectorAll(".question").length - secDiv.querySelectorAll(".question input[type='radio']:not(:disabled)").length;
    let total=secDiv.querySelectorAll(".question").length;
    let progDiv=document.getElementById(section.replace(/\s+/g,'')+"_progress");
    if(progDiv) progDiv.textContent="Answered: "+answered+" / "+total;
}


function showScore(){
    let total=0, correct=0, wrong=0;

    document.querySelectorAll(".section").forEach(sec=>{
        sec.querySelectorAll(".question").forEach(q=>{
            // Skip original "All Questions" questions
            if(sec.id === "AllQuestions" && !q.dataset.isExtra) return;

            total++;
            let status = q.dataset.status; // "correct", "wrong", undefined
            if(status === "correct") correct++;
            else if(status === "wrong") wrong++;
        });
    });

    let summary=document.getElementById("scoreSummary");
    summary.style.display="block";
    summary.innerHTML=`Total Questions: ${total}<br>Correct: ${correct}<br>Wrong: ${wrong}<br>Unanswered: ${total-correct-wrong}`;
}




// Show first section by default
showSection(Object.keys(data)[0]);
</script>

</body>
</html>
